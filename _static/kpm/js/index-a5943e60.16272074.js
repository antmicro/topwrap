"use strict";(self.webpackChunkpipeline_manager=self.webpackChunkpipeline_manager||[]).push([[197],{34580:(e,t,i)=>{i.d(t,{Wx:()=>G,dH:()=>L,L6:()=>_,kx:()=>R,Ay:()=>J,sA:()=>P});var a=i(63282),n=i(94541),s=i(25504),r=i(26061),o=i(63491),d=i(50953),c=i(46171),h=i(42302),l=i(41857),u=i(20641),p=i(96422);const f="COPY",g="DELETE",y="UNHIGHLIGHT",v="PASTE";var m=i(35851);class b{types=new Map;defaultStyle={interfaceConnectionPattern:"solid",interfaceConnectionColor:"#FFFFFF",interfaceColor:"#00E58D"};constructor(e){e.hooks.renderInterface.subscribe(this,(({intf:e,el:t})=>{if(e.type){const i=this.normalizeType(e.type).find((e=>void 0!==this.types[e]?.interfaceColor));if(void 0!==i){const e=this.types[i].interfaceColor,a=t.querySelector(".__port:not(.greyedout_arrow)");if(null!==a)a.style.backgroundColor=e;else{const e=t.querySelector(".__port");null!==e&&(e.style.backgroundColor=getComputedStyle(e).getPropertyValue("$gray-500"))}}}return{intf:e,el:t}}))}normalizeType(e){return"string"==typeof e||e instanceof String?[e]:e}getConnectionStyle(e,t){const i=this.normalizeType(e?.type),a=this.normalizeType(t?.type);if(void 0===e?.type)return this.defaultStyle;if(void 0===t?.type){const e=i.find((e=>void 0!==this.types[e]));return{...this.defaultStyle,...this.types[e]}}const n=i.filter((e=>a.includes(e)));if(Array.isArray(n)&&n.length>1)return this.defaultStyle;const s=n.find((e=>void 0!==this.types[e]));return{...this.defaultStyle,...this.types[s]}}readInterfaceTypes(e){this.types={},e?.interfaces&&Object.entries(e.interfaces).forEach((([e,t])=>{this.types[e]={...t,name:e}}))}}var w=i(8239),x=i(85022),$=i(75572),S=i(41686),N=i(78873),k=i(38703),V=i(80850);function E(e,t,i){const a=document.getElementById(e.nodeId);return((a?a.offsetTop:0)+i.y)*t}function M(e,t,i){const a=document.getElementById(e.nodeId);return((a?a.offsetTop+a.offsetHeight:0)+i.y)*t}function O(e,t,i,a,n){return[Math.sqrt(Math.abs((e-i)*(e-i)+(e-i)*(t-a)/n)),Math.sqrt(Math.abs((t-a)*(t-a)+(t-a)*(e-i)*n))]}class A{constructor(e,t,i,a,n){this.x1=e,this.y1=t,this.x2=i,this.y2=a,this.from=n.from,n.to&&(this.to=n.to,("input"===this.from.direction&&"output"===this.to.direction||"input"===this.from.direction&&"inout"===this.to.direction||"inout"===this.from.direction&&"output"===this.to.direction)&&([this.x1,this.x2,this.y1,this.y2]=[this.x2,this.x1,this.y2,this.y1],[this.from,this.to]=[this.to,this.from]))}}class C{style="curved";viewModel=null;randomizedOffset=!1;shiftDistance=15;getShift(e,t,i,a){const n=(e.sidePosition+t.sidePosition)/2;if(this.randomizedOffset){const s=this.getInterfaceNeighbors(e,i),r=this.getInterfaceNeighbors(t,i);let o=[...t.id].reduce(((e,t)=>e+t.charCodeAt(0)),0)??0,d=[...e.id].reduce(((e,t)=>e+t.charCodeAt(0)),0)??0;const c=o^d;d=c%s.length,o=c%r.length;const h=(d+o)/2;return this.shiftDistance*(h/2+n/2)*a}return this.shiftDistance*n*a}getMaxShift(e,t,i,a){const n=this.getInterfaceNeighbors(e,i).length-1,s=this.getInterfaceNeighbors(t,i).length-1;return this.shiftDistance*((n+s)/2)*a}getInterfaceNeighbors(e,t){const i=t.findNodeById(e.nodeId);return[...Object.values(i.inputs),...Object.values(i.outputs)].filter((t=>t.side===e.side&&t.port))}someAboveOrBelow(e,t,i){const a=E(e,i.scaling,i.panning),n=E(t,i.scaling,i.panning),s=M(e,i.scaling,i.panning),r=M(t,i.scaling,i.panning);return s<n||a>r}curvedRender(e,t,i,a,n){const s=new A(e,t,i,a,n),r=.3*Math.abs(s.x1-s.x2);if(s.to){if("right"===s.from.side&&"left"===s.to.side)return`M ${s.x1} ${s.y1} C ${s.x1+r} ${s.y1}, ${s.x2-r} ${s.y2}, ${s.x2} ${s.y2}`;if("left"===s.from.side&&"right"===s.to.side)return`M ${s.x1} ${s.y1} C ${s.x1-r} ${s.y1}, ${s.x2+r} ${s.y2}, ${s.x2} ${s.y2}`;if("right"===s.from.side&&"right"===s.to.side){const e=Math.max(s.x1+r,s.x2+r);return`M ${s.x1} ${s.y1} C ${e} ${s.y1}, ${e} ${s.y2}, ${s.x2} ${s.y2}`}if("left"===s.from.side&&"left"===s.to.side){const e=Math.min(s.x1-r,s.x2-r);return`M ${s.x1} ${s.y1} C ${e} ${s.y1}, ${e} ${s.y2}, ${s.x2} ${s.y2}`}}return"right"===s.from.side?`M ${s.x1} ${s.y1} C ${s.x1+r} ${s.y1}, ${s.x2-r} ${s.y2}, ${s.x2} ${s.y2}`:"left"===s.from.side?`M ${s.x1} ${s.y1} C ${s.x1-r} ${s.y1}, ${s.x2+r} ${s.y2}, ${s.x2} ${s.y2}`:void 0}curvedRenderLoopback(e,t,i,a,n){const s=this.viewModel.displayedGraph,r=new A(e,t,i,a,n),o=10*s.scaling;if(r.from.id===r.to.id){const e=this.getShift(r.from,r.to,s,s.scaling)+30*s.scaling,t="right"===r.from.side?r.x1+e:r.x1-e;return`M ${r.x1} ${r.y1}\n            A ${o} ${o/2} 0 0 0 ${t} ${r.y1}\n            A ${o} ${o/2} 0 0 0 ${r.x1} ${r.y1}`}if("left"===r.from.side&&"left"===r.to.side){const e=o,t=Math.abs(r.y1-r.y2)/2,i=r.y1>r.y2?1:0;return`M ${r.x1} ${r.y1}\n            A ${e} ${t} 0 0 ${i} ${r.x2} ${r.y2}`}if("right"===r.from.side&&"right"===r.to.side){const e=o,t=Math.abs(r.y1-r.y2)/2,i=r.y1>r.y2?0:1;return`M ${r.x1} ${r.y1}\n            A ${e} ${t} 0 0 ${i} ${r.x2} ${r.y2}`}const d=this.getShift(r.from,r.to,s,s.scaling)+30*s.scaling,c="left"===r.from.side?r.x1:r.x2,h="right"===r.to.side?r.x2:r.x1,l="left"===r.from.side?r.y1:r.y2,u="right"===r.to.side?r.y2:r.y1,p=M(r.from,s.scaling,s.panning),f=p+d,g=h-d,y=(f+u)/2,[v,m]=O(h,f,g,y,1),b=(h+c)/2,w=p,[x,$]=O(h,f,b,w,1),S=c+d,N=(f+l)/2,[k,V]=O(c,f,S,N,-1);return`M ${h} ${u}\n        A ${v} ${m} 0 0 1 ${h} ${f}\n        A ${x} ${$} 0 0 1 ${c} ${f}\n        A ${k} ${V} 0 0 1 ${c} ${l}`}orthogonalAnchorsPath(e,t,i){const a=e.map((e=>{return{x:((t=e).x+i.panning.x)*i.scaling,y:(t.y+i.panning.y)*i.scaling};var t})),n=[{x:t.x1,y:t.y1}];let s=t.from.side;if("right"===s?n.push({x:t.x1+10,y:t.y1}):"left"===s&&n.push({x:t.x1-10,y:t.y1}),s="horizontal",a.forEach((e=>{"vertical"===s?(n.push({x:n[n.length-1].x+(e.x-n[n.length-1].x)/2,y:n[n.length-1].y}),n.push({x:n[n.length-2].x+(e.x-n[n.length-2].x)/2,y:e.y}),n.push({x:e.x,y:e.y}),s="horizontal"):(n.push({x:n[n.length-1].x,y:n[n.length-1].y+(e.y-n[n.length-1].y)/2}),n.push({x:e.x,y:n[n.length-2].y+(e.y-n[n.length-2].y)/2}),n.push({x:e.x,y:e.y}),s="vertical")})),"vertical"===s)n.push({x:n[n.length-1].x+(t.x2-n[n.length-1].x)/2,y:n[n.length-1].y}),n.push({x:n[n.length-2].x+(t.x2-n[n.length-2].x)/2,y:t.y2}),n.push({x:t.x2,y:t.y2});else{n.push({x:n[n.length-1].x,y:n[n.length-1].y+(t.y2-n[n.length-1].y)/2});let e=0;e="left"===t.to.side?10:-10,n.push({x:t.x2-e,y:n[n.length-2].y+(t.y2-n[n.length-2].y)/2}),n.push({x:t.x2-e,y:t.y2}),n.push({x:t.x2,y:t.y2})}return n}orthogonalRender(e,t,i,a,n){const s=this.viewModel.displayedGraph,r=new A(e,t,i,a,n);if(void 0!==n.anchors&&n.anchors.length)return this.orthogonalAnchorsPath(n.anchors,r,s);const o=30*s.scaling,d=(r.x1+r.x2)/2;if(n.to){const e=this.getShift(r.from,r.to,s,s.scaling);if("right"===r.from.side&&"left"===r.to.side){const t=Math.max(r.x1,d)+e+o,i=t<r.x2-e-o?r.x1+e+o:t,a=r.x2-e-o;return t>=r.x2-e-o&&(i>r.x2-o||a<r.x1-o)?`M ${r.x1} ${r.y1}\n                    H ${i}\n                    V ${(r.y1+r.y2)/2}\n                    H ${a}\n                    V ${r.y2}\n                    H ${r.x2}`:`M ${r.x1} ${r.y1} H ${t} V ${r.y2} H ${r.x2}`}if("left"===r.from.side&&"right"===r.to.side){const t=Math.max(r.x2,d)+e+o,i=t<r.x1-e-o?r.x2+e+o:t,a=r.x1-e-o;return t>=r.x1-e-o&&(i>r.x1-o||a<r.x2-o)?`M ${r.x2} ${r.y2}\n                    H ${i}\n                    V ${(r.y1+r.y2)/2}\n                    H ${a}\n                    V ${r.y1}\n                    H ${r.x1}`:`M ${r.x2} ${r.y2} H ${t} V ${r.y1} H ${r.x1}`}if("right"===r.from.side&&"right"===r.to.side)return`M ${r.x1} ${r.y1} H ${Math.max(r.x1,r.x2,d)+e+o} V ${r.y2} H ${r.x2}`;if("left"===r.from.side&&"left"===r.to.side)return`M ${r.x1} ${r.y1} H ${Math.min(r.x1,r.x2,d)-e-o} V ${r.y2} H ${r.x2}`}return`M ${r.x1} ${r.y1} H ${d} V ${r.y2} H ${r.x2}`}orthogonalRenderLoopback(e,t,i,a,n){const s=this.viewModel.displayedGraph,r=new A(e,t,i,a,n),o=this.getShift(r.from,r.to,s,s.scaling)+30*s.scaling;if(void 0!==n.anchors&&n.anchors.length){const e=n.anchors.map((e=>({x:(e.x+s.panning.x)*s.scaling,y:(e.y+s.panning.y)*s.scaling}))),t=[{x:r.x1,y:r.y1}],i="right"===r.from.side?o:-o;return t.push({x:r.x1+i,y:r.y1}),e.forEach((e=>{t.push({x:t[t.length-1].x,y:e.y}),t.push({x:e.x,y:e.y}),t.push({x:e.x,y:e.y})})),t.push({x:t[t.length-1].x,y:r.y2}),t.push({x:r.x2+i,y:r.y2}),t.push({x:r.x2,y:r.y2}),t}const d=M(r.from,s.scaling,s.panning)+o;return"right"===r.from.side&&"left"===r.to.side?`M ${r.x1} ${r.y1}\n            h ${o}\n            V ${d} H ${r.x2-o} V ${r.y2} H ${r.x2}`:"left"===r.from.side&&"right"===r.to.side?`M ${r.x2} ${r.y2}\n            h ${o}\n            V ${d} H ${r.x1-o} V ${r.y1} H ${r.x1}`:"right"===r.from.side&&"right"===r.to.side?`M ${r.x2} ${r.y2}\n            h ${o}\n            V ${r.y1} H ${r.x1}`:"left"===r.from.side&&"left"===r.to.side?`M ${r.x2} ${r.y2}\n            h ${-o}\n            V ${r.y1} H ${r.x1}`:void 0}alternativeOrthogonalRender(e,t,i,a,n){const s=this.viewModel.displayedGraph,r=new A(e,t,i,a,n);if(void 0!==n.anchors&&n.anchors.length)return this.orthogonalAnchorsPath(n.anchors,r,s);const o=30*s.scaling,d=(r.x1+r.x2)/2;if(n.to){const e=this.getShift(r.from,r.to,s,s.scaling),t=this.getMaxShift(r.from,r.to,s,s.scaling)||1,i=Math.abs(r.x1-r.x2)-2*o,a=o*(2+t/s.scaling/30),n=i<a,c=2*a;let h;h=i<c?e/t*i:e/t*c+(i-c)/2;const l=this.someAboveOrBelow(r.from,r.to,s);if("right"===r.from.side&&"left"===r.to.side){const i=r.x1>r.x2;if(l&&n||i){const i=r.x1+o+e/t*a,n=r.x2-o+(e/t-1)*a;return`M ${r.x1} ${r.y1}\n                    H ${i}\n                    V ${(r.y1+r.y2)/2}\n                    H ${n}\n                    V ${r.y2}\n                    H ${r.x2}`}const s=r.x1+o+h;return`M ${r.x1} ${r.y1} H ${s} V ${r.y2} H ${r.x2}`}if("left"===r.from.side&&"right"===r.to.side){const i=r.x2>r.x1;if(l&&n||i){const i=r.x2+o+e/t*a,n=r.x1-o+(e/t-1)*a;return`M ${r.x2} ${r.y2}\n                    H ${i}\n                    V ${(r.y1+r.y2)/2}\n                    H ${n}\n                    V ${r.y1}\n                    H ${r.x1}`}const s=r.x2+o+h;return`M ${r.x2} ${r.y2} H ${s} V ${r.y1} H ${r.x1}`}if("right"===r.from.side&&"right"===r.to.side)return`M ${r.x1} ${r.y1} H ${Math.max(r.x1,r.x2,d)+e+o} V ${r.y2} H ${r.x2}`;if("left"===r.from.side&&"left"===r.to.side)return`M ${r.x1} ${r.y1} H ${Math.min(r.x1,r.x2,d)-e-o} V ${r.y2} H ${r.x2}`}return`M ${r.x1} ${r.y1} H ${d} V ${r.y2} H ${r.x2}`}alternativeOrthogonalRenderLoopback(e,t,i,a,n){return this.orthogonalRenderLoopback(e,t,i,a,n)}straightRender(e,t,i,a,n){const s=this.viewModel.displayedGraph;return[{x:e,y:t}].concat((n.anchors??[]).map((e=>({x:(e.x+s.panning.x)*s.scaling,y:(e.y+s.panning.y)*s.scaling})))).concat([{x:i,y:a}])}straightRenderLoopback(e,t,i,a,n){return this.curvedRenderLoopback(e,t,i,a,n)}constructor(e,t,i=!1){this.viewModel=e,this.style=t,this.randomizedOffset=i}render(e,t,i,a,n){const s=this.isLoopback(n)?"Loopback":"";return this[`${this.style}Render${s}`](e,t,i,a,n)}isLoopback(e){return!!e.to&&e.from.nodeId===e.to.nodeId}supportsAnchors(){return["orthogonal","alternativeOrthogonal","straight"].includes(this.style)}}var T=i(22048);class I{constructor(){Object.entries(S.properties).forEach((([e,t])=>{this[e]=t.default}))}}const j="New Node Type",G="New Node Type",H="New Graph Node",L="New Graph Node",R="__new",_="__edited";async function P(e){const t=function(e){if(e.startsWith("data:application/json"))return e;let t="{}";"undefined"!=typeof document&&(t=`${document.location.href.split("/").slice(0,-1).join("/")}/{}`);const i={NODE_ENV:"production",VUE_APP_STATIC:"true",VUE_APP_VERBOSE:"false",VUE_APP_GRAPH_DEVELOPMENT_MODE:"false",BASE_URL:""}.VUE_APP_JSON_URL_SUBSTITUTES??`{"https": "https://{}", "http": "http://{}", "relative": "${t}"}`,a=JSON.parse(i),n=e.split("//");if(n.length<2)return;const s=n[0].substring(0,n[0].length-1),r=n.slice(1).join("");return Object.keys(a).includes(s)?a[s].replace("{}",r):void 0}(e);if(void 0===t)return[!1,`Could not download the resource from:  ${e}.`];let i;try{i=await fetch(t,{mode:"cors"})}catch(e){return[!1,e.message]}try{return[!0,await i.json()]}catch(e){return[!1,e.message]}}class J{static instance;defaultMetadata=new I;editor=new m.A;baklavaView=(0,o.AP)(this.editor);specificationLoaded=(0,d.KR)(!1);specification=T.A.getInstance();updatedMetadata={};relatedGraphsStore=[];externalApplicationManager;constructor(){this.editor.editorManager=this,this.editor.unregisterNodes(),this.baklavaView.connectionRenderer=new C(this.baklavaView,this.defaultMetadata.connectionStyle,this.defaultMetadata.randomizedOffset),this.baklavaView.editor.layoutManager.useAlgorithm(this.defaultMetadata.layout),this.baklavaView.interfaceTypes=new b(this.baklavaView),this.baklavaView.layers=this.defaultMetadata.layers,this.baklavaView.collapseSidebar=this.defaultMetadata.collapseSidebar,this.baklavaView.movementStep=this.defaultMetadata.movementStep,this.baklavaView.editor.allowLoopbacks=this.defaultMetadata.allowLoopbacks,this.baklavaView.navbarItems=this.defaultMetadata.navbarItems,this.baklavaView.cache={},this.baklavaView.logLevel=this.defaultMetadata.logLevel,this.baklavaView.settings.editableNodeTypes=this.defaultMetadata.editableNodeTypes,this.baklavaView.settings.hideAnchors=this.defaultMetadata.hideAnchors,this.baklavaView.settings.showIds=this.defaultMetadata.showIds,this.baklavaView.settings.newGraphNode=this.defaultMetadata.newGraphNode,this.specificationVersion=x.version,this.baklavaView.commandHandler=(0,o.TE)(),this.baklavaView.history=null,this.baklavaView.history=(0,l.W6)((0,d.ux)(this.baklavaView).displayedGraph,this.baklavaView.commandHandler),this.baklavaView.clipboard=function(e,t,i){const a=Symbol("ClipboardToken"),n=(0,d.KR)(""),s=(0,d.KR)(""),r=(0,d.KR)(0),c=(0,u.EW)((()=>!n.value)),m=(e,t,i)=>{for(let a=0;a<e.length;a+=1){let n;if(i&&"input"!==i||(n=Object.values(e[a].inputs).find((e=>e.id===t))),n||i&&"output"!==i||(n=Object.values(e[a].outputs).find((e=>e.id===t))),n)return n}};return i.registerCommand(g,{canExecute:()=>e.value.selectedNodes.length>0,execute:()=>{const{viewModel:t}=(0,o.if)();t.value.editor.readonly||((0,l.nb)(),e.value.selectedNodes.forEach((e=>{(0,p.bf)(e)})),(0,l.wH)())}}),i.registerHotkey(["Delete"],g),i.registerCommand(y,{canExecute:()=>!0,execute:()=>{e.value.selectedNodes=[]}}),i.registerHotkey(["Escape"],y),i.registerCommand(f,{canExecute:()=>!0,execute:()=>{const t=e.value.selectedNodes.flatMap((e=>[...Object.values(e.inputs),...Object.values(e.outputs)])),i=e.value.connections.filter((e=>t.includes(e.from)||t.includes(e.to))).map((e=>({from:e.from.id,to:e.to.id})));s.value=JSON.stringify(i),n.value=JSON.stringify(e.value.selectedNodes.map((e=>e.save()))),r.value=0}}),i.registerHotkey(["Control","c"],f),i.registerCommand(v,{canExecute:()=>!c.value,execute:()=>{var d;const{viewModel:u}=(0,o.if)();if(c.value||u.value.editor.readonly)return;(0,l.nb)();const p=null!==(d=u.value.movementStep)&&void 0!==d?d:1,f=new Map,g=JSON.parse(n.value),y=JSON.parse(s.value),v=[],b=[],w=e.value;i.executeCommand("START_TRANSACTION");for(let i=0;i<g.length;i+=1){const n=t.value.nodeTypes.get(g[i].name);if(!n)return;let s=new n.type;v.push(s),s.hooks.beforeLoad.subscribe(a,(e=>{const t=e;return t.position&&(r.value+=1,t.position.x+=r.value*Math.max(40,p),t.position.y+=r.value*Math.max(40,p)),void 0!==g[i].graphState&&g[i].graphState.nodes.forEach((e=>{void 0!==e.type&&(e.name=e.type)})),s.hooks.beforeLoad.unsubscribe(a),t})),s=w.addNode(s);const o=e=>{const t=(0,h.A)();f.set(e.id,t),e.id=t},d=e=>{o(e),void 0!==e.graphState?(o(e.graphState),e.graphState.nodes.forEach((e=>{d(e)})),e.interfaces.forEach((e=>{var t;e.id=null!==(t=f.get(e.id))&&void 0!==t?t:e.id,void 0!==e.externalName&&(e.externalName=w.resolveNewExposedName(e.externalName))})),e.graphState.connections.forEach((e=>{if(void 0===f.get(e.from)||void 0===f.get(e.to))throw new Error(`Error when executing copy and paste. Connection from interface ${e.from} to ${e.to} is invalid`);e.from=f.get(e.from),e.to=f.get(e.to)}))):e.interfaces.forEach((e=>{o(e),void 0!==e.externalName&&(e.externalName=w.resolveNewExposedName(e.externalName))}))};d(g[i]),s.load(Object.assign(Object.assign({},g[i]),{id:s.id})),void 0!==e.value.graphNode&&e.value.graphNode.updateExposedInterfaces()}for(let e=0;e<y.length;e+=1){const t=f.get(y[e].from),i=f.get(y[e].to);if(t&&i){const e=m(v,t,"output"),a=m(v,i,"input");if(e&&a){const t=w.addConnection(e,a);t&&b.push(t)}}}return(0,l.wH)(),{newNodes:v,newConnections:b}}}),i.registerHotkey(["Control","v"],v),i.registerCommand("CLEAR_CLIPBOARD",{canExecute:()=>!0,execute:()=>{n.value="",s.value=""}}),(0,d.Kh)({isEmpty:c})}((0,d.ux)(this.baklavaView).displayedGraph,(0,d.KR)(this.baklavaView.editor),this.baklavaView.commandHandler),this.modifiedNodeSpecificationRegistry={}}async updateEditorSpecification(e,t=!1,i=!0,a=null){if(!e)return["No specification passed"];if("string"==typeof e||e instanceof String)try{e=r.parse(e)}catch(e){return{errors:[e],warnings:[]}}let n,s;this.isSpecificationLoaded()&&(n=this.saveDataflow(),s=this.baklavaView.displayedGraph.sidebar.nodeId,this.clearEditorManagerState());const o=[],c=[],h=[],{version:l}=e;if(this.specification.currentSpecification||(void 0===l?o.push(`Loaded specification has no version assigned. Please update the specification to version ${this.specificationVersion}.`):l!==this.specificationVersion&&h.push(`The specification format version (${l}) differs from the current specification format version (${this.specificationVersion}). It may result in unexpected behaviour.`)),i&&o.push(...J.unmarkNewNodes(e)),this.specification.unresolvedSpecification=(0,d.Kh)(JSON.parse(JSON.stringify(e))),this.specification.currentSpecification=e,!t){this.globalVisitedSpecs=new Set;const t=Object.fromEntries(Object.entries({include:e.include,urloverrides:e.urloverrides}).filter((([e,t])=>void 0!==t))),{specification:n,errors:s,warnings:r}=await this.downloadNestedImports(t,void 0,a);if(c.push(...s),o.push(...r),c.length)return{errors:c,warnings:o,info:h};i&&o.push(...J.unmarkNewNodes(n));const{graphs:d,errors:l}=await J.includeGraphs(e.includeGraphs??[]);if(c.push(...l),c.length)return{errors:c,warnings:o,info:h};n.graphs=(n.graphs??[]).concat(d),this.specification.includedSpecification=JSON.parse(JSON.stringify(n));const{errors:u,warnings:p}=J.mergeObjects(e,n);if(c.push(...u),o.push(...p),c.length)return{errors:c,warnings:o,info:h};const{metadata:f}=e;if(c.push(...this.updateMetadata(f,!1,!0)),c.length)return{errors:c,warnings:o,info:h};const{errors:g,warnings:y}=await this.updateGraphSpecification(e);c.push(...g),o.push(...y)}if(0===c.length?this.setSpecificationLoaded(!0):this.clearEditorManagerState(),void 0!==n&&void 0===e.entryGraph&&(!(await this.loadDataflow(n)).errors.length&&s?(this.baklavaView.displayedGraph.sidebar.nodeId=s,this.baklavaView.displayedGraph.sidebar.visible=!0):this.relatedGraphsStore.forEach((e=>this.baklavaView.editor.registerGraph(e)))),this.externalApplicationManager){const e=this.specification.currentSpecification;await this.externalApplicationManager.notifyAboutChange("specification_on_change",{specification:e})}return{errors:c,warnings:o,info:h}}clearEditorManagerState(){this.baklavaView.editor.unregisterGraphs(),this.baklavaView.editor.deepCleanEditor(),this.baklavaView.editor.unregisterNodes(),this.baklavaView.editor.nodeStyles.clear(),this.setSpecificationLoaded(!1),this.specification.currentSpecification={},this.specification.includedSpecification={},this.specification.unresolvedSpecification=(0,d.Kh)({})}isSpecificationLoaded(){return"boolean"==typeof this.specificationLoaded?this.specificationLoaded:this.specificationLoaded.value}setSpecificationLoaded(e){"boolean"==typeof this.specificationLoaded?this.specificationLoaded=e:this.specificationLoaded.value=e}async downloadNestedImports(e,t=new Set,i=null){const a=[],n=[],s=[],r=new Set,o=e.include??[];return await Promise.all(o.map((async e=>{let i;if("object"==typeof e&&null!==e&&({url:e,style:i}=e),r.has(e))n.push(`Specification is included multiple times, skipping ${e}`);else if(t.has(e))n.push(`Circular dependency detected in included specification ${e}`);else if(r.add(e),!this.globalVisitedSpecs.has(e)){this.globalVisitedSpecs.add(e);const[a,r]=await P(e);!1===a?n.push(`Could not load the included specification from ${e}. Reason: ${r}`):s.push({specification:r,trace:new Set([...t,e]),style:i})}}))),n.length||await Promise.all(s.map((async({specification:t,trace:s,style:r})=>{const{specification:o,errors:d,warnings:c}=await this.downloadNestedImports(t,s,i);n.push(...d),a.push(...c),void 0!==r&&J.includeWithStyle(o,r),J.applyUrlOverrides(o,{...e.urloverrides??{},...i??{}});const{errors:h,warnings:l}=J.mergeObjects(e,o);n.push(...h),a.push(...l)}))),{specification:e,errors:n,warnings:a}}static async includeGraphs(e){const t=[],i=[];if(0===e.length)return{graphs:i,errors:t};if(e.length!==new Set(e).size)return t.push("Duplicate subgraph includes detected. Aborting."),{graphs:i,errors:t};const a=[];if(await Promise.all(e.map((async e=>{const[i,n]=await P(e.url);!1!==i?a.push(n):t.push(`Could not load the included dataflow from '${e.url}'. Reason: ${n}`)}))),t.length)return{graphs:i,errors:t};for(let n=0;n<e.length;n+=1){const s=a[n],r=e[n];if(1!==s.graphs.length){t.push(`Only single graph dataflows are supported. Aborting loading subgraph include from ${r.url}.`);continue}const o=s.graphs[0];o.name=r.name??o.name,void 0!==o.name?void 0===i.find((e=>e.name===o.name))?i.push(o):t.push(`Included graph from ${r.url} has a duplicate name`):t.push(`Included subgraph from ${r.url} does not have a name defined.`)}return{graphs:i,errors:t}}registerDefaultNodes(){const e=[],t=[];if(this.editor.nodeTypes.has(L))return e.push(`Node name '${H}' is reserved by the editor, but it was included in the specification. Please change the name of the graph node to avoid conflicts.`),{errors:e,warnings:t};if(this.editor.nodeTypes.has(G))return e.push(`Node name '${j}' is reserved by the editor, but it was included in the specification. Please change the name of the graph node to avoid conflicts.`),{errors:e,warnings:t};const i={name:j,category:"Default"};this._registerNodeType(i);const a={name:H,category:"Graphs"},n=(0,w.$o)([],[],H,this.baklavaView.editor);return a.subgraphId=n.id,Array.isArray(n)&&n.length?e.push(...n):this.baklavaView.editor.addGraphTemplate(n,a),{errors:e,warnings:t}}updateExtendingNodes(e,t){const i=this.specification.unresolvedSpecification.nodes.filter((e=>e.extends?.includes(t)))??[],a=this.specification.currentSpecification.nodes.filter((e=>e.extends?.includes(t)))??[];[...i,...a].forEach((i=>{i.category=e.category,i.extends.forEach(((a,n)=>{a===t&&(i.extends[n]=J.getNodeName(e))}))})),new Map(a.map((e=>[e.name,e]))).forEach(((e,t)=>{this._unregisterNodeType(t);const{viewModel:i}=(0,o.if)(),{editor:a}=i.value;Array.from(a.graphs).map((e=>e.nodes)).flat().filter((e=>e.type===t)).forEach((t=>{Object.entries(structuredClone((0,d.ux)(e))).forEach((([e,i])=>{void 0!==i&&"interfaces"!==e&&"properties"!==e&&(t[e]=structuredClone((0,d.ux)(i)))}))})),this._registerNodeType(structuredClone((0,d.ux)(e)))}))}updateParentNode(e,t){e?.extends?.forEach((i=>{const a=this.baklavaView.editor.parentNodes.get(i);a.extending?.includes(t)&&a.extending.splice(a.extending.indexOf(t),1,e.name)})),this.baklavaView.editor.parentNodes.has(t)&&this.baklavaView.editor.parentNodes.delete(t),this.baklavaView.editor.parentNodes.set(e.name,e)}addNodeToEditorSpecification(e,t=void 0,i=!0){Object.entries(e.properties??{}).forEach((([e,t])=>{Object.keys(t).forEach((e=>{void 0===t[e]&&delete t[e]}))})),Object.entries(e.interfaces??{}).forEach((([e,t])=>{Object.keys(t).forEach((e=>{void 0===t[e]&&delete t[e]}))}));let a=this.validateNode(e);if(a.length)return a;if(void 0===this.specification.currentSpecification){const t={nodes:[e]};return this.updateEditorSpecification(t,!1,!1)}if(this.specification.unresolvedSpecification.nodes??=[],void 0!==t){const n=this.specification.unresolvedSpecification.nodes.find((e=>J.getNodeName(e)===t)),s=this.specification.currentSpecification.nodes.find((e=>J.getNodeName(e)===t));if(void 0===s){if(Object.entries(e).forEach((([e,t])=>{void 0!==t&&(n[e]=structuredClone((0,d.ux)(t)))})),a=this._registerNodeType(n),a.length)return{errors:a,warnings:[]}}else{void 0===n?(e.includeName=t,this.specification.unresolvedSpecification.nodes.push(e)):(i&&Object.keys(n).filter((t=>!(t in e))).forEach((e=>{delete n[e]})),Object.entries(e).forEach((([e,t])=>{void 0!==t&&(n[e]=JSON.parse(JSON.stringify(t)))}))),Object.entries(e).forEach((([e,t])=>{void 0!==t&&(s[e]=JSON.parse(JSON.stringify(t)))}));const r=J.getNodeName(e);s.name=r;const o=this.specification.currentSpecification.nodes.filter((e=>e.extends?.includes(t))).map((e=>J.getNodeName(e)));if(void 0!==o&&(s.extending=o),a=this._registerNodeType(s),a.length)return{errors:a,warnings:[]};if(this.baklavaView.editor.nodeTypes.get(r).isCategory&&this.updateExtendingNodes(JSON.parse(JSON.stringify(e)),t),e.name!==t&&this.updateParentNode(s,t),void 0!==s.subgraphId){let e,t;this.specification.currentSpecification.graphs.forEach((i=>{s.subgraphId===i.id&&(e=s,t=i)}));const i=(0,w.$o)(t.nodes,t.connections,t.name,this.baklavaView.editor);this.baklavaView.editor.addGraphTemplate(i,e)}}}else{if(a=this._registerNodeType(e),a.length)return{errors:a,warnings:[]};this.specification.unresolvedSpecification.nodes.push(e)}if(this.externalApplicationManager){const e=this.specification.unresolvedSpecification;this.externalApplicationManager.notifyAboutChange("specification_on_change",{specification:e}).then()}return{errors:[],warnings:[]}}addSubgraphToNode(e,t=[],i=[]){this._unregisterNodeType(e.type);const a=(0,w.$o)(t,i,e.type,this.baklavaView.editor);if(Array.isArray(a)&&a.length)return a;const n=this.specification.unresolvedSpecification.nodes.find((t=>J.getNodeName(t)===e.type)),s=this.specification.currentSpecification.nodes.find((t=>J.getNodeName(t)===e.type));void 0===s?(n.subgraphId=a.id,this.baklavaView.editor.addGraphTemplate(a,n)):(s.subgraphId=a.id,void 0===n?this.specification.unresolvedSpecification.nodes.push(s):n.subgraphId=a.id,this.baklavaView.editor.addGraphTemplate(a,s));const{viewModel:r}=(0,o.if)(),{displayedGraph:d}=r.value;return d.nodes.filter((t=>t.type===e.type)).forEach((t=>{d.replaceNode(t,e.type)})),[]}_registerNodeType(e){if(this.baklavaView.editor.nodeTypes.has(e.name))return[`Node of type ${e.name} is already registered`];const t=(0,w.Wo)(e.name,e.layer,e.interfaces??[],e.properties??[],e.interfaceGroups??[],e.defaultInterfaceGroups??[],e.twoColumn??this.baklavaView.twoColumn??!1,e.description??"",e.extends??[],e.extending??[],e.siblings??[],e.width??300);if(Array.isArray(t)&&t.length)return t;if(this.baklavaView.editor.registerNodeType(t,{title:e.name,category:e.category,isCategory:e.isCategory??!1,color:e.color,style:e.style,pill:e.pill,subgraphId:e.subgraphId,relatedGraphs:e.relatedGraphs}),"icon"in e){const t="string"==typeof e.icon?e.icon:this.getMetadataIcon(e.icon);this.baklavaView.editor.nodeIcons.set(e.name,t)}return"urls"in e&&Object.entries(e.urls).forEach((([t,i])=>{this.baklavaView.editor.nodeURLs.has(e.name)||this.baklavaView.editor.nodeURLs.set(e.name,{}),this.baklavaView.editor.nodeURLs.get(e.name)[t]=i})),[]}getMetadataIcon(e){const[[t,i]]=Object.entries(e),a=this.baklavaView.editor.baseIconUrls.get(t);return`${a}${a.endsWith("/")?"":"/"}${i}`}_unregisterNodeType(e){return this.baklavaView.editor.nodeTypes.has(e)?(this.baklavaView.editor.unregisterNodeType(e),[]):[`Node of type ${e} is not registered`]}static getSubgraphs(e,t,i=!0){const a=t?.find((t=>t.id===e)),n=Object.fromEntries(t.map((e=>[e.id,e]))),s=[],r=e=>{if(s.includes(e.id))return;s.push(e.id);const t=e.nodes?.map((e=>e.subgraph))??[],i=e.nodes?.map((e=>e.relatedGraphs?.map((({id:e})=>e))??[])).flat()??[];t.concat(i).filter((e=>void 0!==e)).map((e=>n[e])).forEach(r)};return r(a),s.filter((t=>t!==e||i)).map((e=>n[e]))}async updateGraphSpecification(e){const t=[];if(!e)return{errors:["No specification passed"],warnings:t};const{nodes:i,graphs:a,metadata:n}=e;if(void 0===i&&void 0===a)return{errors:[],warnings:t};let s=[];i.forEach((e=>{e.abstract&&this.baklavaView.editor.parentNodes.set(e.name,e)}));try{const e=J.preprocessNodes(i);s=this.resolveInheritance(e)}catch(e){return{errors:[e.message],warnings:t}}s.forEach((e=>{e.isCategory&&this.baklavaView.editor.parentNodes.set(e.name,e)}));const r=[];if(r.push(...this.validateResolvedSpecification({graphs:a,nodes:s,metadata:n})),r.length)return{errors:r,warnings:t};if(this.specification.currentSpecification.nodes=JSON.parse(JSON.stringify(s)),this.specification.currentSpecification.graphs=JSON.parse(JSON.stringify(a)),s.forEach((e=>{(e.extends??[]).forEach((t=>{const i=s.find((e=>e.name===t));void 0!==i&&(void 0===i.extending&&(i.extending=[]),i.extending.push(e.name))}))})),s.forEach((e=>{const t=new Set;(e.extends??[]).forEach((e=>{const i=s.find((t=>t.name===e));void 0!==i&&i.extending.forEach((e=>t.add(e)))})),t.delete(e.name),e.siblings=Array.from(t)})),s.forEach((e=>{e.extends&&(e.extends=e.extends.filter((e=>void 0!==s.find((t=>t.name===e)))))})),s.forEach((e=>{r.push(...this.validateNodeStyle(e)),r.push(...this._registerNodeType(e))})),r.length)return{errors:r,warnings:t};if(this.relatedGraphsStore=[],void 0!==a){const n=i.filter((({subgraphId:e})=>void 0!==e)),o=i.map((e=>e.relatedGraphs?.map((({id:e})=>e)))).filter((e=>void 0!==e)).flat(),d=async(i,n=[])=>{const s=J.getSubgraphs(i.id,a).map((e=>structuredClone(e))),{errors:o,warnings:d}=await this.loadDataflow({graphs:s,version:e.version},...n);this.baklavaView.editor.deepCleanEditor(),this.baklavaView.editor.unregisterGraphs(),t.push(...d.map((e=>`Graph '${i.name}' is invalid: ${e}`))),r.push(...o.map((e=>`Graph '${i.name}' is invalid: ${e}`)))};for(const e of n){const t=e.subgraphId,i=a.find((({id:e})=>e===t));if(void 0===i){r.push([`The subgraph with ID ${t} was not found`]);continue}const n=(0,w.$o)(i.nodes,i.connections,i.name,this.baklavaView.editor);if(Array.isArray(n)&&n.length){r.push(...n);continue}this.baklavaView.editor.addGraphTemplate(n,s.find((t=>t.name===e.name)));const o=[!0,!0,e.name];await d(i,o),this.baklavaView.editor.deepCleanEditor(),this.baklavaView.editor.unregisterGraphs()}for(const e of o){const t=a.find((({id:t})=>t===e));if(void 0===t){r.push([`The related graph with ID ${e} was not found`]);continue}const i=[!0,!0];if(await d(t,i),this.relatedGraphsStore.find((t=>e===t.id)))continue;const n=new c.TS(this.baklavaView.editor);n.load(t),this.relatedGraphsStore.push(n)}this.relatedGraphsStore.forEach((e=>this.baklavaView.editor.registerGraph(e))),this.editor._graph.id=(0,h.A)()}const o=[...new Set(t)],{errors:d,warnings:l}=this.registerDefaultNodes();r.push(...d),o.push(...l);const u=e.entryGraph;if(!r.length&&void 0!==u)if(a?.some((e=>e.id===u))){const{errors:t}=await this.loadDataflow({graphs:J.getSubgraphs(u,a),version:e.version,entryGraph:u});if(t&&0!==t.length){t.forEach((e=>r.push(e)));const e=new c.TS(this.baklavaView.editor);this.baklavaView.editor.displayedGraph=e,this.baklavaView.editor.deepCleanEditor(),this.baklavaView.editor.unregisterGraphs()}}else o.push(`'entryGraph' points to undefined graph: '${u}'`);return{errors:r,warnings:o}}static preprocessNodes(e){return e.filter((e=>e.isCategory)).forEach((e=>{e.name=J.getNodeName(e)})),e}updateMetadata(e=void 0,t=!1,i=!1){let a;if(i&&(this.updatedMetadata={}),void 0!==e&&(e={...this.updatedMetadata,...e},a=JSON.parse(JSON.stringify(e))),void 0===e&&this.specification.currentSpecification&&(e=this.specification.currentSpecification.metadata??{}),!e)return["No specification to load provided."];if(t){const t=e;e=JSON.parse(JSON.stringify(this.specification.currentSpecification?.metadata??{})),J.mergeObjects(e,t)}return this.baklavaView.interfaceTypes.readInterfaceTypes(e),e&&"urls"in e&&Object.entries(e.urls).forEach((([e,t])=>{this.baklavaView.editor.baseURLs.set(e,t)})),e&&"icons"in e&&Object.entries(e.icons).forEach((([e,t])=>{this.baklavaView.editor.baseIconUrls.set(e,t)})),e&&"navbarItems"in e&&(this.baklavaView.navbarItems=JSON.parse(JSON.stringify(e.navbarItems))),this.baklavaView.editor.readonly=e?.readonly??this.defaultMetadata.readonly,this.baklavaView.editor.hideHud=e?.hideHud??this.defaultMetadata.hideHud,this.baklavaView.editor.nodeStyles.set(R,{icon:"NewNode"}),this.baklavaView.editor.nodeStyles.set(_,{icon:"EditedNode"}),Object.entries(e?.styles??{}).forEach((([e,t])=>{this.baklavaView.editor.nodeStyles.set(e,t)})),this.editor.allowLoopbacks=e?.allowLoopbacks??this.defaultMetadata.allowLoopbacks,this.baklavaView.twoColumn=e?.twoColumn??this.defaultMetadata.twoColumn,this.baklavaView.connectionRenderer.style=e?.connectionStyle??this.defaultMetadata.connectionStyle,this.baklavaView.movementStep=e?.movementStep??this.defaultMetadata.movementStep,this.baklavaView.settings.background.gridSize=e?.backgroundSize??this.defaultMetadata.backgroundSize,this.baklavaView.connectionRenderer.randomizedOffset=e?.randomizedOffset??this.defaultMetadata.randomizedOffset,this.baklavaView.settings.toggleableEditableTypes=e?.toggleableEditableTypes??this.defaultMetadata.toggleableEditableTypes,this.baklavaView.settings.editableNodeTypes=e?.editableTypes??this.defaultMetadata.editableNodeTypes,this.baklavaView.settings.hideAnchors=e?.hideAnchors??this.defaultMetadata.hideAnchors,this.baklavaView.settings.showIds=e?.showIds??this.defaultMetadata.showIds,this.baklavaView.settings.newGraphNode=e?.newGraphNode??this.defaultMetadata.newGraphNode,this.baklavaView.ignoredLayers=new Set,this.baklavaView.layers=e?.layers??this.defaultMetadata.layers,this.baklavaView.collapseSidebar=e?.collapseSidebar??this.defaultMetadata.collapseSidebar,this.baklavaView.editor.layoutManager.useAlgorithm(e?.layout??this.defaultMetadata.layout),this.baklavaView.logLevel=e?.logLevel??this.defaultMetadata.logLevel,this.baklavaView.welcome=e?.welcome??this.defaultMetadata.welcome,a&&(this.updatedMetadata=a),[]}resolveInheritance(e){const t=JSON.parse(JSON.stringify(e)),i=e=>"object"==typeof e&&null!==e&&!Array.isArray(e),a=e=>Array.isArray(e),n=(e,t)=>{const s={...structuredClone(t)};return["abstract","isCategory"].forEach((e=>{delete s[e]})),i(e)&&i(t)&&Object.keys(e).forEach((r=>{if("style"===r)s[r]=J.mergeStyles(t[r],e[r]);else if(i(e[r]))s[r]=r in s?n(e[r],t[r]):e[r];else if(a(e[r])&&a(t[r]))if("extends"===r)s[r]=e[r];else{const i=Object.fromEntries(t[r].map(((e,t)=>[e.name,t])));e[r].forEach((a=>{if(a.name&&a.name in i){const n=i[a.name];if(!a.override)throw new Error(`'${e.name}' node cannot override '${a.name}' property of '${t.name}' node`);s[r][n]={...t[r][n],...a},delete s[r][n].override}else s[r].push(a)}))}else s[r]=e[r]})),s},s={},r=t=>{if(t in s)return s[t];let i,a=e.find((e=>e.name===t));if(!a.extends)return s[t]=a,a;if(new Set(a.extends).size!==a.extends.length)throw new Error(`Repeated class in "extends" list of "${a.name}" node`);return a.extends.forEach((e=>{i=r(e),a=n(a,i)})),s[t]=a,a};return t.filter((e=>!e.abstract)).map((e=>r(e.name)))}validateNodeStyle(e){const t=[];if(void 0===e.style)return t;const i=Array.isArray(e.style)?e.style:[e.style],a=new Set(i);return a.size!==i.length&&t.push(`Repeated styles in "${J.getNodeName(e)}" node`),t.push(...Array.from(a).filter((e=>!this.baklavaView.editor.nodeStyles.has(e))).map((t=>`Non-existing style "${t}" in '${J.getNodeName(e)}' node`))),t}saveSpecification(){const e=JSON.parse(JSON.stringify(this.specification.unresolvedSpecification));return J.unmarkNewNodes(e),e}static unmarkNewNodes(e){const t=[],i=e=>{t.push(`Loaded node '${J.getNodeName(e)}' has '${R}' style, removing it.`)};return e.nodes?.forEach((e=>{e.style===R?(i(e),delete e.style):Array.isArray(e.style)&&e.style.includes(R)&&(i(e),e.style.splice(e.style.indexOf(R),1))})),t}getRootGraph(){return this.editor.subgraphStack.length?this.editor.subgraphStack[0]:this.editor.graph}saveDataflow(e,t,i,a){const n=this.baklavaView.editor.save();n.version=this.specificationVersion;const s=n.entryGraph?n.graphs.find((e=>e.id===n.entryGraph)):n.graphs[0];if(s&&null!=a){const e=this.getRootGraph();s.name=a,e.name=a,e===this.editor.graph&&(this.baklavaView.editor.graphName=a)}return i||n.graphs.forEach((e=>{delete e.panning,delete e.scaling})),void 0===n.metadata&&(n.metadata={}),[[e,"readonly"],[t,"hideHud"],[this.editor.allowLoopbacks,"allowLoopbacks"],[this.baklavaView.twoColumn,"twoColumn"],[this.baklavaView.connectionRenderer.style,"connectionStyle"],[this.baklavaView.movementStep,"movementStep"],[this.baklavaView.settings.background.gridSize,"backgroundSize"],[this.baklavaView.connectionRenderer.randomizedOffset,"randomizedOffset"],[this.baklavaView.settings.editableNodeTypes,"editableTypes"],[this.baklavaView.settings.toggleableEditableTypes,"toggleableEditableTypes"],[this.baklavaView.settings.hideAnchors,"hideAnchors"],[this.baklavaView.settings.showIds,"showIds"],[this.baklavaView.settings.newGraphNode,"newGraphNode"]].forEach((([e,t])=>{const i=this.specification.currentSpecification?.metadata??{},a=this.defaultMetadata;e!==(i[t]??a[t])&&(n.metadata[t]=e)})),0===Object.keys(n.metadata).length&&delete n.metadata,n}async loadDataflow(e,t=!1,i=!1,a=null){let{notifyWhenChanged:n}=this;this.updateMetadata({notifyWhenChanged:!1},!0,!0);try{const s=J.validateDataflow(e);if(s.length)return{errors:s,warnings:[]};try{("string"==typeof e||e instanceof String)&&(e=r.parse(e));const s=e.version,o=[],d=[];if(void 0===s?o.push(`Loaded dataflow has no version assigned. Please update the dataflow to version ${this.specificationVersion}.`):s!==this.specificationVersion&&d.push(`Dataflow version (${s}) differs from the current version (${this.specificationVersion}). It may result in unexpected behaviour.`),"metadata"in e&&void 0!==this.specification.currentSpecification){const t=J.validateMetadata(e.metadata);if(Array.isArray(t)&&t.length)return{errors:t,warnings:o};n=e.metadata.notifyWhenChanged??n,this.updateMetadata({...e.metadata,notifyWhenChanged:!1},!0,!0)}void 0!==this.baklavaView.displayedGraph&&this.baklavaView.history.unsubscribeFromGraphEvents(this.baklavaView.displayedGraph,Symbol("HistoryToken"));let c=!0;try{c=window.isWebpack}catch{c=!1}const h={};return c?Object.assign(h,{errors:[],warnings:[]}):(Object.assign(h,{errors:await this.baklavaView.editor.load(e,t,i,a),warnings:o,info:d}),this.baklavaView.history.graphSwitch(this.baklavaView.displayedGraph,this.baklavaView.displayedGraph)),this.verifyExposedInterfaceNamesMatchExternalNames(e),h}catch(e){return{errors:["Unrecognized format. Make sure that the passed dataflow is correct.",e.toString()],warnings:[],info:[]}}}finally{this.updateMetadata({notifyWhenChanged:n},!0)}}verifyExposedInterfaceNamesMatchExternalNames(e){const t=new Map;e.graphs.forEach((e=>{e.nodes.forEach((e=>{e.interfaces.forEach((e=>{t.has(e.id)?t.get(e.id).push(e):t.set(e.id,[e])}))}))})),t.forEach(((e,t)=>{if(e.length<2)return;const i=e.find((e=>void 0!==e.externalName));if(void 0===i)throw new Error(`The interface with id = ${t} seems to be exposed but lacks "externalName" property.`);e.forEach((e=>{if(e===i||i.externalName===e.name)return;const a=`Mismatch between "externalName" of the original interface and "name" of the exposed version of the interface, for the interface with id = ${t}\nExpected: ${i.externalName}\nGot: ${e.name}`;throw new Error(a)}))}))}static getEditorManagerInstance(){return J.instance||(J.instance=new J),J.instance}static applyUrlOverrides(e,t){Object.entries(t).forEach((([t,i])=>{Object.entries(e.metadata?.icons??{}).forEach((([a,n])=>{e.metadata.icons[a]=n.replaceAll(t,i)})),Object.values(e.metadata?.urls??{}).forEach((e=>{e.url=e.url.replaceAll(t,i)}))}))}static includeWithStyle(e,t){e.nodes?.forEach((e=>{const i=J.mergeStyles(e.style,t);void 0!==i&&(e.style=i)}))}static mergeStyles(e,t){return e===t?e:void 0===(e&&t)?e??t:([e,t]=[e,t].map((e=>Array.isArray(e)?e:[e])).map((e=>new Set(e))),e=e.difference(t),Array.from(e.union(t)))}static mergeObjects(e,t){const i=[],a=[];return t=t??{},void 0===e||0===Object.keys(e).length||Object.entries(t).forEach((([t,n])=>{if(Array.isArray(n)&&Array.isArray(e[t])){if("graphs"===t){const i=[n,e[t]].map((e=>e.map((e=>[e.id,e])))).map(Object.fromEntries);return void(e[t]=Object.values(Object.assign({},...i)))}if("nodes"!==t)return void e[t].push(...n);try{const a=Object.fromEntries(e[t].filter((e=>e.includeName)).map((e=>[e.includeName,J.getNodeName(e)]))),s=new Set,r=e=>{const t=J.getNodeName(e),i=a[t];return void 0!==i&&s.add(t),i??t},o=[n.map((e=>[r(e),e])),e[t].map((e=>[J.getNodeName(e),e]))].map(Object.fromEntries);e[t]=Object.values(Object.assign({},...o));const d=Object.keys(a).filter((e=>!s.has(e)));d.length&&i.push(`Unused include names: ${d}`)}catch(e){a.push(e)}}else if("object"==typeof n&&"object"==typeof e[t]){const{errors:s,warnings:r}=J.mergeObjects(e[t],n);a.push(...s),i.push(...r)}else e[t]=n})),{errors:a,warnings:i}}static getNodeName(e){if(!e.isCategory){if(void 0===e.name)throw new Error("Non-category node has to define field 'name'");return e.name}const t=e.category.split("/").at(-1);if(void 0!==e.name&&e.name!==t)throw new Error(`Node '${e.name}' is a category node and has a name defined different than ${t}`);return t}static validateJSONWithSchema(e,t,i="",o={}){const d=new n({allowUnionTypes:!0,addUsedSchema:!1,formats:{hex:/^0x[a-fA-F0-9]+$/},schemas:[x,$,S,N,k],...o});d.addKeyword("version"),d.addSchema(t,"root");const c=d.getSchema(`root${i}`);if(void 0===c)return[`Invalid value of "reference" parameter: ${i}`];const h="string"==typeof e||e instanceof String;let l;try{l=h?r.parse(e):e}catch(e){return[`Not a proper JSON file: ${e.toString()}`]}return c(l)?[]:c.errors.map((i=>{const n=`${t.$id.split("_").slice(0,-1).join("_")}${i.instancePath}`;let r="";if(h){const t=s.parse(e),a=t.pointers[i.instancePath].value.line+1,n=t.pointers[i.instancePath].valueEnd.line+1;r=a===n?`Line ${a} -`:`Lines ${a}-${n} -`}switch(i.keyword){case"enum":return`${r} ${n} ${i.message} - ${(0,a.stringify)(i.params.allowedValues)}`;case"additionalProperties":return`${r} ${n} ${i.message} - ${(0,a.stringify)(i.params.additionalProperty)}`;case"const":return`${r} ${n} ${i.message} - ${(0,a.stringify)(i.params.allowedValue)}`;case"unevaluatedProperties":return`${r} ${n} ${i.message} - ${(0,a.stringify)(i.params.unevaluatedProperty)}}`;case"not":case"oneOf":return"";default:return`${r} ${n} ${i.message}`}})).filter((e=>""!==e))}validateResolvedSpecification(e){const t=J.validateSpecification(e,$);if(t.length)return t;const{nodes:i}=e,a=i.filter((e=>e.isCategory)),n={},s=[];a.forEach((e=>{e.name in n?s.push(`Category '${e.category}' has multiple nodes defining it.`):n[e.name]=e.category.split("/").slice(0,-1).join("/")}));const r=new Set;return i.forEach((e=>{void 0===e.category&&(e.category="");const t=e.category.split("/");for(let i=t.length-1;i>=0;i-=1){const a=t[i],r=t.slice(0,i).join("/");if(a in n&&e.name!==a&&r===n[a]){void 0!==e.extends&&e.extends.includes(a)||s.push(`Node '${e.name}' does not extend its category node '${a}'.`);break}}for(let t=0;t<(e.extends??[]).length;t+=1){const i=e.extends[t];if(i in n){const t=""!==n[i]?`${n[i]}/${i}`:i;if(!e.category.includes(t)){s.push(`Node '${e.name}' extends from a category node '${i}' but is not in its category`);break}}}r.has(e.name)&&s.push(`Node '${e.name}' is defined multiple times`),r.add(e.name)})),s}validateNode(e,t=x){return J.validateJSONWithSchema(e,t,"#/$defs/node")}validateNodeProperty(e,t=x){return J.validateJSONWithSchema(e,t,"#/$defs/property")}validateNodeInterface(e,t=x){return J.validateJSONWithSchema(e,t,"#/$defs/interface")}static validateSpecification(e,t=x){return J.validateJSONWithSchema(e,t)}static validateMetadata(e){return J.validateJSONWithSchema(e,S)}static validateDataflow(e){return J.validateJSONWithSchema(e,N)}static validateMessage(e){return J.validateJSONWithSchema(e,V)}isInsideSubgraph(){return this.baklavaView.displayedGraph!==this.baklavaView.editor.graph}returnFromSubgraph(){this.baklavaView.editor.backFromSubgraph(this.baklavaView.displayedGraph)}centerZoom(){this.baklavaView.editor.centerZoom()}updateSubgraphName(e){this.editor.updateCurrentSubgraphName(e)}get notifyWhenChanged(){return this.updatedMetadata.notifyWhenChanged??this.specification.currentSpecification?.metadata?.notifyWhenChanged??this.defaultMetadata.notifyWhenChanged}}},41857:(e,t,i)=>{i.d(t,{$4:()=>p,W6:()=>y,nb:()=>f,wH:()=>g});var a=i(50953),n=i(20641),s=i(42302),r=i(8328);const o=(0,a.KR)(!1),d=(0,a.KR)("");class c{constructor(e,t,i=(0,s.A)()){Object.defineProperty(this,"type",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"transactionId",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"topic",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.type=e,this.topic=t,this.transactionId=i}add(e){throw new Error(`Method add has thrown an error for topic: ${this.topic}`)}remove(e){throw new Error(`Method remove has thrown an error for topic: ${this.topic}`)}edit(e){throw new Error(`Method edit has thrown an error for topic: ${this.topic}`)}}class h extends c{constructor(e,t,i=(0,s.A)()){""===i&&(i=(0,s.A)()),super(e,t,i),Object.defineProperty(this,"nodeTuple",{enumerable:!0,configurable:!0,writable:!0,value:[]})}add(e){void 0!==this.nodeTuple[0]&&e.value.addNode(this.nodeTuple[0]).load(this.nodeTuple[1])}remove(e){const t=e.value.nodes.find((e=>e.id===this.topic));void 0!==t&&(this.nodeTuple=[t,t.save()],e.value.removeNode(t))}edit(e){if(void 0!==this.nodeTuple[0]){const t=[...Object.values(this.nodeTuple[0].inputs),...Object.values(this.nodeTuple[0].outputs)],i=e.value.connections.filter((e=>t.includes(e.from)||t.includes(e.to)));e.value.removeNode(this.nodeTuple[0]);const a=e.value.addNode(this.nodeTuple[0]),n=this.nodeTuple[1];this.nodeTuple=[this.nodeTuple[0],this.nodeTuple[0].save()],a.load(n),i.forEach((t=>{e.value.addConnection(t.from,t.to)}))}}}class l extends c{constructor(e,t,i=(0,s.A)()){""===i&&(i=(0,s.A)()),super(e,t,i),Object.defineProperty(this,"conn",{enumerable:!0,configurable:!0,writable:!0,value:void 0})}add(e){if(void 0!==this.conn){const t=e.value.findNodeById(this.conn.from.nodeId),i=e.value.findNodeById(this.conn.to.nodeId);if(!t||!i)return;const a=[...Object.values(t.inputs),...Object.values(t.outputs)].filter((e=>e.port)).find((e=>e.id===this.conn.from.id)),n=[...Object.values(i.inputs),...Object.values(i.outputs)].filter((e=>e.port)).find((e=>e.id===this.conn.to.id));if(!a||!n)return;const s=e.value.addConnection(a,n);if(void 0===s)return;s.id=this.conn.id}}remove(e){const t=e.value.connections.find((e=>e.id===this.topic));void 0!==t&&(this.conn=t,e.value.removeConnection(t))}}class u extends c{constructor(e,t,i=(0,s.A)()){""===i&&(i=(0,s.A)()),super(e,t,i),Object.defineProperty(this,"anchor",{enumerable:!0,configurable:!0,writable:!0,value:void 0})}add(e){if(void 0!==this.anchor){const t=e.value.connections.find((e=>e.from.id===this.anchor[0].from.id&&e.to.id===this.anchor[0].to.id&&e.id===this.anchor[0].id));void 0!==t&&void 0===t.anchors&&(t.anchors=[]),t.anchors.splice(this.anchor[2],0,this.anchor[1])}}remove(e){if(void 0!==this.anchor){const t=e.value.connections.find((e=>e.from===this.anchor[0].from&&e.to===this.anchor[0].to));void 0!==t&&t.anchors.splice(this.anchor[2],1)}}}function p(e){o.value=e}function f(e=(0,s.A)()){if(""===d.value)return d.value=e,e}function g(){d.value=""}function y(e,t){const i=Symbol("CustomHistoryToken"),s=new Map,c=new Map;let p="ThisShouldNotAppearInHistoryMaps",y="ThisShouldNotAppearInHistoryMaps";const v=(e,t)=>{e.events.addNode.unsubscribe(t),e.events.removeNode.unsubscribe(t),e.events.editNode.unsubscribe(t),e.events.addConnection.unsubscribe(t),e.events.removeConnection.unsubscribe(t),e.events.addAnchor.unsubscribe(t),e.events.removeAnchor.unsubscribe(t)},m=(e,t,a=!1)=>{if(t&&v(t,i),e){if(y=p,p=e.id,void 0===s.get(p)&&s.set(p,[]),void 0===c.get(p)&&c.set(p,[]),a){const e=c.get(y);e&&c.set(p,e);const t=s.get(y);t&&s.set(p,t)}e.events.addNode.subscribe(i,(t=>{var i;if((null===(i=r.c.nodeData)||void 0===i?void 0:i.name)!==t.type&&!o.value){const i=s.get(e.id);if(!i)return;i.push(new h("add",t.id.toString(),d.value)),c.set(e.id,[])}})),e.events.removeNode.subscribe(i,(t=>{var i;if(!o.value){if((null===(i=r.c.nodeData)||void 0===i?void 0:i.name)===t.type)return;const a=s.get(e.id);if(!a)return;const n=new h("rem",t.id.toString(),d.value);a.push(n),n.nodeTuple=[t,t.save()],c.set(e.id,[])}})),e.events.editNode.subscribe(i,(t=>{if(!o.value){const i=s.get(e.id);if(!i)return;const a=new h("edit",t.id.toString(),d.value);i.push(a),a.nodeTuple=[t,t.save()],c.set(e.id,[])}})),e.events.addConnection.subscribe(i,(t=>{if(!o.value){const i=s.get(e.id);if(!i)return;i.push(new l("add",t.id.toString(),d.value)),c.set(e.id,[])}})),e.events.removeConnection.subscribe(i,(t=>{var i;if(!o.value){const a=""!==d.value;a||f();const n=s.get(e.id);if(!n)return;(null!==(i=t.anchors)&&void 0!==i?i:[]).slice().reverse().forEach((i=>{e.events.removeAnchor.emit([t,t.anchors.indexOf(i)])}));const r=new l("rem",t.id.toString(),d.value);n.push(r),r.conn=t,c.set(e.id,[]),a||g()}})),e.events.addAnchor.subscribe(i,(t=>{if(!o.value){const i=s.get(e.id);if(!i)return;const a=Math.trunc((t[1]-1)/3),n=t[0],r=new u("add",n.anchors[a].id.toString(),d.value);i.push(r),r.anchor=[n,n.anchors[a],a],c.set(e.id,[])}})),e.events.removeAnchor.subscribe(i,(t=>{if(!o.value){const i=s.get(e.id);if(!i)return;const a=t[1],n=t[0],r=new u("rem",n.anchors[a].id.toString(),d.value);i.push(r),r.anchor=[n,n.anchors[a],a],c.set(e.id,[])}}))}};(0,n.wB)(e,((e,t)=>m(e,t)),{flush:"post",immediate:!0});const b=(t,i)=>{const a=t.pop();void 0!==a&&(o.value=!0,"add"===a.type?(a.type="rem",a.remove(e)):"rem"===a.type?(a.type="add",a.add(e)):"edit"===a.type&&(a.type="edit",a.edit(e)),i.push(a),t.length>0&&t[t.length-1].transactionId===a.transactionId&&b(t,i),o.value=!1,e.value.selectedNodes.splice(0,e.value.selectedNodes.length))};return t.registerCommand("undo",{canExecute:()=>!0,execute:()=>{const e=s.get(p);if(e&&0!==e.length){const t=c.get(p);e&&t&&b(e,t)}}}),t.registerCommand("redo",{canExecute:()=>!0,execute:()=>{const e=s.get(p),t=c.get(p);e&&t&&0!==t.length&&b(t,e)}}),t.registerCommand("START_TRANSACTION",{canExecute:()=>""===d.value,execute:()=>f}),t.registerCommand("COMMIT_TRANSACTION",{canExecute:()=>""!==d.value,execute:()=>g}),t.registerHotkey(["Control","z"],"undo"),t.registerHotkey(["Control","y"],"redo"),(0,a.Kh)({max_steps:200,graphSwitch:m,unsubscribeFromGraphEvents:v})}},54320:(e,t,i)=>{i.d(t,{A:()=>s});var a=i(10892),n=i(30920);class s{layoutEngine=void 0;usedAlgorithm=void 0;graph=void 0;availableEngines={NoLayout:new n.A,CytoscapeEngine:new a.A};constructor(){this.useAlgorithm("NoLayout")}useAlgorithm(e){const[t,i]=e.split(" - "),a=this.availableEngines[t];if(void 0===a)throw new Error(`Could not parse the ${e} autolayout algorithm`);this.layoutEngine=a,void 0!==i&&this.layoutEngine.chooseAlgorithm(i),this.usedAlgorithm=e}getAvailableAlgorithms(){return Object.entries(this.availableEngines).map((([e,t])=>1!==t.availableAlgorithms.length?t.availableAlgorithms.map((t=>`${e} - ${t}`)):e)).flat()}registerGraph(e){this.graph=function(e){const t=new Map;e.nodes.forEach((e=>{e.interfaces.forEach((i=>t.set(i.id,e.id)))}));const i=e.nodes.filter((e=>void 0===e.position)).map((e=>({id:e.id}))),a=e.connections.filter((e=>i.filter((i=>i.id===t.get(e.from))).length>0&&i.filter((i=>i.id===t.get(e.to))).length>0)).map((e=>({id:e.id,from:t.get(e.from),to:t.get(e.to)})));return{nodes:i,connections:a}}(e)}async computeLayout(e){return this.updateDimensions(),function(e,t){const i=new Map;return e.nodes.forEach((e=>i.set(e.id,e.position))),t.nodes=t.nodes.map((e=>({...e,position:i.has(e.id)?i.get(e.id):e.position}))),t}(await this.runEngine(this.graph),e)}async runEngine(e){return this.layoutEngine.calculate(e)}updateDimensions(){this.graph.nodes=this.graph.nodes.map((e=>{const t=document.getElementById(e.id);return{...e,width:t.offsetWidth,height:t.offsetHeight}}))}}}}]);
//# sourceMappingURL=index-a5943e60.16272074.js.map