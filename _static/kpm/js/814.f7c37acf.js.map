{"version":3,"file":"js/814.f7c37acf.js","mappings":"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","sources":["webpack://pipeline-manager/./node_modules/ajv/dist/vocabularies/applicator/if.js","webpack://pipeline-manager/./node_modules/ajv/dist/core.js","webpack://pipeline-manager/./node_modules/ajv/dist/compile/validate/defaults.js","webpack://pipeline-manager/./node_modules/ajv/dist/compile/validate/applicability.js","webpack://pipeline-manager/./node_modules/ajv/dist/compile/validate/dataType.js","webpack://pipeline-manager/./node_modules/ajv/dist/compile/rules.js","webpack://pipeline-manager/./node_modules/ajv/dist/vocabularies/applicator/contains.js","webpack://pipeline-manager/./node_modules/ajv/dist/vocabularies/dynamic/recursiveAnchor.js","webpack://pipeline-manager/./node_modules/ajv/dist/vocabularies/unevaluated/unevaluatedItems.js","webpack://pipeline-manager/./node_modules/ajv/dist/runtime/validation_error.js","webpack://pipeline-manager/./node_modules/ajv/dist/vocabularies/core/ref.js","webpack://pipeline-manager/./node_modules/ajv/dist/vocabularies/applicator/thenElse.js","webpack://pipeline-manager/./node_modules/ajv/dist/vocabularies/applicator/additionalItems.js","webpack://pipeline-manager/./node_modules/ajv/dist/vocabularies/code.js","webpack://pipeline-manager/./node_modules/ajv/dist/vocabularies/applicator/allOf.js","webpack://pipeline-manager/./node_modules/ajv/dist/vocabularies/applicator/anyOf.js","webpack://pipeline-manager/./node_modules/ajv/dist/vocabularies/applicator/propertyNames.js","webpack://pipeline-manager/./node_modules/ajv/dist/vocabularies/applicator/items.js","webpack://pipeline-manager/./node_modules/ajv/dist/vocabularies/dynamic/recursiveRef.js","webpack://pipeline-manager/./node_modules/ajv/dist/compile/validate/subschema.js","webpack://pipeline-manager/./node_modules/ajv/dist/vocabularies/next.js","webpack://pipeline-manager/./node_modules/ajv/dist/vocabularies/validation/const.js","webpack://pipeline-manager/./node_modules/ajv/dist/vocabularies/validation/enum.js","webpack://pipeline-manager/./node_modules/ajv/dist/compile/validate/boolSchema.js","webpack://pipeline-manager/./node_modules/ajv/dist/vocabularies/validation/dependentRequired.js","webpack://pipeline-manager/./node_modules/ajv/dist/vocabularies/validation/limitContains.js","webpack://pipeline-manager/./node_modules/ajv/dist/vocabularies/dynamic/dynamicRef.js","webpack://pipeline-manager/./node_modules/ajv/dist/compile/validate/keyword.js","webpack://pipeline-manager/./node_modules/ajv/dist/vocabularies/validation/required.js","webpack://pipeline-manager/./node_modules/ajv/dist/vocabularies/validation/limitProperties.js","webpack://pipeline-manager/./node_modules/ajv/dist/compile/ref_error.js","webpack://pipeline-manager/./node_modules/ajv/dist/vocabularies/applicator/dependentSchemas.js","webpack://pipeline-manager/./node_modules/ajv/dist/vocabularies/discriminator/index.js","webpack://pipeline-manager/./node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js","webpack://pipeline-manager/./node_modules/ajv/dist/vocabularies/applicator/properties.js","webpack://pipeline-manager/./node_modules/ajv/dist/compile/codegen/code.js","webpack://pipeline-manager/./node_modules/ajv/dist/compile/names.js","webpack://pipeline-manager/./node_modules/ajv/dist/vocabularies/applicator/patternProperties.js","webpack://pipeline-manager/./node_modules/ajv/dist/compile/errors.js","webpack://pipeline-manager/./node_modules/ajv/dist/runtime/ucs2length.js","webpack://pipeline-manager/./node_modules/ajv/dist/runtime/uri.js","webpack://pipeline-manager/./node_modules/ajv/dist/vocabularies/applicator/index.js","webpack://pipeline-manager/./node_modules/ajv/dist/compile/codegen/scope.js","webpack://pipeline-manager/./node_modules/ajv/dist/vocabularies/applicator/not.js","webpack://pipeline-manager/./node_modules/ajv/dist/vocabularies/validation/uniqueItems.js","webpack://pipeline-manager/./node_modules/ajv/dist/vocabularies/validation/limitItems.js","webpack://pipeline-manager/./node_modules/ajv/dist/compile/validate/index.js","webpack://pipeline-manager/./node_modules/ajv/dist/ajv.js","webpack://pipeline-manager/./node_modules/ajv/dist/vocabularies/validation/multipleOf.js","webpack://pipeline-manager/./node_modules/ajv/dist/vocabularies/applicator/prefixItems.js","webpack://pipeline-manager/./node_modules/ajv/dist/vocabularies/dynamic/index.js","webpack://pipeline-manager/./node_modules/ajv/dist/compile/resolve.js","webpack://pipeline-manager/./node_modules/ajv/dist/vocabularies/validation/index.js","webpack://pipeline-manager/./node_modules/ajv/dist/vocabularies/metadata.js","webpack://pipeline-manager/./node_modules/ajv/dist/refs/json-schema-2019-09/index.js","webpack://pipeline-manager/./node_modules/ajv/dist/vocabularies/core/index.js","webpack://pipeline-manager/./node_modules/ajv/dist/vocabularies/dynamic/dynamicAnchor.js","webpack://pipeline-manager/./node_modules/ajv/dist/vocabularies/unevaluated/index.js","webpack://pipeline-manager/./node_modules/ajv/dist/compile/index.js","webpack://pipeline-manager/./node_modules/ajv/dist/vocabularies/validation/limitNumber.js","webpack://pipeline-manager/./node_modules/ajv/dist/runtime/equal.js","webpack://pipeline-manager/./node_modules/ajv/dist/vocabularies/validation/limitLength.js","webpack://pipeline-manager/./node_modules/ajv/dist/vocabularies/unevaluated/unevaluatedProperties.js","webpack://pipeline-manager/./node_modules/ajv/dist/vocabularies/applicator/dependencies.js","webpack://pipeline-manager/./node_modules/ajv/dist/vocabularies/core/id.js","webpack://pipeline-manager/./node_modules/ajv/dist/vocabularies/draft7.js","webpack://pipeline-manager/./node_modules/ajv/dist/vocabularies/validation/pattern.js","webpack://pipeline-manager/./node_modules/ajv/dist/vocabularies/applicator/items2020.js","webpack://pipeline-manager/./node_modules/ajv/dist/compile/util.js","webpack://pipeline-manager/./node_modules/ajv/dist/2019.js","webpack://pipeline-manager/./node_modules/ajv/dist/vocabularies/format/format.js","webpack://pipeline-manager/./node_modules/ajv/dist/vocabularies/applicator/oneOf.js","webpack://pipeline-manager/./node_modules/ajv/dist/vocabularies/format/index.js","webpack://pipeline-manager/./node_modules/ajv/dist/vocabularies/discriminator/types.js","webpack://pipeline-manager/./node_modules/ajv/dist/compile/codegen/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: ({ params }) => (0, codegen_1.str) `must match \"${params.ifClause}\" schema`,\n    params: ({ params }) => (0, codegen_1._) `{failingKeyword: ${params.ifClause}}`,\n};\nconst def = {\n    keyword: \"if\",\n    schemaType: [\"object\", \"boolean\"],\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, parentSchema, it } = cxt;\n        if (parentSchema.then === undefined && parentSchema.else === undefined) {\n            (0, util_1.checkStrictMode)(it, '\"if\" without \"then\" and \"else\" is ignored');\n        }\n        const hasThen = hasSchema(it, \"then\");\n        const hasElse = hasSchema(it, \"else\");\n        if (!hasThen && !hasElse)\n            return;\n        const valid = gen.let(\"valid\", true);\n        const schValid = gen.name(\"_valid\");\n        validateIf();\n        cxt.reset();\n        if (hasThen && hasElse) {\n            const ifClause = gen.let(\"ifClause\");\n            cxt.setParams({ ifClause });\n            gen.if(schValid, validateClause(\"then\", ifClause), validateClause(\"else\", ifClause));\n        }\n        else if (hasThen) {\n            gen.if(schValid, validateClause(\"then\"));\n        }\n        else {\n            gen.if((0, codegen_1.not)(schValid), validateClause(\"else\"));\n        }\n        cxt.pass(valid, () => cxt.error(true));\n        function validateIf() {\n            const schCxt = cxt.subschema({\n                keyword: \"if\",\n                compositeRule: true,\n                createErrors: false,\n                allErrors: false,\n            }, schValid);\n            cxt.mergeEvaluated(schCxt);\n        }\n        function validateClause(keyword, ifClause) {\n            return () => {\n                const schCxt = cxt.subschema({ keyword }, schValid);\n                gen.assign(valid, schValid);\n                cxt.mergeValidEvaluated(schCxt, valid);\n                if (ifClause)\n                    gen.assign(ifClause, (0, codegen_1._) `${keyword}`);\n                else\n                    cxt.setParams({ ifClause: keyword });\n            };\n        }\n    },\n};\nfunction hasSchema(it, keyword) {\n    const schema = it.schema[keyword];\n    return schema !== undefined && !(0, util_1.alwaysValidSchema)(it, schema);\n}\nexports.default = def;\n//# sourceMappingURL=if.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;\nvar validate_1 = require(\"./compile/validate\");\nObject.defineProperty(exports, \"KeywordCxt\", { enumerable: true, get: function () { return validate_1.KeywordCxt; } });\nvar codegen_1 = require(\"./compile/codegen\");\nObject.defineProperty(exports, \"_\", { enumerable: true, get: function () { return codegen_1._; } });\nObject.defineProperty(exports, \"str\", { enumerable: true, get: function () { return codegen_1.str; } });\nObject.defineProperty(exports, \"stringify\", { enumerable: true, get: function () { return codegen_1.stringify; } });\nObject.defineProperty(exports, \"nil\", { enumerable: true, get: function () { return codegen_1.nil; } });\nObject.defineProperty(exports, \"Name\", { enumerable: true, get: function () { return codegen_1.Name; } });\nObject.defineProperty(exports, \"CodeGen\", { enumerable: true, get: function () { return codegen_1.CodeGen; } });\nconst validation_error_1 = require(\"./runtime/validation_error\");\nconst ref_error_1 = require(\"./compile/ref_error\");\nconst rules_1 = require(\"./compile/rules\");\nconst compile_1 = require(\"./compile\");\nconst codegen_2 = require(\"./compile/codegen\");\nconst resolve_1 = require(\"./compile/resolve\");\nconst dataType_1 = require(\"./compile/validate/dataType\");\nconst util_1 = require(\"./compile/util\");\nconst $dataRefSchema = require(\"./refs/data.json\");\nconst uri_1 = require(\"./runtime/uri\");\nconst defaultRegExp = (str, flags) => new RegExp(str, flags);\ndefaultRegExp.code = \"new RegExp\";\nconst META_IGNORE_OPTIONS = [\"removeAdditional\", \"useDefaults\", \"coerceTypes\"];\nconst EXT_SCOPE_NAMES = new Set([\n    \"validate\",\n    \"serialize\",\n    \"parse\",\n    \"wrapper\",\n    \"root\",\n    \"schema\",\n    \"keyword\",\n    \"pattern\",\n    \"formats\",\n    \"validate$data\",\n    \"func\",\n    \"obj\",\n    \"Error\",\n]);\nconst removedOptions = {\n    errorDataPath: \"\",\n    format: \"`validateFormats: false` can be used instead.\",\n    nullable: '\"nullable\" keyword is supported by default.',\n    jsonPointers: \"Deprecated jsPropertySyntax can be used instead.\",\n    extendRefs: \"Deprecated ignoreKeywordsWithRef can be used instead.\",\n    missingRefs: \"Pass empty schema with $id that should be ignored to ajv.addSchema.\",\n    processCode: \"Use option `code: {process: (code, schemaEnv: object) => string}`\",\n    sourceCode: \"Use option `code: {source: true}`\",\n    strictDefaults: \"It is default now, see option `strict`.\",\n    strictKeywords: \"It is default now, see option `strict`.\",\n    uniqueItems: '\"uniqueItems\" keyword is always validated.',\n    unknownFormats: \"Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).\",\n    cache: \"Map is used as cache, schema object as key.\",\n    serialize: \"Map is used as cache, schema object as key.\",\n    ajvErrors: \"It is default now.\",\n};\nconst deprecatedOptions = {\n    ignoreKeywordsWithRef: \"\",\n    jsPropertySyntax: \"\",\n    unicode: '\"minLength\"/\"maxLength\" account for unicode characters by default.',\n};\nconst MAX_EXPRESSION = 200;\n// eslint-disable-next-line complexity\nfunction requiredOptions(o) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;\n    const s = o.strict;\n    const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;\n    const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;\n    const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;\n    const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;\n    return {\n        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,\n        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,\n        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : \"log\",\n        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : \"log\",\n        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,\n        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },\n        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,\n        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,\n        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,\n        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,\n        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,\n        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : \"$id\",\n        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,\n        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,\n        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,\n        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,\n        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,\n        uriResolver: uriResolver,\n    };\n}\nclass Ajv {\n    constructor(opts = {}) {\n        this.schemas = {};\n        this.refs = {};\n        this.formats = {};\n        this._compilations = new Set();\n        this._loading = {};\n        this._cache = new Map();\n        opts = this.opts = { ...opts, ...requiredOptions(opts) };\n        const { es5, lines } = this.opts.code;\n        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });\n        this.logger = getLogger(opts.logger);\n        const formatOpt = opts.validateFormats;\n        opts.validateFormats = false;\n        this.RULES = (0, rules_1.getRules)();\n        checkOptions.call(this, removedOptions, opts, \"NOT SUPPORTED\");\n        checkOptions.call(this, deprecatedOptions, opts, \"DEPRECATED\", \"warn\");\n        this._metaOpts = getMetaSchemaOptions.call(this);\n        if (opts.formats)\n            addInitialFormats.call(this);\n        this._addVocabularies();\n        this._addDefaultMetaSchema();\n        if (opts.keywords)\n            addInitialKeywords.call(this, opts.keywords);\n        if (typeof opts.meta == \"object\")\n            this.addMetaSchema(opts.meta);\n        addInitialSchemas.call(this);\n        opts.validateFormats = formatOpt;\n    }\n    _addVocabularies() {\n        this.addKeyword(\"$async\");\n    }\n    _addDefaultMetaSchema() {\n        const { $data, meta, schemaId } = this.opts;\n        let _dataRefSchema = $dataRefSchema;\n        if (schemaId === \"id\") {\n            _dataRefSchema = { ...$dataRefSchema };\n            _dataRefSchema.id = _dataRefSchema.$id;\n            delete _dataRefSchema.$id;\n        }\n        if (meta && $data)\n            this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);\n    }\n    defaultMeta() {\n        const { meta, schemaId } = this.opts;\n        return (this.opts.defaultMeta = typeof meta == \"object\" ? meta[schemaId] || meta : undefined);\n    }\n    validate(schemaKeyRef, // key, ref or schema object\n    // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\n    data // to be validated\n    ) {\n        let v;\n        if (typeof schemaKeyRef == \"string\") {\n            v = this.getSchema(schemaKeyRef);\n            if (!v)\n                throw new Error(`no schema with key or ref \"${schemaKeyRef}\"`);\n        }\n        else {\n            v = this.compile(schemaKeyRef);\n        }\n        const valid = v(data);\n        if (!(\"$async\" in v))\n            this.errors = v.errors;\n        return valid;\n    }\n    compile(schema, _meta) {\n        const sch = this._addSchema(schema, _meta);\n        return (sch.validate || this._compileSchemaEnv(sch));\n    }\n    compileAsync(schema, meta) {\n        if (typeof this.opts.loadSchema != \"function\") {\n            throw new Error(\"options.loadSchema should be a function\");\n        }\n        const { loadSchema } = this.opts;\n        return runCompileAsync.call(this, schema, meta);\n        async function runCompileAsync(_schema, _meta) {\n            await loadMetaSchema.call(this, _schema.$schema);\n            const sch = this._addSchema(_schema, _meta);\n            return sch.validate || _compileAsync.call(this, sch);\n        }\n        async function loadMetaSchema($ref) {\n            if ($ref && !this.getSchema($ref)) {\n                await runCompileAsync.call(this, { $ref }, true);\n            }\n        }\n        async function _compileAsync(sch) {\n            try {\n                return this._compileSchemaEnv(sch);\n            }\n            catch (e) {\n                if (!(e instanceof ref_error_1.default))\n                    throw e;\n                checkLoaded.call(this, e);\n                await loadMissingSchema.call(this, e.missingSchema);\n                return _compileAsync.call(this, sch);\n            }\n        }\n        function checkLoaded({ missingSchema: ref, missingRef }) {\n            if (this.refs[ref]) {\n                throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);\n            }\n        }\n        async function loadMissingSchema(ref) {\n            const _schema = await _loadSchema.call(this, ref);\n            if (!this.refs[ref])\n                await loadMetaSchema.call(this, _schema.$schema);\n            if (!this.refs[ref])\n                this.addSchema(_schema, ref, meta);\n        }\n        async function _loadSchema(ref) {\n            const p = this._loading[ref];\n            if (p)\n                return p;\n            try {\n                return await (this._loading[ref] = loadSchema(ref));\n            }\n            finally {\n                delete this._loading[ref];\n            }\n        }\n    }\n    // Adds schema to the instance\n    addSchema(schema, // If array is passed, `key` will be ignored\n    key, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n    _meta, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.\n    _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.\n    ) {\n        if (Array.isArray(schema)) {\n            for (const sch of schema)\n                this.addSchema(sch, undefined, _meta, _validateSchema);\n            return this;\n        }\n        let id;\n        if (typeof schema === \"object\") {\n            const { schemaId } = this.opts;\n            id = schema[schemaId];\n            if (id !== undefined && typeof id != \"string\") {\n                throw new Error(`schema ${schemaId} must be string`);\n            }\n        }\n        key = (0, resolve_1.normalizeId)(key || id);\n        this._checkUnique(key);\n        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);\n        return this;\n    }\n    // Add schema that will be used to validate other schemas\n    // options in META_IGNORE_OPTIONS are alway set to false\n    addMetaSchema(schema, key, // schema key\n    _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema\n    ) {\n        this.addSchema(schema, key, true, _validateSchema);\n        return this;\n    }\n    //  Validate schema against its meta-schema\n    validateSchema(schema, throwOrLogError) {\n        if (typeof schema == \"boolean\")\n            return true;\n        let $schema;\n        $schema = schema.$schema;\n        if ($schema !== undefined && typeof $schema != \"string\") {\n            throw new Error(\"$schema must be a string\");\n        }\n        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();\n        if (!$schema) {\n            this.logger.warn(\"meta-schema not available\");\n            this.errors = null;\n            return true;\n        }\n        const valid = this.validate($schema, schema);\n        if (!valid && throwOrLogError) {\n            const message = \"schema is invalid: \" + this.errorsText();\n            if (this.opts.validateSchema === \"log\")\n                this.logger.error(message);\n            else\n                throw new Error(message);\n        }\n        return valid;\n    }\n    // Get compiled schema by `key` or `ref`.\n    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)\n    getSchema(keyRef) {\n        let sch;\n        while (typeof (sch = getSchEnv.call(this, keyRef)) == \"string\")\n            keyRef = sch;\n        if (sch === undefined) {\n            const { schemaId } = this.opts;\n            const root = new compile_1.SchemaEnv({ schema: {}, schemaId });\n            sch = compile_1.resolveSchema.call(this, root, keyRef);\n            if (!sch)\n                return;\n            this.refs[keyRef] = sch;\n        }\n        return (sch.validate || this._compileSchemaEnv(sch));\n    }\n    // Remove cached schema(s).\n    // If no parameter is passed all schemas but meta-schemas are removed.\n    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n    removeSchema(schemaKeyRef) {\n        if (schemaKeyRef instanceof RegExp) {\n            this._removeAllSchemas(this.schemas, schemaKeyRef);\n            this._removeAllSchemas(this.refs, schemaKeyRef);\n            return this;\n        }\n        switch (typeof schemaKeyRef) {\n            case \"undefined\":\n                this._removeAllSchemas(this.schemas);\n                this._removeAllSchemas(this.refs);\n                this._cache.clear();\n                return this;\n            case \"string\": {\n                const sch = getSchEnv.call(this, schemaKeyRef);\n                if (typeof sch == \"object\")\n                    this._cache.delete(sch.schema);\n                delete this.schemas[schemaKeyRef];\n                delete this.refs[schemaKeyRef];\n                return this;\n            }\n            case \"object\": {\n                const cacheKey = schemaKeyRef;\n                this._cache.delete(cacheKey);\n                let id = schemaKeyRef[this.opts.schemaId];\n                if (id) {\n                    id = (0, resolve_1.normalizeId)(id);\n                    delete this.schemas[id];\n                    delete this.refs[id];\n                }\n                return this;\n            }\n            default:\n                throw new Error(\"ajv.removeSchema: invalid parameter\");\n        }\n    }\n    // add \"vocabulary\" - a collection of keywords\n    addVocabulary(definitions) {\n        for (const def of definitions)\n            this.addKeyword(def);\n        return this;\n    }\n    addKeyword(kwdOrDef, def // deprecated\n    ) {\n        let keyword;\n        if (typeof kwdOrDef == \"string\") {\n            keyword = kwdOrDef;\n            if (typeof def == \"object\") {\n                this.logger.warn(\"these parameters are deprecated, see docs for addKeyword\");\n                def.keyword = keyword;\n            }\n        }\n        else if (typeof kwdOrDef == \"object\" && def === undefined) {\n            def = kwdOrDef;\n            keyword = def.keyword;\n            if (Array.isArray(keyword) && !keyword.length) {\n                throw new Error(\"addKeywords: keyword must be string or non-empty array\");\n            }\n        }\n        else {\n            throw new Error(\"invalid addKeywords parameters\");\n        }\n        checkKeyword.call(this, keyword, def);\n        if (!def) {\n            (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));\n            return this;\n        }\n        keywordMetaschema.call(this, def);\n        const definition = {\n            ...def,\n            type: (0, dataType_1.getJSONTypes)(def.type),\n            schemaType: (0, dataType_1.getJSONTypes)(def.schemaType),\n        };\n        (0, util_1.eachItem)(keyword, definition.type.length === 0\n            ? (k) => addRule.call(this, k, definition)\n            : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));\n        return this;\n    }\n    getKeyword(keyword) {\n        const rule = this.RULES.all[keyword];\n        return typeof rule == \"object\" ? rule.definition : !!rule;\n    }\n    // Remove keyword\n    removeKeyword(keyword) {\n        // TODO return type should be Ajv\n        const { RULES } = this;\n        delete RULES.keywords[keyword];\n        delete RULES.all[keyword];\n        for (const group of RULES.rules) {\n            const i = group.rules.findIndex((rule) => rule.keyword === keyword);\n            if (i >= 0)\n                group.rules.splice(i, 1);\n        }\n        return this;\n    }\n    // Add format\n    addFormat(name, format) {\n        if (typeof format == \"string\")\n            format = new RegExp(format);\n        this.formats[name] = format;\n        return this;\n    }\n    errorsText(errors = this.errors, // optional array of validation errors\n    { separator = \", \", dataVar = \"data\" } = {} // optional options with properties `separator` and `dataVar`\n    ) {\n        if (!errors || errors.length === 0)\n            return \"No errors\";\n        return errors\n            .map((e) => `${dataVar}${e.instancePath} ${e.message}`)\n            .reduce((text, msg) => text + separator + msg);\n    }\n    $dataMetaSchema(metaSchema, keywordsJsonPointers) {\n        const rules = this.RULES.all;\n        metaSchema = JSON.parse(JSON.stringify(metaSchema));\n        for (const jsonPointer of keywordsJsonPointers) {\n            const segments = jsonPointer.split(\"/\").slice(1); // first segment is an empty string\n            let keywords = metaSchema;\n            for (const seg of segments)\n                keywords = keywords[seg];\n            for (const key in rules) {\n                const rule = rules[key];\n                if (typeof rule != \"object\")\n                    continue;\n                const { $data } = rule.definition;\n                const schema = keywords[key];\n                if ($data && schema)\n                    keywords[key] = schemaOrData(schema);\n            }\n        }\n        return metaSchema;\n    }\n    _removeAllSchemas(schemas, regex) {\n        for (const keyRef in schemas) {\n            const sch = schemas[keyRef];\n            if (!regex || regex.test(keyRef)) {\n                if (typeof sch == \"string\") {\n                    delete schemas[keyRef];\n                }\n                else if (sch && !sch.meta) {\n                    this._cache.delete(sch.schema);\n                    delete schemas[keyRef];\n                }\n            }\n        }\n    }\n    _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {\n        let id;\n        const { schemaId } = this.opts;\n        if (typeof schema == \"object\") {\n            id = schema[schemaId];\n        }\n        else {\n            if (this.opts.jtd)\n                throw new Error(\"schema must be object\");\n            else if (typeof schema != \"boolean\")\n                throw new Error(\"schema must be object or boolean\");\n        }\n        let sch = this._cache.get(schema);\n        if (sch !== undefined)\n            return sch;\n        baseId = (0, resolve_1.normalizeId)(id || baseId);\n        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);\n        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });\n        this._cache.set(sch.schema, sch);\n        if (addSchema && !baseId.startsWith(\"#\")) {\n            // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)\n            if (baseId)\n                this._checkUnique(baseId);\n            this.refs[baseId] = sch;\n        }\n        if (validateSchema)\n            this.validateSchema(schema, true);\n        return sch;\n    }\n    _checkUnique(id) {\n        if (this.schemas[id] || this.refs[id]) {\n            throw new Error(`schema with key or id \"${id}\" already exists`);\n        }\n    }\n    _compileSchemaEnv(sch) {\n        if (sch.meta)\n            this._compileMetaSchema(sch);\n        else\n            compile_1.compileSchema.call(this, sch);\n        /* istanbul ignore if */\n        if (!sch.validate)\n            throw new Error(\"ajv implementation error\");\n        return sch.validate;\n    }\n    _compileMetaSchema(sch) {\n        const currentOpts = this.opts;\n        this.opts = this._metaOpts;\n        try {\n            compile_1.compileSchema.call(this, sch);\n        }\n        finally {\n            this.opts = currentOpts;\n        }\n    }\n}\nAjv.ValidationError = validation_error_1.default;\nAjv.MissingRefError = ref_error_1.default;\nexports.default = Ajv;\nfunction checkOptions(checkOpts, options, msg, log = \"error\") {\n    for (const key in checkOpts) {\n        const opt = key;\n        if (opt in options)\n            this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);\n    }\n}\nfunction getSchEnv(keyRef) {\n    keyRef = (0, resolve_1.normalizeId)(keyRef); // TODO tests fail without this line\n    return this.schemas[keyRef] || this.refs[keyRef];\n}\nfunction addInitialSchemas() {\n    const optsSchemas = this.opts.schemas;\n    if (!optsSchemas)\n        return;\n    if (Array.isArray(optsSchemas))\n        this.addSchema(optsSchemas);\n    else\n        for (const key in optsSchemas)\n            this.addSchema(optsSchemas[key], key);\n}\nfunction addInitialFormats() {\n    for (const name in this.opts.formats) {\n        const format = this.opts.formats[name];\n        if (format)\n            this.addFormat(name, format);\n    }\n}\nfunction addInitialKeywords(defs) {\n    if (Array.isArray(defs)) {\n        this.addVocabulary(defs);\n        return;\n    }\n    this.logger.warn(\"keywords option as map is deprecated, pass array\");\n    for (const keyword in defs) {\n        const def = defs[keyword];\n        if (!def.keyword)\n            def.keyword = keyword;\n        this.addKeyword(def);\n    }\n}\nfunction getMetaSchemaOptions() {\n    const metaOpts = { ...this.opts };\n    for (const opt of META_IGNORE_OPTIONS)\n        delete metaOpts[opt];\n    return metaOpts;\n}\nconst noLogs = { log() { }, warn() { }, error() { } };\nfunction getLogger(logger) {\n    if (logger === false)\n        return noLogs;\n    if (logger === undefined)\n        return console;\n    if (logger.log && logger.warn && logger.error)\n        return logger;\n    throw new Error(\"logger must implement log, warn and error methods\");\n}\nconst KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;\nfunction checkKeyword(keyword, def) {\n    const { RULES } = this;\n    (0, util_1.eachItem)(keyword, (kwd) => {\n        if (RULES.keywords[kwd])\n            throw new Error(`Keyword ${kwd} is already defined`);\n        if (!KEYWORD_NAME.test(kwd))\n            throw new Error(`Keyword ${kwd} has invalid name`);\n    });\n    if (!def)\n        return;\n    if (def.$data && !(\"code\" in def || \"validate\" in def)) {\n        throw new Error('$data keyword must have \"code\" or \"validate\" function');\n    }\n}\nfunction addRule(keyword, definition, dataType) {\n    var _a;\n    const post = definition === null || definition === void 0 ? void 0 : definition.post;\n    if (dataType && post)\n        throw new Error('keyword with \"post\" flag cannot have \"type\"');\n    const { RULES } = this;\n    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);\n    if (!ruleGroup) {\n        ruleGroup = { type: dataType, rules: [] };\n        RULES.rules.push(ruleGroup);\n    }\n    RULES.keywords[keyword] = true;\n    if (!definition)\n        return;\n    const rule = {\n        keyword,\n        definition: {\n            ...definition,\n            type: (0, dataType_1.getJSONTypes)(definition.type),\n            schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType),\n        },\n    };\n    if (definition.before)\n        addBeforeRule.call(this, ruleGroup, rule, definition.before);\n    else\n        ruleGroup.rules.push(rule);\n    RULES.all[keyword] = rule;\n    (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));\n}\nfunction addBeforeRule(ruleGroup, rule, before) {\n    const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);\n    if (i >= 0) {\n        ruleGroup.rules.splice(i, 0, rule);\n    }\n    else {\n        ruleGroup.rules.push(rule);\n        this.logger.warn(`rule ${before} is not defined`);\n    }\n}\nfunction keywordMetaschema(def) {\n    let { metaSchema } = def;\n    if (metaSchema === undefined)\n        return;\n    if (def.$data && this.opts.$data)\n        metaSchema = schemaOrData(metaSchema);\n    def.validateSchema = this.compile(metaSchema, true);\n}\nconst $dataRef = {\n    $ref: \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\n};\nfunction schemaOrData(schema) {\n    return { anyOf: [schema, $dataRef] };\n}\n//# sourceMappingURL=core.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.assignDefaults = void 0;\nconst codegen_1 = require(\"../codegen\");\nconst util_1 = require(\"../util\");\nfunction assignDefaults(it, ty) {\n    const { properties, items } = it.schema;\n    if (ty === \"object\" && properties) {\n        for (const key in properties) {\n            assignDefault(it, key, properties[key].default);\n        }\n    }\n    else if (ty === \"array\" && Array.isArray(items)) {\n        items.forEach((sch, i) => assignDefault(it, i, sch.default));\n    }\n}\nexports.assignDefaults = assignDefaults;\nfunction assignDefault(it, prop, defaultValue) {\n    const { gen, compositeRule, data, opts } = it;\n    if (defaultValue === undefined)\n        return;\n    const childData = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(prop)}`;\n    if (compositeRule) {\n        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);\n        return;\n    }\n    let condition = (0, codegen_1._) `${childData} === undefined`;\n    if (opts.useDefaults === \"empty\") {\n        condition = (0, codegen_1._) `${condition} || ${childData} === null || ${childData} === \"\"`;\n    }\n    // `${childData} === undefined` +\n    // (opts.useDefaults === \"empty\" ? ` || ${childData} === null || ${childData} === \"\"` : \"\")\n    gen.if(condition, (0, codegen_1._) `${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);\n}\n//# sourceMappingURL=defaults.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.shouldUseRule = exports.shouldUseGroup = exports.schemaHasRulesForType = void 0;\nfunction schemaHasRulesForType({ schema, self }, type) {\n    const group = self.RULES.types[type];\n    return group && group !== true && shouldUseGroup(schema, group);\n}\nexports.schemaHasRulesForType = schemaHasRulesForType;\nfunction shouldUseGroup(schema, group) {\n    return group.rules.some((rule) => shouldUseRule(schema, rule));\n}\nexports.shouldUseGroup = shouldUseGroup;\nfunction shouldUseRule(schema, rule) {\n    var _a;\n    return (schema[rule.keyword] !== undefined ||\n        ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== undefined)));\n}\nexports.shouldUseRule = shouldUseRule;\n//# sourceMappingURL=applicability.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;\nconst rules_1 = require(\"../rules\");\nconst applicability_1 = require(\"./applicability\");\nconst errors_1 = require(\"../errors\");\nconst codegen_1 = require(\"../codegen\");\nconst util_1 = require(\"../util\");\nvar DataType;\n(function (DataType) {\n    DataType[DataType[\"Correct\"] = 0] = \"Correct\";\n    DataType[DataType[\"Wrong\"] = 1] = \"Wrong\";\n})(DataType || (exports.DataType = DataType = {}));\nfunction getSchemaTypes(schema) {\n    const types = getJSONTypes(schema.type);\n    const hasNull = types.includes(\"null\");\n    if (hasNull) {\n        if (schema.nullable === false)\n            throw new Error(\"type: null contradicts nullable: false\");\n    }\n    else {\n        if (!types.length && schema.nullable !== undefined) {\n            throw new Error('\"nullable\" cannot be used without \"type\"');\n        }\n        if (schema.nullable === true)\n            types.push(\"null\");\n    }\n    return types;\n}\nexports.getSchemaTypes = getSchemaTypes;\n// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\nfunction getJSONTypes(ts) {\n    const types = Array.isArray(ts) ? ts : ts ? [ts] : [];\n    if (types.every(rules_1.isJSONType))\n        return types;\n    throw new Error(\"type must be JSONType or JSONType[]: \" + types.join(\",\"));\n}\nexports.getJSONTypes = getJSONTypes;\nfunction coerceAndCheckDataType(it, types) {\n    const { gen, data, opts } = it;\n    const coerceTo = coerceToTypes(types, opts.coerceTypes);\n    const checkTypes = types.length > 0 &&\n        !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));\n    if (checkTypes) {\n        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);\n        gen.if(wrongType, () => {\n            if (coerceTo.length)\n                coerceData(it, types, coerceTo);\n            else\n                reportTypeError(it);\n        });\n    }\n    return checkTypes;\n}\nexports.coerceAndCheckDataType = coerceAndCheckDataType;\nconst COERCIBLE = new Set([\"string\", \"number\", \"integer\", \"boolean\", \"null\"]);\nfunction coerceToTypes(types, coerceTypes) {\n    return coerceTypes\n        ? types.filter((t) => COERCIBLE.has(t) || (coerceTypes === \"array\" && t === \"array\"))\n        : [];\n}\nfunction coerceData(it, types, coerceTo) {\n    const { gen, data, opts } = it;\n    const dataType = gen.let(\"dataType\", (0, codegen_1._) `typeof ${data}`);\n    const coerced = gen.let(\"coerced\", (0, codegen_1._) `undefined`);\n    if (opts.coerceTypes === \"array\") {\n        gen.if((0, codegen_1._) `${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen\n            .assign(data, (0, codegen_1._) `${data}[0]`)\n            .assign(dataType, (0, codegen_1._) `typeof ${data}`)\n            .if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));\n    }\n    gen.if((0, codegen_1._) `${coerced} !== undefined`);\n    for (const t of coerceTo) {\n        if (COERCIBLE.has(t) || (t === \"array\" && opts.coerceTypes === \"array\")) {\n            coerceSpecificType(t);\n        }\n    }\n    gen.else();\n    reportTypeError(it);\n    gen.endIf();\n    gen.if((0, codegen_1._) `${coerced} !== undefined`, () => {\n        gen.assign(data, coerced);\n        assignParentData(it, coerced);\n    });\n    function coerceSpecificType(t) {\n        switch (t) {\n            case \"string\":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} == \"number\" || ${dataType} == \"boolean\"`)\n                    .assign(coerced, (0, codegen_1._) `\"\" + ${data}`)\n                    .elseIf((0, codegen_1._) `${data} === null`)\n                    .assign(coerced, (0, codegen_1._) `\"\"`);\n                return;\n            case \"number\":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} == \"boolean\" || ${data} === null\n              || (${dataType} == \"string\" && ${data} && ${data} == +${data})`)\n                    .assign(coerced, (0, codegen_1._) `+${data}`);\n                return;\n            case \"integer\":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} === \"boolean\" || ${data} === null\n              || (${dataType} === \"string\" && ${data} && ${data} == +${data} && !(${data} % 1))`)\n                    .assign(coerced, (0, codegen_1._) `+${data}`);\n                return;\n            case \"boolean\":\n                gen\n                    .elseIf((0, codegen_1._) `${data} === \"false\" || ${data} === 0 || ${data} === null`)\n                    .assign(coerced, false)\n                    .elseIf((0, codegen_1._) `${data} === \"true\" || ${data} === 1`)\n                    .assign(coerced, true);\n                return;\n            case \"null\":\n                gen.elseIf((0, codegen_1._) `${data} === \"\" || ${data} === 0 || ${data} === false`);\n                gen.assign(coerced, null);\n                return;\n            case \"array\":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} === \"string\" || ${dataType} === \"number\"\n              || ${dataType} === \"boolean\" || ${data} === null`)\n                    .assign(coerced, (0, codegen_1._) `[${data}]`);\n        }\n    }\n}\nfunction assignParentData({ gen, parentData, parentDataProperty }, expr) {\n    // TODO use gen.property\n    gen.if((0, codegen_1._) `${parentData} !== undefined`, () => gen.assign((0, codegen_1._) `${parentData}[${parentDataProperty}]`, expr));\n}\nfunction checkDataType(dataType, data, strictNums, correct = DataType.Correct) {\n    const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;\n    let cond;\n    switch (dataType) {\n        case \"null\":\n            return (0, codegen_1._) `${data} ${EQ} null`;\n        case \"array\":\n            cond = (0, codegen_1._) `Array.isArray(${data})`;\n            break;\n        case \"object\":\n            cond = (0, codegen_1._) `${data} && typeof ${data} == \"object\" && !Array.isArray(${data})`;\n            break;\n        case \"integer\":\n            cond = numCond((0, codegen_1._) `!(${data} % 1) && !isNaN(${data})`);\n            break;\n        case \"number\":\n            cond = numCond();\n            break;\n        default:\n            return (0, codegen_1._) `typeof ${data} ${EQ} ${dataType}`;\n    }\n    return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);\n    function numCond(_cond = codegen_1.nil) {\n        return (0, codegen_1.and)((0, codegen_1._) `typeof ${data} == \"number\"`, _cond, strictNums ? (0, codegen_1._) `isFinite(${data})` : codegen_1.nil);\n    }\n}\nexports.checkDataType = checkDataType;\nfunction checkDataTypes(dataTypes, data, strictNums, correct) {\n    if (dataTypes.length === 1) {\n        return checkDataType(dataTypes[0], data, strictNums, correct);\n    }\n    let cond;\n    const types = (0, util_1.toHash)(dataTypes);\n    if (types.array && types.object) {\n        const notObj = (0, codegen_1._) `typeof ${data} != \"object\"`;\n        cond = types.null ? notObj : (0, codegen_1._) `!${data} || ${notObj}`;\n        delete types.null;\n        delete types.array;\n        delete types.object;\n    }\n    else {\n        cond = codegen_1.nil;\n    }\n    if (types.number)\n        delete types.integer;\n    for (const t in types)\n        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));\n    return cond;\n}\nexports.checkDataTypes = checkDataTypes;\nconst typeError = {\n    message: ({ schema }) => `must be ${schema}`,\n    params: ({ schema, schemaValue }) => typeof schema == \"string\" ? (0, codegen_1._) `{type: ${schema}}` : (0, codegen_1._) `{type: ${schemaValue}}`,\n};\nfunction reportTypeError(it) {\n    const cxt = getTypeErrorContext(it);\n    (0, errors_1.reportError)(cxt, typeError);\n}\nexports.reportTypeError = reportTypeError;\nfunction getTypeErrorContext(it) {\n    const { gen, data, schema } = it;\n    const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, \"type\");\n    return {\n        gen,\n        keyword: \"type\",\n        data,\n        schema: schema.type,\n        schemaCode,\n        schemaValue: schemaCode,\n        parentSchema: schema,\n        params: {},\n        it,\n    };\n}\n//# sourceMappingURL=dataType.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getRules = exports.isJSONType = void 0;\nconst _jsonTypes = [\"string\", \"number\", \"integer\", \"boolean\", \"null\", \"object\", \"array\"];\nconst jsonTypes = new Set(_jsonTypes);\nfunction isJSONType(x) {\n    return typeof x == \"string\" && jsonTypes.has(x);\n}\nexports.isJSONType = isJSONType;\nfunction getRules() {\n    const groups = {\n        number: { type: \"number\", rules: [] },\n        string: { type: \"string\", rules: [] },\n        array: { type: \"array\", rules: [] },\n        object: { type: \"object\", rules: [] },\n    };\n    return {\n        types: { ...groups, integer: true, boolean: true, null: true },\n        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],\n        post: { rules: [] },\n        all: {},\n        keywords: {},\n    };\n}\nexports.getRules = getRules;\n//# sourceMappingURL=rules.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: ({ params: { min, max } }) => max === undefined\n        ? (0, codegen_1.str) `must contain at least ${min} valid item(s)`\n        : (0, codegen_1.str) `must contain at least ${min} and no more than ${max} valid item(s)`,\n    params: ({ params: { min, max } }) => max === undefined ? (0, codegen_1._) `{minContains: ${min}}` : (0, codegen_1._) `{minContains: ${min}, maxContains: ${max}}`,\n};\nconst def = {\n    keyword: \"contains\",\n    type: \"array\",\n    schemaType: [\"object\", \"boolean\"],\n    before: \"uniqueItems\",\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, schema, parentSchema, data, it } = cxt;\n        let min;\n        let max;\n        const { minContains, maxContains } = parentSchema;\n        if (it.opts.next) {\n            min = minContains === undefined ? 1 : minContains;\n            max = maxContains;\n        }\n        else {\n            min = 1;\n        }\n        const len = gen.const(\"len\", (0, codegen_1._) `${data}.length`);\n        cxt.setParams({ min, max });\n        if (max === undefined && min === 0) {\n            (0, util_1.checkStrictMode)(it, `\"minContains\" == 0 without \"maxContains\": \"contains\" keyword ignored`);\n            return;\n        }\n        if (max !== undefined && min > max) {\n            (0, util_1.checkStrictMode)(it, `\"minContains\" > \"maxContains\" is always invalid`);\n            cxt.fail();\n            return;\n        }\n        if ((0, util_1.alwaysValidSchema)(it, schema)) {\n            let cond = (0, codegen_1._) `${len} >= ${min}`;\n            if (max !== undefined)\n                cond = (0, codegen_1._) `${cond} && ${len} <= ${max}`;\n            cxt.pass(cond);\n            return;\n        }\n        it.items = true;\n        const valid = gen.name(\"valid\");\n        if (max === undefined && min === 1) {\n            validateItems(valid, () => gen.if(valid, () => gen.break()));\n        }\n        else if (min === 0) {\n            gen.let(valid, true);\n            if (max !== undefined)\n                gen.if((0, codegen_1._) `${data}.length > 0`, validateItemsWithCount);\n        }\n        else {\n            gen.let(valid, false);\n            validateItemsWithCount();\n        }\n        cxt.result(valid, () => cxt.reset());\n        function validateItemsWithCount() {\n            const schValid = gen.name(\"_valid\");\n            const count = gen.let(\"count\", 0);\n            validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));\n        }\n        function validateItems(_valid, block) {\n            gen.forRange(\"i\", 0, len, (i) => {\n                cxt.subschema({\n                    keyword: \"contains\",\n                    dataProp: i,\n                    dataPropType: util_1.Type.Num,\n                    compositeRule: true,\n                }, _valid);\n                block();\n            });\n        }\n        function checkLimits(count) {\n            gen.code((0, codegen_1._) `${count}++`);\n            if (max === undefined) {\n                gen.if((0, codegen_1._) `${count} >= ${min}`, () => gen.assign(valid, true).break());\n            }\n            else {\n                gen.if((0, codegen_1._) `${count} > ${max}`, () => gen.assign(valid, false).break());\n                if (min === 1)\n                    gen.assign(valid, true);\n                else\n                    gen.if((0, codegen_1._) `${count} >= ${min}`, () => gen.assign(valid, true));\n            }\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=contains.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst dynamicAnchor_1 = require(\"./dynamicAnchor\");\nconst util_1 = require(\"../../compile/util\");\nconst def = {\n    keyword: \"$recursiveAnchor\",\n    schemaType: \"boolean\",\n    code(cxt) {\n        if (cxt.schema)\n            (0, dynamicAnchor_1.dynamicAnchor)(cxt, \"\");\n        else\n            (0, util_1.checkStrictMode)(cxt.it, \"$recursiveAnchor: false is ignored\");\n    },\n};\nexports.default = def;\n//# sourceMappingURL=recursiveAnchor.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: ({ params: { len } }) => (0, codegen_1.str) `must NOT have more than ${len} items`,\n    params: ({ params: { len } }) => (0, codegen_1._) `{limit: ${len}}`,\n};\nconst def = {\n    keyword: \"unevaluatedItems\",\n    type: \"array\",\n    schemaType: [\"boolean\", \"object\"],\n    error,\n    code(cxt) {\n        const { gen, schema, data, it } = cxt;\n        const items = it.items || 0;\n        if (items === true)\n            return;\n        const len = gen.const(\"len\", (0, codegen_1._) `${data}.length`);\n        if (schema === false) {\n            cxt.setParams({ len: items });\n            cxt.fail((0, codegen_1._) `${len} > ${items}`);\n        }\n        else if (typeof schema == \"object\" && !(0, util_1.alwaysValidSchema)(it, schema)) {\n            const valid = gen.var(\"valid\", (0, codegen_1._) `${len} <= ${items}`);\n            gen.if((0, codegen_1.not)(valid), () => validateItems(valid, items));\n            cxt.ok(valid);\n        }\n        it.items = true;\n        function validateItems(valid, from) {\n            gen.forRange(\"i\", from, len, (i) => {\n                cxt.subschema({ keyword: \"unevaluatedItems\", dataProp: i, dataPropType: util_1.Type.Num }, valid);\n                if (!it.allErrors)\n                    gen.if((0, codegen_1.not)(valid), () => gen.break());\n            });\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=unevaluatedItems.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass ValidationError extends Error {\n    constructor(errors) {\n        super(\"validation failed\");\n        this.errors = errors;\n        this.ajv = this.validation = true;\n    }\n}\nexports.default = ValidationError;\n//# sourceMappingURL=validation_error.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.callRef = exports.getValidate = void 0;\nconst ref_error_1 = require(\"../../compile/ref_error\");\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst names_1 = require(\"../../compile/names\");\nconst compile_1 = require(\"../../compile\");\nconst util_1 = require(\"../../compile/util\");\nconst def = {\n    keyword: \"$ref\",\n    schemaType: \"string\",\n    code(cxt) {\n        const { gen, schema: $ref, it } = cxt;\n        const { baseId, schemaEnv: env, validateName, opts, self } = it;\n        const { root } = env;\n        if (($ref === \"#\" || $ref === \"#/\") && baseId === root.baseId)\n            return callRootRef();\n        const schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);\n        if (schOrEnv === undefined)\n            throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);\n        if (schOrEnv instanceof compile_1.SchemaEnv)\n            return callValidate(schOrEnv);\n        return inlineRefSchema(schOrEnv);\n        function callRootRef() {\n            if (env === root)\n                return callRef(cxt, validateName, env, env.$async);\n            const rootName = gen.scopeValue(\"root\", { ref: root });\n            return callRef(cxt, (0, codegen_1._) `${rootName}.validate`, root, root.$async);\n        }\n        function callValidate(sch) {\n            const v = getValidate(cxt, sch);\n            callRef(cxt, v, sch, sch.$async);\n        }\n        function inlineRefSchema(sch) {\n            const schName = gen.scopeValue(\"schema\", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });\n            const valid = gen.name(\"valid\");\n            const schCxt = cxt.subschema({\n                schema: sch,\n                dataTypes: [],\n                schemaPath: codegen_1.nil,\n                topSchemaRef: schName,\n                errSchemaPath: $ref,\n            }, valid);\n            cxt.mergeEvaluated(schCxt);\n            cxt.ok(valid);\n        }\n    },\n};\nfunction getValidate(cxt, sch) {\n    const { gen } = cxt;\n    return sch.validate\n        ? gen.scopeValue(\"validate\", { ref: sch.validate })\n        : (0, codegen_1._) `${gen.scopeValue(\"wrapper\", { ref: sch })}.validate`;\n}\nexports.getValidate = getValidate;\nfunction callRef(cxt, v, sch, $async) {\n    const { gen, it } = cxt;\n    const { allErrors, schemaEnv: env, opts } = it;\n    const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;\n    if ($async)\n        callAsyncRef();\n    else\n        callSyncRef();\n    function callAsyncRef() {\n        if (!env.$async)\n            throw new Error(\"async schema referenced by sync schema\");\n        const valid = gen.let(\"valid\");\n        gen.try(() => {\n            gen.code((0, codegen_1._) `await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);\n            addEvaluatedFrom(v); // TODO will not work with async, it has to be returned with the result\n            if (!allErrors)\n                gen.assign(valid, true);\n        }, (e) => {\n            gen.if((0, codegen_1._) `!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));\n            addErrorsFrom(e);\n            if (!allErrors)\n                gen.assign(valid, false);\n        });\n        cxt.ok(valid);\n    }\n    function callSyncRef() {\n        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));\n    }\n    function addErrorsFrom(source) {\n        const errs = (0, codegen_1._) `${source}.errors`;\n        gen.assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`); // TODO tagged\n        gen.assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors}.length`);\n    }\n    function addEvaluatedFrom(source) {\n        var _a;\n        if (!it.opts.unevaluated)\n            return;\n        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;\n        // TODO refactor\n        if (it.props !== true) {\n            if (schEvaluated && !schEvaluated.dynamicProps) {\n                if (schEvaluated.props !== undefined) {\n                    it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);\n                }\n            }\n            else {\n                const props = gen.var(\"props\", (0, codegen_1._) `${source}.evaluated.props`);\n                it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);\n            }\n        }\n        if (it.items !== true) {\n            if (schEvaluated && !schEvaluated.dynamicItems) {\n                if (schEvaluated.items !== undefined) {\n                    it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);\n                }\n            }\n            else {\n                const items = gen.var(\"items\", (0, codegen_1._) `${source}.evaluated.items`);\n                it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);\n            }\n        }\n    }\n}\nexports.callRef = callRef;\nexports.default = def;\n//# sourceMappingURL=ref.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst util_1 = require(\"../../compile/util\");\nconst def = {\n    keyword: [\"then\", \"else\"],\n    schemaType: [\"object\", \"boolean\"],\n    code({ keyword, parentSchema, it }) {\n        if (parentSchema.if === undefined)\n            (0, util_1.checkStrictMode)(it, `\"${keyword}\" without \"if\" is ignored`);\n    },\n};\nexports.default = def;\n//# sourceMappingURL=thenElse.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateAdditionalItems = void 0;\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: ({ params: { len } }) => (0, codegen_1.str) `must NOT have more than ${len} items`,\n    params: ({ params: { len } }) => (0, codegen_1._) `{limit: ${len}}`,\n};\nconst def = {\n    keyword: \"additionalItems\",\n    type: \"array\",\n    schemaType: [\"boolean\", \"object\"],\n    before: \"uniqueItems\",\n    error,\n    code(cxt) {\n        const { parentSchema, it } = cxt;\n        const { items } = parentSchema;\n        if (!Array.isArray(items)) {\n            (0, util_1.checkStrictMode)(it, '\"additionalItems\" is ignored when \"items\" is not an array of schemas');\n            return;\n        }\n        validateAdditionalItems(cxt, items);\n    },\n};\nfunction validateAdditionalItems(cxt, items) {\n    const { gen, schema, data, keyword, it } = cxt;\n    it.items = true;\n    const len = gen.const(\"len\", (0, codegen_1._) `${data}.length`);\n    if (schema === false) {\n        cxt.setParams({ len: items.length });\n        cxt.pass((0, codegen_1._) `${len} <= ${items.length}`);\n    }\n    else if (typeof schema == \"object\" && !(0, util_1.alwaysValidSchema)(it, schema)) {\n        const valid = gen.var(\"valid\", (0, codegen_1._) `${len} <= ${items.length}`); // TODO var\n        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));\n        cxt.ok(valid);\n    }\n    function validateItems(valid) {\n        gen.forRange(\"i\", items.length, len, (i) => {\n            cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);\n            if (!it.allErrors)\n                gen.if((0, codegen_1.not)(valid), () => gen.break());\n        });\n    }\n}\nexports.validateAdditionalItems = validateAdditionalItems;\nexports.default = def;\n//# sourceMappingURL=additionalItems.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = void 0;\nconst codegen_1 = require(\"../compile/codegen\");\nconst util_1 = require(\"../compile/util\");\nconst names_1 = require(\"../compile/names\");\nconst util_2 = require(\"../compile/util\");\nfunction checkReportMissingProp(cxt, prop) {\n    const { gen, data, it } = cxt;\n    gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {\n        cxt.setParams({ missingProperty: (0, codegen_1._) `${prop}` }, true);\n        cxt.error();\n    });\n}\nexports.checkReportMissingProp = checkReportMissingProp;\nfunction checkMissingProp({ gen, data, it: { opts } }, properties, missing) {\n    return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._) `${missing} = ${prop}`)));\n}\nexports.checkMissingProp = checkMissingProp;\nfunction reportMissingProp(cxt, missing) {\n    cxt.setParams({ missingProperty: missing }, true);\n    cxt.error();\n}\nexports.reportMissingProp = reportMissingProp;\nfunction hasPropFunc(gen) {\n    return gen.scopeValue(\"func\", {\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        ref: Object.prototype.hasOwnProperty,\n        code: (0, codegen_1._) `Object.prototype.hasOwnProperty`,\n    });\n}\nexports.hasPropFunc = hasPropFunc;\nfunction isOwnProperty(gen, data, property) {\n    return (0, codegen_1._) `${hasPropFunc(gen)}.call(${data}, ${property})`;\n}\nexports.isOwnProperty = isOwnProperty;\nfunction propertyInData(gen, data, property, ownProperties) {\n    const cond = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(property)} !== undefined`;\n    return ownProperties ? (0, codegen_1._) `${cond} && ${isOwnProperty(gen, data, property)}` : cond;\n}\nexports.propertyInData = propertyInData;\nfunction noPropertyInData(gen, data, property, ownProperties) {\n    const cond = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(property)} === undefined`;\n    return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;\n}\nexports.noPropertyInData = noPropertyInData;\nfunction allSchemaProperties(schemaMap) {\n    return schemaMap ? Object.keys(schemaMap).filter((p) => p !== \"__proto__\") : [];\n}\nexports.allSchemaProperties = allSchemaProperties;\nfunction schemaProperties(it, schemaMap) {\n    return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));\n}\nexports.schemaProperties = schemaProperties;\nfunction callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {\n    const dataAndSchema = passSchema ? (0, codegen_1._) `${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;\n    const valCxt = [\n        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],\n        [names_1.default.parentData, it.parentData],\n        [names_1.default.parentDataProperty, it.parentDataProperty],\n        [names_1.default.rootData, names_1.default.rootData],\n    ];\n    if (it.opts.dynamicRef)\n        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);\n    const args = (0, codegen_1._) `${dataAndSchema}, ${gen.object(...valCxt)}`;\n    return context !== codegen_1.nil ? (0, codegen_1._) `${func}.call(${context}, ${args})` : (0, codegen_1._) `${func}(${args})`;\n}\nexports.callValidateCode = callValidateCode;\nconst newRegExp = (0, codegen_1._) `new RegExp`;\nfunction usePattern({ gen, it: { opts } }, pattern) {\n    const u = opts.unicodeRegExp ? \"u\" : \"\";\n    const { regExp } = opts.code;\n    const rx = regExp(pattern, u);\n    return gen.scopeValue(\"pattern\", {\n        key: rx.toString(),\n        ref: rx,\n        code: (0, codegen_1._) `${regExp.code === \"new RegExp\" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`,\n    });\n}\nexports.usePattern = usePattern;\nfunction validateArray(cxt) {\n    const { gen, data, keyword, it } = cxt;\n    const valid = gen.name(\"valid\");\n    if (it.allErrors) {\n        const validArr = gen.let(\"valid\", true);\n        validateItems(() => gen.assign(validArr, false));\n        return validArr;\n    }\n    gen.var(valid, true);\n    validateItems(() => gen.break());\n    return valid;\n    function validateItems(notValid) {\n        const len = gen.const(\"len\", (0, codegen_1._) `${data}.length`);\n        gen.forRange(\"i\", 0, len, (i) => {\n            cxt.subschema({\n                keyword,\n                dataProp: i,\n                dataPropType: util_1.Type.Num,\n            }, valid);\n            gen.if((0, codegen_1.not)(valid), notValid);\n        });\n    }\n}\nexports.validateArray = validateArray;\nfunction validateUnion(cxt) {\n    const { gen, schema, keyword, it } = cxt;\n    /* istanbul ignore if */\n    if (!Array.isArray(schema))\n        throw new Error(\"ajv implementation error\");\n    const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));\n    if (alwaysValid && !it.opts.unevaluated)\n        return;\n    const valid = gen.let(\"valid\", false);\n    const schValid = gen.name(\"_valid\");\n    gen.block(() => schema.forEach((_sch, i) => {\n        const schCxt = cxt.subschema({\n            keyword,\n            schemaProp: i,\n            compositeRule: true,\n        }, schValid);\n        gen.assign(valid, (0, codegen_1._) `${valid} || ${schValid}`);\n        const merged = cxt.mergeValidEvaluated(schCxt, schValid);\n        // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)\n        // or if all properties and items were evaluated (it.props === true && it.items === true)\n        if (!merged)\n            gen.if((0, codegen_1.not)(valid));\n    }));\n    cxt.result(valid, () => cxt.reset(), () => cxt.error(true));\n}\nexports.validateUnion = validateUnion;\n//# sourceMappingURL=code.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst util_1 = require(\"../../compile/util\");\nconst def = {\n    keyword: \"allOf\",\n    schemaType: \"array\",\n    code(cxt) {\n        const { gen, schema, it } = cxt;\n        /* istanbul ignore if */\n        if (!Array.isArray(schema))\n            throw new Error(\"ajv implementation error\");\n        const valid = gen.name(\"valid\");\n        schema.forEach((sch, i) => {\n            if ((0, util_1.alwaysValidSchema)(it, sch))\n                return;\n            const schCxt = cxt.subschema({ keyword: \"allOf\", schemaProp: i }, valid);\n            cxt.ok(valid);\n            cxt.mergeEvaluated(schCxt);\n        });\n    },\n};\nexports.default = def;\n//# sourceMappingURL=allOf.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst code_1 = require(\"../code\");\nconst def = {\n    keyword: \"anyOf\",\n    schemaType: \"array\",\n    trackErrors: true,\n    code: code_1.validateUnion,\n    error: { message: \"must match a schema in anyOf\" },\n};\nexports.default = def;\n//# sourceMappingURL=anyOf.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: \"property name must be valid\",\n    params: ({ params }) => (0, codegen_1._) `{propertyName: ${params.propertyName}}`,\n};\nconst def = {\n    keyword: \"propertyNames\",\n    type: \"object\",\n    schemaType: [\"object\", \"boolean\"],\n    error,\n    code(cxt) {\n        const { gen, schema, data, it } = cxt;\n        if ((0, util_1.alwaysValidSchema)(it, schema))\n            return;\n        const valid = gen.name(\"valid\");\n        gen.forIn(\"key\", data, (key) => {\n            cxt.setParams({ propertyName: key });\n            cxt.subschema({\n                keyword: \"propertyNames\",\n                data: key,\n                dataTypes: [\"string\"],\n                propertyName: key,\n                compositeRule: true,\n            }, valid);\n            gen.if((0, codegen_1.not)(valid), () => {\n                cxt.error(true);\n                if (!it.allErrors)\n                    gen.break();\n            });\n        });\n        cxt.ok(valid);\n    },\n};\nexports.default = def;\n//# sourceMappingURL=propertyNames.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateTuple = void 0;\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst code_1 = require(\"../code\");\nconst def = {\n    keyword: \"items\",\n    type: \"array\",\n    schemaType: [\"object\", \"array\", \"boolean\"],\n    before: \"uniqueItems\",\n    code(cxt) {\n        const { schema, it } = cxt;\n        if (Array.isArray(schema))\n            return validateTuple(cxt, \"additionalItems\", schema);\n        it.items = true;\n        if ((0, util_1.alwaysValidSchema)(it, schema))\n            return;\n        cxt.ok((0, code_1.validateArray)(cxt));\n    },\n};\nfunction validateTuple(cxt, extraItems, schArr = cxt.schema) {\n    const { gen, parentSchema, data, keyword, it } = cxt;\n    checkStrictTuple(parentSchema);\n    if (it.opts.unevaluated && schArr.length && it.items !== true) {\n        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);\n    }\n    const valid = gen.name(\"valid\");\n    const len = gen.const(\"len\", (0, codegen_1._) `${data}.length`);\n    schArr.forEach((sch, i) => {\n        if ((0, util_1.alwaysValidSchema)(it, sch))\n            return;\n        gen.if((0, codegen_1._) `${len} > ${i}`, () => cxt.subschema({\n            keyword,\n            schemaProp: i,\n            dataProp: i,\n        }, valid));\n        cxt.ok(valid);\n    });\n    function checkStrictTuple(sch) {\n        const { opts, errSchemaPath } = it;\n        const l = schArr.length;\n        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);\n        if (opts.strictTuples && !fullTuple) {\n            const msg = `\"${keyword}\" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path \"${errSchemaPath}\"`;\n            (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);\n        }\n    }\n}\nexports.validateTuple = validateTuple;\nexports.default = def;\n//# sourceMappingURL=items.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst dynamicRef_1 = require(\"./dynamicRef\");\nconst def = {\n    keyword: \"$recursiveRef\",\n    schemaType: \"string\",\n    code: (cxt) => (0, dynamicRef_1.dynamicRef)(cxt, cxt.schema),\n};\nexports.default = def;\n//# sourceMappingURL=recursiveRef.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = void 0;\nconst codegen_1 = require(\"../codegen\");\nconst util_1 = require(\"../util\");\nfunction getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {\n    if (keyword !== undefined && schema !== undefined) {\n        throw new Error('both \"keyword\" and \"schema\" passed, only one allowed');\n    }\n    if (keyword !== undefined) {\n        const sch = it.schema[keyword];\n        return schemaProp === undefined\n            ? {\n                schema: sch,\n                schemaPath: (0, codegen_1._) `${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,\n                errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n            }\n            : {\n                schema: sch[schemaProp],\n                schemaPath: (0, codegen_1._) `${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,\n                errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`,\n            };\n    }\n    if (schema !== undefined) {\n        if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {\n            throw new Error('\"schemaPath\", \"errSchemaPath\" and \"topSchemaRef\" are required with \"schema\"');\n        }\n        return {\n            schema,\n            schemaPath,\n            topSchemaRef,\n            errSchemaPath,\n        };\n    }\n    throw new Error('either \"keyword\" or \"schema\" must be passed');\n}\nexports.getSubschema = getSubschema;\nfunction extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {\n    if (data !== undefined && dataProp !== undefined) {\n        throw new Error('both \"data\" and \"dataProp\" passed, only one allowed');\n    }\n    const { gen } = it;\n    if (dataProp !== undefined) {\n        const { errorPath, dataPathArr, opts } = it;\n        const nextData = gen.let(\"data\", (0, codegen_1._) `${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);\n        dataContextProps(nextData);\n        subschema.errorPath = (0, codegen_1.str) `${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;\n        subschema.parentDataProperty = (0, codegen_1._) `${dataProp}`;\n        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];\n    }\n    if (data !== undefined) {\n        const nextData = data instanceof codegen_1.Name ? data : gen.let(\"data\", data, true); // replaceable if used once?\n        dataContextProps(nextData);\n        if (propertyName !== undefined)\n            subschema.propertyName = propertyName;\n        // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr\n    }\n    if (dataTypes)\n        subschema.dataTypes = dataTypes;\n    function dataContextProps(_nextData) {\n        subschema.data = _nextData;\n        subschema.dataLevel = it.dataLevel + 1;\n        subschema.dataTypes = [];\n        it.definedProperties = new Set();\n        subschema.parentData = it.data;\n        subschema.dataNames = [...it.dataNames, _nextData];\n    }\n}\nexports.extendSubschemaData = extendSubschemaData;\nfunction extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {\n    if (compositeRule !== undefined)\n        subschema.compositeRule = compositeRule;\n    if (createErrors !== undefined)\n        subschema.createErrors = createErrors;\n    if (allErrors !== undefined)\n        subschema.allErrors = allErrors;\n    subschema.jtdDiscriminator = jtdDiscriminator; // not inherited\n    subschema.jtdMetadata = jtdMetadata; // not inherited\n}\nexports.extendSubschemaMode = extendSubschemaMode;\n//# sourceMappingURL=subschema.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst dependentRequired_1 = require(\"./validation/dependentRequired\");\nconst dependentSchemas_1 = require(\"./applicator/dependentSchemas\");\nconst limitContains_1 = require(\"./validation/limitContains\");\nconst next = [dependentRequired_1.default, dependentSchemas_1.default, limitContains_1.default];\nexports.default = next;\n//# sourceMappingURL=next.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst equal_1 = require(\"../../runtime/equal\");\nconst error = {\n    message: \"must be equal to constant\",\n    params: ({ schemaCode }) => (0, codegen_1._) `{allowedValue: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"const\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, $data, schemaCode, schema } = cxt;\n        if ($data || (schema && typeof schema == \"object\")) {\n            cxt.fail$data((0, codegen_1._) `!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);\n        }\n        else {\n            cxt.fail((0, codegen_1._) `${schema} !== ${data}`);\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=const.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst equal_1 = require(\"../../runtime/equal\");\nconst error = {\n    message: \"must be equal to one of the allowed values\",\n    params: ({ schemaCode }) => (0, codegen_1._) `{allowedValues: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"enum\",\n    schemaType: \"array\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, $data, schema, schemaCode, it } = cxt;\n        if (!$data && schema.length === 0)\n            throw new Error(\"enum must have non-empty array\");\n        const useLoop = schema.length >= it.opts.loopEnum;\n        let eql;\n        const getEql = () => (eql !== null && eql !== void 0 ? eql : (eql = (0, util_1.useFunc)(gen, equal_1.default)));\n        let valid;\n        if (useLoop || $data) {\n            valid = gen.let(\"valid\");\n            cxt.block$data(valid, loopEnum);\n        }\n        else {\n            /* istanbul ignore if */\n            if (!Array.isArray(schema))\n                throw new Error(\"ajv implementation error\");\n            const vSchema = gen.const(\"vSchema\", schemaCode);\n            valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));\n        }\n        cxt.pass(valid);\n        function loopEnum() {\n            gen.assign(valid, false);\n            gen.forOf(\"v\", schemaCode, (v) => gen.if((0, codegen_1._) `${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));\n        }\n        function equalCode(vSchema, i) {\n            const sch = schema[i];\n            return typeof sch === \"object\" && sch !== null\n                ? (0, codegen_1._) `${getEql()}(${data}, ${vSchema}[${i}])`\n                : (0, codegen_1._) `${data} === ${sch}`;\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=enum.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;\nconst errors_1 = require(\"../errors\");\nconst codegen_1 = require(\"../codegen\");\nconst names_1 = require(\"../names\");\nconst boolError = {\n    message: \"boolean schema is false\",\n};\nfunction topBoolOrEmptySchema(it) {\n    const { gen, schema, validateName } = it;\n    if (schema === false) {\n        falseSchemaError(it, false);\n    }\n    else if (typeof schema == \"object\" && schema.$async === true) {\n        gen.return(names_1.default.data);\n    }\n    else {\n        gen.assign((0, codegen_1._) `${validateName}.errors`, null);\n        gen.return(true);\n    }\n}\nexports.topBoolOrEmptySchema = topBoolOrEmptySchema;\nfunction boolOrEmptySchema(it, valid) {\n    const { gen, schema } = it;\n    if (schema === false) {\n        gen.var(valid, false); // TODO var\n        falseSchemaError(it);\n    }\n    else {\n        gen.var(valid, true); // TODO var\n    }\n}\nexports.boolOrEmptySchema = boolOrEmptySchema;\nfunction falseSchemaError(it, overrideAllErrors) {\n    const { gen, data } = it;\n    // TODO maybe some other interface should be used for non-keyword validation errors...\n    const cxt = {\n        gen,\n        keyword: \"false schema\",\n        data,\n        schema: false,\n        schemaCode: false,\n        schemaValue: false,\n        params: {},\n        it,\n    };\n    (0, errors_1.reportError)(cxt, boolError, undefined, overrideAllErrors);\n}\n//# sourceMappingURL=boolSchema.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst dependencies_1 = require(\"../applicator/dependencies\");\nconst def = {\n    keyword: \"dependentRequired\",\n    type: \"object\",\n    schemaType: \"object\",\n    error: dependencies_1.error,\n    code: (cxt) => (0, dependencies_1.validatePropertyDeps)(cxt),\n};\nexports.default = def;\n//# sourceMappingURL=dependentRequired.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst util_1 = require(\"../../compile/util\");\nconst def = {\n    keyword: [\"maxContains\", \"minContains\"],\n    type: \"array\",\n    schemaType: \"number\",\n    code({ keyword, parentSchema, it }) {\n        if (parentSchema.contains === undefined) {\n            (0, util_1.checkStrictMode)(it, `\"${keyword}\" without \"contains\" is ignored`);\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=limitContains.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.dynamicRef = void 0;\nconst codegen_1 = require(\"../../compile/codegen\");\nconst names_1 = require(\"../../compile/names\");\nconst ref_1 = require(\"../core/ref\");\nconst def = {\n    keyword: \"$dynamicRef\",\n    schemaType: \"string\",\n    code: (cxt) => dynamicRef(cxt, cxt.schema),\n};\nfunction dynamicRef(cxt, ref) {\n    const { gen, keyword, it } = cxt;\n    if (ref[0] !== \"#\")\n        throw new Error(`\"${keyword}\" only supports hash fragment reference`);\n    const anchor = ref.slice(1);\n    if (it.allErrors) {\n        _dynamicRef();\n    }\n    else {\n        const valid = gen.let(\"valid\", false);\n        _dynamicRef(valid);\n        cxt.ok(valid);\n    }\n    function _dynamicRef(valid) {\n        // TODO the assumption here is that `recursiveRef: #` always points to the root\n        // of the schema object, which is not correct, because there may be $id that\n        // makes # point to it, and the target schema may not contain dynamic/recursiveAnchor.\n        // Because of that 2 tests in recursiveRef.json fail.\n        // This is a similar problem to #815 (`$id` doesn't alter resolution scope for `{ \"$ref\": \"#\" }`).\n        // (This problem is not tested in JSON-Schema-Test-Suite)\n        if (it.schemaEnv.root.dynamicAnchors[anchor]) {\n            const v = gen.let(\"_v\", (0, codegen_1._) `${names_1.default.dynamicAnchors}${(0, codegen_1.getProperty)(anchor)}`);\n            gen.if(v, _callRef(v, valid), _callRef(it.validateName, valid));\n        }\n        else {\n            _callRef(it.validateName, valid)();\n        }\n    }\n    function _callRef(validate, valid) {\n        return valid\n            ? () => gen.block(() => {\n                (0, ref_1.callRef)(cxt, validate);\n                gen.let(valid, true);\n            })\n            : () => (0, ref_1.callRef)(cxt, validate);\n    }\n}\nexports.dynamicRef = dynamicRef;\nexports.default = def;\n//# sourceMappingURL=dynamicRef.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;\nconst codegen_1 = require(\"../codegen\");\nconst names_1 = require(\"../names\");\nconst code_1 = require(\"../../vocabularies/code\");\nconst errors_1 = require(\"../errors\");\nfunction macroKeywordCode(cxt, def) {\n    const { gen, keyword, schema, parentSchema, it } = cxt;\n    const macroSchema = def.macro.call(it.self, schema, parentSchema, it);\n    const schemaRef = useKeyword(gen, keyword, macroSchema);\n    if (it.opts.validateSchema !== false)\n        it.self.validateSchema(macroSchema, true);\n    const valid = gen.name(\"valid\");\n    cxt.subschema({\n        schema: macroSchema,\n        schemaPath: codegen_1.nil,\n        errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n        topSchemaRef: schemaRef,\n        compositeRule: true,\n    }, valid);\n    cxt.pass(valid, () => cxt.error(true));\n}\nexports.macroKeywordCode = macroKeywordCode;\nfunction funcKeywordCode(cxt, def) {\n    var _a;\n    const { gen, keyword, schema, parentSchema, $data, it } = cxt;\n    checkAsyncKeyword(it, def);\n    const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;\n    const validateRef = useKeyword(gen, keyword, validate);\n    const valid = gen.let(\"valid\");\n    cxt.block$data(valid, validateKeyword);\n    cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);\n    function validateKeyword() {\n        if (def.errors === false) {\n            assignValid();\n            if (def.modifying)\n                modifyData(cxt);\n            reportErrs(() => cxt.error());\n        }\n        else {\n            const ruleErrs = def.async ? validateAsync() : validateSync();\n            if (def.modifying)\n                modifyData(cxt);\n            reportErrs(() => addErrs(cxt, ruleErrs));\n        }\n    }\n    function validateAsync() {\n        const ruleErrs = gen.let(\"ruleErrs\", null);\n        gen.try(() => assignValid((0, codegen_1._) `await `), (e) => gen.assign(valid, false).if((0, codegen_1._) `${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._) `${e}.errors`), () => gen.throw(e)));\n        return ruleErrs;\n    }\n    function validateSync() {\n        const validateErrs = (0, codegen_1._) `${validateRef}.errors`;\n        gen.assign(validateErrs, null);\n        assignValid(codegen_1.nil);\n        return validateErrs;\n    }\n    function assignValid(_await = def.async ? (0, codegen_1._) `await ` : codegen_1.nil) {\n        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;\n        const passSchema = !((\"compile\" in def && !$data) || def.schema === false);\n        gen.assign(valid, (0, codegen_1._) `${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);\n    }\n    function reportErrs(errors) {\n        var _a;\n        gen.if((0, codegen_1.not)((_a = def.valid) !== null && _a !== void 0 ? _a : valid), errors);\n    }\n}\nexports.funcKeywordCode = funcKeywordCode;\nfunction modifyData(cxt) {\n    const { gen, data, it } = cxt;\n    gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._) `${it.parentData}[${it.parentDataProperty}]`));\n}\nfunction addErrs(cxt, errs) {\n    const { gen } = cxt;\n    gen.if((0, codegen_1._) `Array.isArray(${errs})`, () => {\n        gen\n            .assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`)\n            .assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors}.length`);\n        (0, errors_1.extendErrors)(cxt);\n    }, () => cxt.error());\n}\nfunction checkAsyncKeyword({ schemaEnv }, def) {\n    if (def.async && !schemaEnv.$async)\n        throw new Error(\"async keyword in sync schema\");\n}\nfunction useKeyword(gen, keyword, result) {\n    if (result === undefined)\n        throw new Error(`keyword \"${keyword}\" failed to compile`);\n    return gen.scopeValue(\"keyword\", typeof result == \"function\" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });\n}\nfunction validSchemaType(schema, schemaType, allowUndefined = false) {\n    // TODO add tests\n    return (!schemaType.length ||\n        schemaType.some((st) => st === \"array\"\n            ? Array.isArray(schema)\n            : st === \"object\"\n                ? schema && typeof schema == \"object\" && !Array.isArray(schema)\n                : typeof schema == st || (allowUndefined && typeof schema == \"undefined\")));\n}\nexports.validSchemaType = validSchemaType;\nfunction validateKeywordUsage({ schema, opts, self, errSchemaPath }, def, keyword) {\n    /* istanbul ignore if */\n    if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {\n        throw new Error(\"ajv implementation error\");\n    }\n    const deps = def.dependencies;\n    if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {\n        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(\",\")}`);\n    }\n    if (def.validateSchema) {\n        const valid = def.validateSchema(schema[keyword]);\n        if (!valid) {\n            const msg = `keyword \"${keyword}\" value is invalid at path \"${errSchemaPath}\": ` +\n                self.errorsText(def.validateSchema.errors);\n            if (opts.validateSchema === \"log\")\n                self.logger.error(msg);\n            else\n                throw new Error(msg);\n        }\n    }\n}\nexports.validateKeywordUsage = validateKeywordUsage;\n//# sourceMappingURL=keyword.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: ({ params: { missingProperty } }) => (0, codegen_1.str) `must have required property '${missingProperty}'`,\n    params: ({ params: { missingProperty } }) => (0, codegen_1._) `{missingProperty: ${missingProperty}}`,\n};\nconst def = {\n    keyword: \"required\",\n    type: \"object\",\n    schemaType: \"array\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, schema, schemaCode, data, $data, it } = cxt;\n        const { opts } = it;\n        if (!$data && schema.length === 0)\n            return;\n        const useLoop = schema.length >= opts.loopRequired;\n        if (it.allErrors)\n            allErrorsMode();\n        else\n            exitOnErrorMode();\n        if (opts.strictRequired) {\n            const props = cxt.parentSchema.properties;\n            const { definedProperties } = cxt.it;\n            for (const requiredKey of schema) {\n                if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === undefined && !definedProperties.has(requiredKey)) {\n                    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n                    const msg = `required property \"${requiredKey}\" is not defined at \"${schemaPath}\" (strictRequired)`;\n                    (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);\n                }\n            }\n        }\n        function allErrorsMode() {\n            if (useLoop || $data) {\n                cxt.block$data(codegen_1.nil, loopAllRequired);\n            }\n            else {\n                for (const prop of schema) {\n                    (0, code_1.checkReportMissingProp)(cxt, prop);\n                }\n            }\n        }\n        function exitOnErrorMode() {\n            const missing = gen.let(\"missing\");\n            if (useLoop || $data) {\n                const valid = gen.let(\"valid\", true);\n                cxt.block$data(valid, () => loopUntilMissing(missing, valid));\n                cxt.ok(valid);\n            }\n            else {\n                gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));\n                (0, code_1.reportMissingProp)(cxt, missing);\n                gen.else();\n            }\n        }\n        function loopAllRequired() {\n            gen.forOf(\"prop\", schemaCode, (prop) => {\n                cxt.setParams({ missingProperty: prop });\n                gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());\n            });\n        }\n        function loopUntilMissing(missing, valid) {\n            cxt.setParams({ missingProperty: missing });\n            gen.forOf(missing, schemaCode, () => {\n                gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));\n                gen.if((0, codegen_1.not)(valid), () => {\n                    cxt.error();\n                    gen.break();\n                });\n            }, codegen_1.nil);\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=required.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst error = {\n    message({ keyword, schemaCode }) {\n        const comp = keyword === \"maxProperties\" ? \"more\" : \"fewer\";\n        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} properties`;\n    },\n    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,\n};\nconst def = {\n    keyword: [\"maxProperties\", \"minProperties\"],\n    type: \"object\",\n    schemaType: \"number\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { keyword, data, schemaCode } = cxt;\n        const op = keyword === \"maxProperties\" ? codegen_1.operators.GT : codegen_1.operators.LT;\n        cxt.fail$data((0, codegen_1._) `Object.keys(${data}).length ${op} ${schemaCode}`);\n    },\n};\nexports.default = def;\n//# sourceMappingURL=limitProperties.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst resolve_1 = require(\"./resolve\");\nclass MissingRefError extends Error {\n    constructor(resolver, baseId, ref, msg) {\n        super(msg || `can't resolve reference ${ref} from id ${baseId}`);\n        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);\n        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));\n    }\n}\nexports.default = MissingRefError;\n//# sourceMappingURL=ref_error.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst dependencies_1 = require(\"./dependencies\");\nconst def = {\n    keyword: \"dependentSchemas\",\n    type: \"object\",\n    schemaType: \"object\",\n    code: (cxt) => (0, dependencies_1.validateSchemaDeps)(cxt),\n};\nexports.default = def;\n//# sourceMappingURL=dependentSchemas.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst types_1 = require(\"../discriminator/types\");\nconst compile_1 = require(\"../../compile\");\nconst ref_error_1 = require(\"../../compile/ref_error\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag\n        ? `tag \"${tagName}\" must be string`\n        : `value of tag \"${tagName}\" must be in oneOf`,\n    params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._) `{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`,\n};\nconst def = {\n    keyword: \"discriminator\",\n    type: \"object\",\n    schemaType: \"object\",\n    error,\n    code(cxt) {\n        const { gen, data, schema, parentSchema, it } = cxt;\n        const { oneOf } = parentSchema;\n        if (!it.opts.discriminator) {\n            throw new Error(\"discriminator: requires discriminator option\");\n        }\n        const tagName = schema.propertyName;\n        if (typeof tagName != \"string\")\n            throw new Error(\"discriminator: requires propertyName\");\n        if (schema.mapping)\n            throw new Error(\"discriminator: mapping is not supported\");\n        if (!oneOf)\n            throw new Error(\"discriminator: requires oneOf keyword\");\n        const valid = gen.let(\"valid\", false);\n        const tag = gen.const(\"tag\", (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(tagName)}`);\n        gen.if((0, codegen_1._) `typeof ${tag} == \"string\"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));\n        cxt.ok(valid);\n        function validateMapping() {\n            const mapping = getMapping();\n            gen.if(false);\n            for (const tagValue in mapping) {\n                gen.elseIf((0, codegen_1._) `${tag} === ${tagValue}`);\n                gen.assign(valid, applyTagSchema(mapping[tagValue]));\n            }\n            gen.else();\n            cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });\n            gen.endIf();\n        }\n        function applyTagSchema(schemaProp) {\n            const _valid = gen.name(\"valid\");\n            const schCxt = cxt.subschema({ keyword: \"oneOf\", schemaProp }, _valid);\n            cxt.mergeEvaluated(schCxt, codegen_1.Name);\n            return _valid;\n        }\n        function getMapping() {\n            var _a;\n            const oneOfMapping = {};\n            const topRequired = hasRequired(parentSchema);\n            let tagRequired = true;\n            for (let i = 0; i < oneOf.length; i++) {\n                let sch = oneOf[i];\n                if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {\n                    const ref = sch.$ref;\n                    sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref);\n                    if (sch instanceof compile_1.SchemaEnv)\n                        sch = sch.schema;\n                    if (sch === undefined)\n                        throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref);\n                }\n                const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];\n                if (typeof propSch != \"object\") {\n                    throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have \"properties/${tagName}\"`);\n                }\n                tagRequired = tagRequired && (topRequired || hasRequired(sch));\n                addMappings(propSch, i);\n            }\n            if (!tagRequired)\n                throw new Error(`discriminator: \"${tagName}\" must be required`);\n            return oneOfMapping;\n            function hasRequired({ required }) {\n                return Array.isArray(required) && required.includes(tagName);\n            }\n            function addMappings(sch, i) {\n                if (sch.const) {\n                    addMapping(sch.const, i);\n                }\n                else if (sch.enum) {\n                    for (const tagValue of sch.enum) {\n                        addMapping(tagValue, i);\n                    }\n                }\n                else {\n                    throw new Error(`discriminator: \"properties/${tagName}\" must have \"const\" or \"enum\"`);\n                }\n            }\n            function addMapping(tagValue, i) {\n                if (typeof tagValue != \"string\" || tagValue in oneOfMapping) {\n                    throw new Error(`discriminator: \"${tagName}\" values must be unique strings`);\n                }\n                oneOfMapping[tagValue] = i;\n            }\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst names_1 = require(\"../../compile/names\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: \"must NOT have additional properties\",\n    params: ({ params }) => (0, codegen_1._) `{additionalProperty: ${params.additionalProperty}}`,\n};\nconst def = {\n    keyword: \"additionalProperties\",\n    type: [\"object\"],\n    schemaType: [\"boolean\", \"object\"],\n    allowUndefined: true,\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, schema, parentSchema, data, errsCount, it } = cxt;\n        /* istanbul ignore if */\n        if (!errsCount)\n            throw new Error(\"ajv implementation error\");\n        const { allErrors, opts } = it;\n        it.props = true;\n        if (opts.removeAdditional !== \"all\" && (0, util_1.alwaysValidSchema)(it, schema))\n            return;\n        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);\n        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);\n        checkAdditionalProperties();\n        cxt.ok((0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);\n        function checkAdditionalProperties() {\n            gen.forIn(\"key\", data, (key) => {\n                if (!props.length && !patProps.length)\n                    additionalPropertyCode(key);\n                else\n                    gen.if(isAdditional(key), () => additionalPropertyCode(key));\n            });\n        }\n        function isAdditional(key) {\n            let definedProp;\n            if (props.length > 8) {\n                // TODO maybe an option instead of hard-coded 8?\n                const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, \"properties\");\n                definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);\n            }\n            else if (props.length) {\n                definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._) `${key} === ${p}`));\n            }\n            else {\n                definedProp = codegen_1.nil;\n            }\n            if (patProps.length) {\n                definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._) `${(0, code_1.usePattern)(cxt, p)}.test(${key})`));\n            }\n            return (0, codegen_1.not)(definedProp);\n        }\n        function deleteAdditional(key) {\n            gen.code((0, codegen_1._) `delete ${data}[${key}]`);\n        }\n        function additionalPropertyCode(key) {\n            if (opts.removeAdditional === \"all\" || (opts.removeAdditional && schema === false)) {\n                deleteAdditional(key);\n                return;\n            }\n            if (schema === false) {\n                cxt.setParams({ additionalProperty: key });\n                cxt.error();\n                if (!allErrors)\n                    gen.break();\n                return;\n            }\n            if (typeof schema == \"object\" && !(0, util_1.alwaysValidSchema)(it, schema)) {\n                const valid = gen.name(\"valid\");\n                if (opts.removeAdditional === \"failing\") {\n                    applyAdditionalSchema(key, valid, false);\n                    gen.if((0, codegen_1.not)(valid), () => {\n                        cxt.reset();\n                        deleteAdditional(key);\n                    });\n                }\n                else {\n                    applyAdditionalSchema(key, valid);\n                    if (!allErrors)\n                        gen.if((0, codegen_1.not)(valid), () => gen.break());\n                }\n            }\n        }\n        function applyAdditionalSchema(key, valid, errors) {\n            const subschema = {\n                keyword: \"additionalProperties\",\n                dataProp: key,\n                dataPropType: util_1.Type.Str,\n            };\n            if (errors === false) {\n                Object.assign(subschema, {\n                    compositeRule: true,\n                    createErrors: false,\n                    allErrors: false,\n                });\n            }\n            cxt.subschema(subschema, valid);\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=additionalProperties.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst validate_1 = require(\"../../compile/validate\");\nconst code_1 = require(\"../code\");\nconst util_1 = require(\"../../compile/util\");\nconst additionalProperties_1 = require(\"./additionalProperties\");\nconst def = {\n    keyword: \"properties\",\n    type: \"object\",\n    schemaType: \"object\",\n    code(cxt) {\n        const { gen, schema, parentSchema, data, it } = cxt;\n        if (it.opts.removeAdditional === \"all\" && parentSchema.additionalProperties === undefined) {\n            additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, \"additionalProperties\"));\n        }\n        const allProps = (0, code_1.allSchemaProperties)(schema);\n        for (const prop of allProps) {\n            it.definedProperties.add(prop);\n        }\n        if (it.opts.unevaluated && allProps.length && it.props !== true) {\n            it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);\n        }\n        const properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));\n        if (properties.length === 0)\n            return;\n        const valid = gen.name(\"valid\");\n        for (const prop of properties) {\n            if (hasDefault(prop)) {\n                applyPropertySchema(prop);\n            }\n            else {\n                gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));\n                applyPropertySchema(prop);\n                if (!it.allErrors)\n                    gen.else().var(valid, true);\n                gen.endIf();\n            }\n            cxt.it.definedProperties.add(prop);\n            cxt.ok(valid);\n        }\n        function hasDefault(prop) {\n            return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined;\n        }\n        function applyPropertySchema(prop) {\n            cxt.subschema({\n                keyword: \"properties\",\n                schemaProp: prop,\n                dataProp: prop,\n            }, valid);\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=properties.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;\n// eslint-disable-next-line @typescript-eslint/no-extraneous-class\nclass _CodeOrName {\n}\nexports._CodeOrName = _CodeOrName;\nexports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;\nclass Name extends _CodeOrName {\n    constructor(s) {\n        super();\n        if (!exports.IDENTIFIER.test(s))\n            throw new Error(\"CodeGen: name must be a valid identifier\");\n        this.str = s;\n    }\n    toString() {\n        return this.str;\n    }\n    emptyStr() {\n        return false;\n    }\n    get names() {\n        return { [this.str]: 1 };\n    }\n}\nexports.Name = Name;\nclass _Code extends _CodeOrName {\n    constructor(code) {\n        super();\n        this._items = typeof code === \"string\" ? [code] : code;\n    }\n    toString() {\n        return this.str;\n    }\n    emptyStr() {\n        if (this._items.length > 1)\n            return false;\n        const item = this._items[0];\n        return item === \"\" || item === '\"\"';\n    }\n    get str() {\n        var _a;\n        return ((_a = this._str) !== null && _a !== void 0 ? _a : (this._str = this._items.reduce((s, c) => `${s}${c}`, \"\")));\n    }\n    get names() {\n        var _a;\n        return ((_a = this._names) !== null && _a !== void 0 ? _a : (this._names = this._items.reduce((names, c) => {\n            if (c instanceof Name)\n                names[c.str] = (names[c.str] || 0) + 1;\n            return names;\n        }, {})));\n    }\n}\nexports._Code = _Code;\nexports.nil = new _Code(\"\");\nfunction _(strs, ...args) {\n    const code = [strs[0]];\n    let i = 0;\n    while (i < args.length) {\n        addCodeArg(code, args[i]);\n        code.push(strs[++i]);\n    }\n    return new _Code(code);\n}\nexports._ = _;\nconst plus = new _Code(\"+\");\nfunction str(strs, ...args) {\n    const expr = [safeStringify(strs[0])];\n    let i = 0;\n    while (i < args.length) {\n        expr.push(plus);\n        addCodeArg(expr, args[i]);\n        expr.push(plus, safeStringify(strs[++i]));\n    }\n    optimize(expr);\n    return new _Code(expr);\n}\nexports.str = str;\nfunction addCodeArg(code, arg) {\n    if (arg instanceof _Code)\n        code.push(...arg._items);\n    else if (arg instanceof Name)\n        code.push(arg);\n    else\n        code.push(interpolate(arg));\n}\nexports.addCodeArg = addCodeArg;\nfunction optimize(expr) {\n    let i = 1;\n    while (i < expr.length - 1) {\n        if (expr[i] === plus) {\n            const res = mergeExprItems(expr[i - 1], expr[i + 1]);\n            if (res !== undefined) {\n                expr.splice(i - 1, 3, res);\n                continue;\n            }\n            expr[i++] = \"+\";\n        }\n        i++;\n    }\n}\nfunction mergeExprItems(a, b) {\n    if (b === '\"\"')\n        return a;\n    if (a === '\"\"')\n        return b;\n    if (typeof a == \"string\") {\n        if (b instanceof Name || a[a.length - 1] !== '\"')\n            return;\n        if (typeof b != \"string\")\n            return `${a.slice(0, -1)}${b}\"`;\n        if (b[0] === '\"')\n            return a.slice(0, -1) + b.slice(1);\n        return;\n    }\n    if (typeof b == \"string\" && b[0] === '\"' && !(a instanceof Name))\n        return `\"${a}${b.slice(1)}`;\n    return;\n}\nfunction strConcat(c1, c2) {\n    return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str `${c1}${c2}`;\n}\nexports.strConcat = strConcat;\n// TODO do not allow arrays here\nfunction interpolate(x) {\n    return typeof x == \"number\" || typeof x == \"boolean\" || x === null\n        ? x\n        : safeStringify(Array.isArray(x) ? x.join(\",\") : x);\n}\nfunction stringify(x) {\n    return new _Code(safeStringify(x));\n}\nexports.stringify = stringify;\nfunction safeStringify(x) {\n    return JSON.stringify(x)\n        .replace(/\\u2028/g, \"\\\\u2028\")\n        .replace(/\\u2029/g, \"\\\\u2029\");\n}\nexports.safeStringify = safeStringify;\nfunction getProperty(key) {\n    return typeof key == \"string\" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _ `[${key}]`;\n}\nexports.getProperty = getProperty;\n//Does best effort to format the name properly\nfunction getEsmExportName(key) {\n    if (typeof key == \"string\" && exports.IDENTIFIER.test(key)) {\n        return new _Code(`${key}`);\n    }\n    throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);\n}\nexports.getEsmExportName = getEsmExportName;\nfunction regexpCode(rx) {\n    return new _Code(rx.toString());\n}\nexports.regexpCode = regexpCode;\n//# sourceMappingURL=code.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"./codegen\");\nconst names = {\n    // validation function arguments\n    data: new codegen_1.Name(\"data\"), // data passed to validation function\n    // args passed from referencing schema\n    valCxt: new codegen_1.Name(\"valCxt\"), // validation/data context - should not be used directly, it is destructured to the names below\n    instancePath: new codegen_1.Name(\"instancePath\"),\n    parentData: new codegen_1.Name(\"parentData\"),\n    parentDataProperty: new codegen_1.Name(\"parentDataProperty\"),\n    rootData: new codegen_1.Name(\"rootData\"), // root data - same as the data passed to the first/top validation function\n    dynamicAnchors: new codegen_1.Name(\"dynamicAnchors\"), // used to support recursiveRef and dynamicRef\n    // function scoped variables\n    vErrors: new codegen_1.Name(\"vErrors\"), // null or array of validation errors\n    errors: new codegen_1.Name(\"errors\"), // counter of validation errors\n    this: new codegen_1.Name(\"this\"),\n    // \"globals\"\n    self: new codegen_1.Name(\"self\"),\n    scope: new codegen_1.Name(\"scope\"),\n    // JTD serialize/parse name for JSON string and position\n    json: new codegen_1.Name(\"json\"),\n    jsonPos: new codegen_1.Name(\"jsonPos\"),\n    jsonLen: new codegen_1.Name(\"jsonLen\"),\n    jsonPart: new codegen_1.Name(\"jsonPart\"),\n};\nexports.default = names;\n//# sourceMappingURL=names.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst util_2 = require(\"../../compile/util\");\nconst def = {\n    keyword: \"patternProperties\",\n    type: \"object\",\n    schemaType: \"object\",\n    code(cxt) {\n        const { gen, schema, data, parentSchema, it } = cxt;\n        const { opts } = it;\n        const patterns = (0, code_1.allSchemaProperties)(schema);\n        const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));\n        if (patterns.length === 0 ||\n            (alwaysValidPatterns.length === patterns.length &&\n                (!it.opts.unevaluated || it.props === true))) {\n            return;\n        }\n        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;\n        const valid = gen.name(\"valid\");\n        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {\n            it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);\n        }\n        const { props } = it;\n        validatePatternProperties();\n        function validatePatternProperties() {\n            for (const pat of patterns) {\n                if (checkProperties)\n                    checkMatchingProperties(pat);\n                if (it.allErrors) {\n                    validateProperties(pat);\n                }\n                else {\n                    gen.var(valid, true); // TODO var\n                    validateProperties(pat);\n                    gen.if(valid);\n                }\n            }\n        }\n        function checkMatchingProperties(pat) {\n            for (const prop in checkProperties) {\n                if (new RegExp(pat).test(prop)) {\n                    (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);\n                }\n            }\n        }\n        function validateProperties(pat) {\n            gen.forIn(\"key\", data, (key) => {\n                gen.if((0, codegen_1._) `${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {\n                    const alwaysValid = alwaysValidPatterns.includes(pat);\n                    if (!alwaysValid) {\n                        cxt.subschema({\n                            keyword: \"patternProperties\",\n                            schemaProp: pat,\n                            dataProp: key,\n                            dataPropType: util_2.Type.Str,\n                        }, valid);\n                    }\n                    if (it.opts.unevaluated && props !== true) {\n                        gen.assign((0, codegen_1._) `${props}[${key}]`, true);\n                    }\n                    else if (!alwaysValid && !it.allErrors) {\n                        // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)\n                        // or if all properties were evaluated (props === true)\n                        gen.if((0, codegen_1.not)(valid), () => gen.break());\n                    }\n                });\n            });\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=patternProperties.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;\nconst codegen_1 = require(\"./codegen\");\nconst util_1 = require(\"./util\");\nconst names_1 = require(\"./names\");\nexports.keywordError = {\n    message: ({ keyword }) => (0, codegen_1.str) `must pass \"${keyword}\" keyword validation`,\n};\nexports.keyword$DataError = {\n    message: ({ keyword, schemaType }) => schemaType\n        ? (0, codegen_1.str) `\"${keyword}\" keyword must be ${schemaType} ($data)`\n        : (0, codegen_1.str) `\"${keyword}\" keyword is invalid ($data)`,\n};\nfunction reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {\n    const { it } = cxt;\n    const { gen, compositeRule, allErrors } = it;\n    const errObj = errorObjectCode(cxt, error, errorPaths);\n    if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : (compositeRule || allErrors)) {\n        addError(gen, errObj);\n    }\n    else {\n        returnErrors(it, (0, codegen_1._) `[${errObj}]`);\n    }\n}\nexports.reportError = reportError;\nfunction reportExtraError(cxt, error = exports.keywordError, errorPaths) {\n    const { it } = cxt;\n    const { gen, compositeRule, allErrors } = it;\n    const errObj = errorObjectCode(cxt, error, errorPaths);\n    addError(gen, errObj);\n    if (!(compositeRule || allErrors)) {\n        returnErrors(it, names_1.default.vErrors);\n    }\n}\nexports.reportExtraError = reportExtraError;\nfunction resetErrorsCount(gen, errsCount) {\n    gen.assign(names_1.default.errors, errsCount);\n    gen.if((0, codegen_1._) `${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._) `${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));\n}\nexports.resetErrorsCount = resetErrorsCount;\nfunction extendErrors({ gen, keyword, schemaValue, data, errsCount, it, }) {\n    /* istanbul ignore if */\n    if (errsCount === undefined)\n        throw new Error(\"ajv implementation error\");\n    const err = gen.name(\"err\");\n    gen.forRange(\"i\", errsCount, names_1.default.errors, (i) => {\n        gen.const(err, (0, codegen_1._) `${names_1.default.vErrors}[${i}]`);\n        gen.if((0, codegen_1._) `${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._) `${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));\n        gen.assign((0, codegen_1._) `${err}.schemaPath`, (0, codegen_1.str) `${it.errSchemaPath}/${keyword}`);\n        if (it.opts.verbose) {\n            gen.assign((0, codegen_1._) `${err}.schema`, schemaValue);\n            gen.assign((0, codegen_1._) `${err}.data`, data);\n        }\n    });\n}\nexports.extendErrors = extendErrors;\nfunction addError(gen, errObj) {\n    const err = gen.const(\"err\", errObj);\n    gen.if((0, codegen_1._) `${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._) `[${err}]`), (0, codegen_1._) `${names_1.default.vErrors}.push(${err})`);\n    gen.code((0, codegen_1._) `${names_1.default.errors}++`);\n}\nfunction returnErrors(it, errs) {\n    const { gen, validateName, schemaEnv } = it;\n    if (schemaEnv.$async) {\n        gen.throw((0, codegen_1._) `new ${it.ValidationError}(${errs})`);\n    }\n    else {\n        gen.assign((0, codegen_1._) `${validateName}.errors`, errs);\n        gen.return(false);\n    }\n}\nconst E = {\n    keyword: new codegen_1.Name(\"keyword\"),\n    schemaPath: new codegen_1.Name(\"schemaPath\"), // also used in JTD errors\n    params: new codegen_1.Name(\"params\"),\n    propertyName: new codegen_1.Name(\"propertyName\"),\n    message: new codegen_1.Name(\"message\"),\n    schema: new codegen_1.Name(\"schema\"),\n    parentSchema: new codegen_1.Name(\"parentSchema\"),\n};\nfunction errorObjectCode(cxt, error, errorPaths) {\n    const { createErrors } = cxt.it;\n    if (createErrors === false)\n        return (0, codegen_1._) `{}`;\n    return errorObject(cxt, error, errorPaths);\n}\nfunction errorObject(cxt, error, errorPaths = {}) {\n    const { gen, it } = cxt;\n    const keyValues = [\n        errorInstancePath(it, errorPaths),\n        errorSchemaPath(cxt, errorPaths),\n    ];\n    extraErrorProps(cxt, error, keyValues);\n    return gen.object(...keyValues);\n}\nfunction errorInstancePath({ errorPath }, { instancePath }) {\n    const instPath = instancePath\n        ? (0, codegen_1.str) `${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}`\n        : errorPath;\n    return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];\n}\nfunction errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {\n    let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str) `${errSchemaPath}/${keyword}`;\n    if (schemaPath) {\n        schPath = (0, codegen_1.str) `${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;\n    }\n    return [E.schemaPath, schPath];\n}\nfunction extraErrorProps(cxt, { params, message }, keyValues) {\n    const { keyword, data, schemaValue, it } = cxt;\n    const { opts, propertyName, topSchemaRef, schemaPath } = it;\n    keyValues.push([E.keyword, keyword], [E.params, typeof params == \"function\" ? params(cxt) : params || (0, codegen_1._) `{}`]);\n    if (opts.messages) {\n        keyValues.push([E.message, typeof message == \"function\" ? message(cxt) : message]);\n    }\n    if (opts.verbose) {\n        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._) `${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);\n    }\n    if (propertyName)\n        keyValues.push([E.propertyName, propertyName]);\n}\n//# sourceMappingURL=errors.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// https://mathiasbynens.be/notes/javascript-encoding\n// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode\nfunction ucs2length(str) {\n    const len = str.length;\n    let length = 0;\n    let pos = 0;\n    let value;\n    while (pos < len) {\n        length++;\n        value = str.charCodeAt(pos++);\n        if (value >= 0xd800 && value <= 0xdbff && pos < len) {\n            // high surrogate, and there is a next character\n            value = str.charCodeAt(pos);\n            if ((value & 0xfc00) === 0xdc00)\n                pos++; // low surrogate\n        }\n    }\n    return length;\n}\nexports.default = ucs2length;\nucs2length.code = 'require(\"ajv/dist/runtime/ucs2length\").default';\n//# sourceMappingURL=ucs2length.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst uri = require(\"fast-uri\");\nuri.code = 'require(\"ajv/dist/runtime/uri\").default';\nexports.default = uri;\n//# sourceMappingURL=uri.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst additionalItems_1 = require(\"./additionalItems\");\nconst prefixItems_1 = require(\"./prefixItems\");\nconst items_1 = require(\"./items\");\nconst items2020_1 = require(\"./items2020\");\nconst contains_1 = require(\"./contains\");\nconst dependencies_1 = require(\"./dependencies\");\nconst propertyNames_1 = require(\"./propertyNames\");\nconst additionalProperties_1 = require(\"./additionalProperties\");\nconst properties_1 = require(\"./properties\");\nconst patternProperties_1 = require(\"./patternProperties\");\nconst not_1 = require(\"./not\");\nconst anyOf_1 = require(\"./anyOf\");\nconst oneOf_1 = require(\"./oneOf\");\nconst allOf_1 = require(\"./allOf\");\nconst if_1 = require(\"./if\");\nconst thenElse_1 = require(\"./thenElse\");\nfunction getApplicator(draft2020 = false) {\n    const applicator = [\n        // any\n        not_1.default,\n        anyOf_1.default,\n        oneOf_1.default,\n        allOf_1.default,\n        if_1.default,\n        thenElse_1.default,\n        // object\n        propertyNames_1.default,\n        additionalProperties_1.default,\n        dependencies_1.default,\n        properties_1.default,\n        patternProperties_1.default,\n    ];\n    // array\n    if (draft2020)\n        applicator.push(prefixItems_1.default, items2020_1.default);\n    else\n        applicator.push(additionalItems_1.default, items_1.default);\n    applicator.push(contains_1.default);\n    return applicator;\n}\nexports.default = getApplicator;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;\nconst code_1 = require(\"./code\");\nclass ValueError extends Error {\n    constructor(name) {\n        super(`CodeGen: \"code\" for ${name} not defined`);\n        this.value = name.value;\n    }\n}\nvar UsedValueState;\n(function (UsedValueState) {\n    UsedValueState[UsedValueState[\"Started\"] = 0] = \"Started\";\n    UsedValueState[UsedValueState[\"Completed\"] = 1] = \"Completed\";\n})(UsedValueState || (exports.UsedValueState = UsedValueState = {}));\nexports.varKinds = {\n    const: new code_1.Name(\"const\"),\n    let: new code_1.Name(\"let\"),\n    var: new code_1.Name(\"var\"),\n};\nclass Scope {\n    constructor({ prefixes, parent } = {}) {\n        this._names = {};\n        this._prefixes = prefixes;\n        this._parent = parent;\n    }\n    toName(nameOrPrefix) {\n        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);\n    }\n    name(prefix) {\n        return new code_1.Name(this._newName(prefix));\n    }\n    _newName(prefix) {\n        const ng = this._names[prefix] || this._nameGroup(prefix);\n        return `${prefix}${ng.index++}`;\n    }\n    _nameGroup(prefix) {\n        var _a, _b;\n        if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || (this._prefixes && !this._prefixes.has(prefix))) {\n            throw new Error(`CodeGen: prefix \"${prefix}\" is not allowed in this scope`);\n        }\n        return (this._names[prefix] = { prefix, index: 0 });\n    }\n}\nexports.Scope = Scope;\nclass ValueScopeName extends code_1.Name {\n    constructor(prefix, nameStr) {\n        super(nameStr);\n        this.prefix = prefix;\n    }\n    setValue(value, { property, itemIndex }) {\n        this.value = value;\n        this.scopePath = (0, code_1._) `.${new code_1.Name(property)}[${itemIndex}]`;\n    }\n}\nexports.ValueScopeName = ValueScopeName;\nconst line = (0, code_1._) `\\n`;\nclass ValueScope extends Scope {\n    constructor(opts) {\n        super(opts);\n        this._values = {};\n        this._scope = opts.scope;\n        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };\n    }\n    get() {\n        return this._scope;\n    }\n    name(prefix) {\n        return new ValueScopeName(prefix, this._newName(prefix));\n    }\n    value(nameOrPrefix, value) {\n        var _a;\n        if (value.ref === undefined)\n            throw new Error(\"CodeGen: ref must be passed in value\");\n        const name = this.toName(nameOrPrefix);\n        const { prefix } = name;\n        const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;\n        let vs = this._values[prefix];\n        if (vs) {\n            const _name = vs.get(valueKey);\n            if (_name)\n                return _name;\n        }\n        else {\n            vs = this._values[prefix] = new Map();\n        }\n        vs.set(valueKey, name);\n        const s = this._scope[prefix] || (this._scope[prefix] = []);\n        const itemIndex = s.length;\n        s[itemIndex] = value.ref;\n        name.setValue(value, { property: prefix, itemIndex });\n        return name;\n    }\n    getValue(prefix, keyOrRef) {\n        const vs = this._values[prefix];\n        if (!vs)\n            return;\n        return vs.get(keyOrRef);\n    }\n    scopeRefs(scopeName, values = this._values) {\n        return this._reduceValues(values, (name) => {\n            if (name.scopePath === undefined)\n                throw new Error(`CodeGen: name \"${name}\" has no value`);\n            return (0, code_1._) `${scopeName}${name.scopePath}`;\n        });\n    }\n    scopeCode(values = this._values, usedValues, getCode) {\n        return this._reduceValues(values, (name) => {\n            if (name.value === undefined)\n                throw new Error(`CodeGen: name \"${name}\" has no value`);\n            return name.value.code;\n        }, usedValues, getCode);\n    }\n    _reduceValues(values, valueCode, usedValues = {}, getCode) {\n        let code = code_1.nil;\n        for (const prefix in values) {\n            const vs = values[prefix];\n            if (!vs)\n                continue;\n            const nameSet = (usedValues[prefix] = usedValues[prefix] || new Map());\n            vs.forEach((name) => {\n                if (nameSet.has(name))\n                    return;\n                nameSet.set(name, UsedValueState.Started);\n                let c = valueCode(name);\n                if (c) {\n                    const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;\n                    code = (0, code_1._) `${code}${def} ${name} = ${c};${this.opts._n}`;\n                }\n                else if ((c = getCode === null || getCode === void 0 ? void 0 : getCode(name))) {\n                    code = (0, code_1._) `${code}${c}${this.opts._n}`;\n                }\n                else {\n                    throw new ValueError(name);\n                }\n                nameSet.set(name, UsedValueState.Completed);\n            });\n        }\n        return code;\n    }\n}\nexports.ValueScope = ValueScope;\n//# sourceMappingURL=scope.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst util_1 = require(\"../../compile/util\");\nconst def = {\n    keyword: \"not\",\n    schemaType: [\"object\", \"boolean\"],\n    trackErrors: true,\n    code(cxt) {\n        const { gen, schema, it } = cxt;\n        if ((0, util_1.alwaysValidSchema)(it, schema)) {\n            cxt.fail();\n            return;\n        }\n        const valid = gen.name(\"valid\");\n        cxt.subschema({\n            keyword: \"not\",\n            compositeRule: true,\n            createErrors: false,\n            allErrors: false,\n        }, valid);\n        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());\n    },\n    error: { message: \"must NOT be valid\" },\n};\nexports.default = def;\n//# sourceMappingURL=not.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst dataType_1 = require(\"../../compile/validate/dataType\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst equal_1 = require(\"../../runtime/equal\");\nconst error = {\n    message: ({ params: { i, j } }) => (0, codegen_1.str) `must NOT have duplicate items (items ## ${j} and ${i} are identical)`,\n    params: ({ params: { i, j } }) => (0, codegen_1._) `{i: ${i}, j: ${j}}`,\n};\nconst def = {\n    keyword: \"uniqueItems\",\n    type: \"array\",\n    schemaType: \"boolean\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;\n        if (!$data && !schema)\n            return;\n        const valid = gen.let(\"valid\");\n        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];\n        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._) `${schemaCode} === false`);\n        cxt.ok(valid);\n        function validateUniqueItems() {\n            const i = gen.let(\"i\", (0, codegen_1._) `${data}.length`);\n            const j = gen.let(\"j\");\n            cxt.setParams({ i, j });\n            gen.assign(valid, true);\n            gen.if((0, codegen_1._) `${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));\n        }\n        function canOptimize() {\n            return itemTypes.length > 0 && !itemTypes.some((t) => t === \"object\" || t === \"array\");\n        }\n        function loopN(i, j) {\n            const item = gen.name(\"item\");\n            const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);\n            const indices = gen.const(\"indices\", (0, codegen_1._) `{}`);\n            gen.for((0, codegen_1._) `;${i}--;`, () => {\n                gen.let(item, (0, codegen_1._) `${data}[${i}]`);\n                gen.if(wrongType, (0, codegen_1._) `continue`);\n                if (itemTypes.length > 1)\n                    gen.if((0, codegen_1._) `typeof ${item} == \"string\"`, (0, codegen_1._) `${item} += \"_\"`);\n                gen\n                    .if((0, codegen_1._) `typeof ${indices}[${item}] == \"number\"`, () => {\n                    gen.assign(j, (0, codegen_1._) `${indices}[${item}]`);\n                    cxt.error();\n                    gen.assign(valid, false).break();\n                })\n                    .code((0, codegen_1._) `${indices}[${item}] = ${i}`);\n            });\n        }\n        function loopN2(i, j) {\n            const eql = (0, util_1.useFunc)(gen, equal_1.default);\n            const outer = gen.name(\"outer\");\n            gen.label(outer).for((0, codegen_1._) `;${i}--;`, () => gen.for((0, codegen_1._) `${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._) `${eql}(${data}[${i}], ${data}[${j}])`, () => {\n                cxt.error();\n                gen.assign(valid, false).break(outer);\n            })));\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=uniqueItems.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst error = {\n    message({ keyword, schemaCode }) {\n        const comp = keyword === \"maxItems\" ? \"more\" : \"fewer\";\n        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} items`;\n    },\n    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,\n};\nconst def = {\n    keyword: [\"maxItems\", \"minItems\"],\n    type: \"array\",\n    schemaType: \"number\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { keyword, data, schemaCode } = cxt;\n        const op = keyword === \"maxItems\" ? codegen_1.operators.GT : codegen_1.operators.LT;\n        cxt.fail$data((0, codegen_1._) `${data}.length ${op} ${schemaCode}`);\n    },\n};\nexports.default = def;\n//# sourceMappingURL=limitItems.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;\nconst boolSchema_1 = require(\"./boolSchema\");\nconst dataType_1 = require(\"./dataType\");\nconst applicability_1 = require(\"./applicability\");\nconst dataType_2 = require(\"./dataType\");\nconst defaults_1 = require(\"./defaults\");\nconst keyword_1 = require(\"./keyword\");\nconst subschema_1 = require(\"./subschema\");\nconst codegen_1 = require(\"../codegen\");\nconst names_1 = require(\"../names\");\nconst resolve_1 = require(\"../resolve\");\nconst util_1 = require(\"../util\");\nconst errors_1 = require(\"../errors\");\n// schema compilation - generates validation function, subschemaCode (below) is used for subschemas\nfunction validateFunctionCode(it) {\n    if (isSchemaObj(it)) {\n        checkKeywords(it);\n        if (schemaCxtHasRules(it)) {\n            topSchemaObjCode(it);\n            return;\n        }\n    }\n    validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));\n}\nexports.validateFunctionCode = validateFunctionCode;\nfunction validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {\n    if (opts.code.es5) {\n        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {\n            gen.code((0, codegen_1._) `\"use strict\"; ${funcSourceUrl(schema, opts)}`);\n            destructureValCxtES5(gen, opts);\n            gen.code(body);\n        });\n    }\n    else {\n        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));\n    }\n}\nfunction destructureValCxt(opts) {\n    return (0, codegen_1._) `{${names_1.default.instancePath}=\"\", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._) `, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;\n}\nfunction destructureValCxtES5(gen, opts) {\n    gen.if(names_1.default.valCxt, () => {\n        gen.var(names_1.default.instancePath, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.instancePath}`);\n        gen.var(names_1.default.parentData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentData}`);\n        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);\n        gen.var(names_1.default.rootData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.rootData}`);\n        if (opts.dynamicRef)\n            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);\n    }, () => {\n        gen.var(names_1.default.instancePath, (0, codegen_1._) `\"\"`);\n        gen.var(names_1.default.parentData, (0, codegen_1._) `undefined`);\n        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `undefined`);\n        gen.var(names_1.default.rootData, names_1.default.data);\n        if (opts.dynamicRef)\n            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `{}`);\n    });\n}\nfunction topSchemaObjCode(it) {\n    const { schema, opts, gen } = it;\n    validateFunction(it, () => {\n        if (opts.$comment && schema.$comment)\n            commentKeyword(it);\n        checkNoDefault(it);\n        gen.let(names_1.default.vErrors, null);\n        gen.let(names_1.default.errors, 0);\n        if (opts.unevaluated)\n            resetEvaluated(it);\n        typeAndKeywords(it);\n        returnResults(it);\n    });\n    return;\n}\nfunction resetEvaluated(it) {\n    // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated\n    const { gen, validateName } = it;\n    it.evaluated = gen.const(\"evaluated\", (0, codegen_1._) `${validateName}.evaluated`);\n    gen.if((0, codegen_1._) `${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._) `${it.evaluated}.props`, (0, codegen_1._) `undefined`));\n    gen.if((0, codegen_1._) `${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._) `${it.evaluated}.items`, (0, codegen_1._) `undefined`));\n}\nfunction funcSourceUrl(schema, opts) {\n    const schId = typeof schema == \"object\" && schema[opts.schemaId];\n    return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._) `/*# sourceURL=${schId} */` : codegen_1.nil;\n}\n// schema compilation - this function is used recursively to generate code for sub-schemas\nfunction subschemaCode(it, valid) {\n    if (isSchemaObj(it)) {\n        checkKeywords(it);\n        if (schemaCxtHasRules(it)) {\n            subSchemaObjCode(it, valid);\n            return;\n        }\n    }\n    (0, boolSchema_1.boolOrEmptySchema)(it, valid);\n}\nfunction schemaCxtHasRules({ schema, self }) {\n    if (typeof schema == \"boolean\")\n        return !schema;\n    for (const key in schema)\n        if (self.RULES.all[key])\n            return true;\n    return false;\n}\nfunction isSchemaObj(it) {\n    return typeof it.schema != \"boolean\";\n}\nfunction subSchemaObjCode(it, valid) {\n    const { schema, gen, opts } = it;\n    if (opts.$comment && schema.$comment)\n        commentKeyword(it);\n    updateContext(it);\n    checkAsyncSchema(it);\n    const errsCount = gen.const(\"_errs\", names_1.default.errors);\n    typeAndKeywords(it, errsCount);\n    // TODO var\n    gen.var(valid, (0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);\n}\nfunction checkKeywords(it) {\n    (0, util_1.checkUnknownRules)(it);\n    checkRefsAndKeywords(it);\n}\nfunction typeAndKeywords(it, errsCount) {\n    if (it.opts.jtd)\n        return schemaKeywords(it, [], false, errsCount);\n    const types = (0, dataType_1.getSchemaTypes)(it.schema);\n    const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);\n    schemaKeywords(it, types, !checkedTypes, errsCount);\n}\nfunction checkRefsAndKeywords(it) {\n    const { schema, errSchemaPath, opts, self } = it;\n    if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) {\n        self.logger.warn(`$ref: keywords ignored in schema at path \"${errSchemaPath}\"`);\n    }\n}\nfunction checkNoDefault(it) {\n    const { schema, opts } = it;\n    if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {\n        (0, util_1.checkStrictMode)(it, \"default is ignored in the schema root\");\n    }\n}\nfunction updateContext(it) {\n    const schId = it.schema[it.opts.schemaId];\n    if (schId)\n        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);\n}\nfunction checkAsyncSchema(it) {\n    if (it.schema.$async && !it.schemaEnv.$async)\n        throw new Error(\"async schema in sync schema\");\n}\nfunction commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {\n    const msg = schema.$comment;\n    if (opts.$comment === true) {\n        gen.code((0, codegen_1._) `${names_1.default.self}.logger.log(${msg})`);\n    }\n    else if (typeof opts.$comment == \"function\") {\n        const schemaPath = (0, codegen_1.str) `${errSchemaPath}/$comment`;\n        const rootName = gen.scopeValue(\"root\", { ref: schemaEnv.root });\n        gen.code((0, codegen_1._) `${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);\n    }\n}\nfunction returnResults(it) {\n    const { gen, schemaEnv, validateName, ValidationError, opts } = it;\n    if (schemaEnv.$async) {\n        // TODO assign unevaluated\n        gen.if((0, codegen_1._) `${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._) `new ${ValidationError}(${names_1.default.vErrors})`));\n    }\n    else {\n        gen.assign((0, codegen_1._) `${validateName}.errors`, names_1.default.vErrors);\n        if (opts.unevaluated)\n            assignEvaluated(it);\n        gen.return((0, codegen_1._) `${names_1.default.errors} === 0`);\n    }\n}\nfunction assignEvaluated({ gen, evaluated, props, items }) {\n    if (props instanceof codegen_1.Name)\n        gen.assign((0, codegen_1._) `${evaluated}.props`, props);\n    if (items instanceof codegen_1.Name)\n        gen.assign((0, codegen_1._) `${evaluated}.items`, items);\n}\nfunction schemaKeywords(it, types, typeErrors, errsCount) {\n    const { gen, schema, data, allErrors, opts, self } = it;\n    const { RULES } = self;\n    if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {\n        gen.block(() => keywordCode(it, \"$ref\", RULES.all.$ref.definition)); // TODO typecast\n        return;\n    }\n    if (!opts.jtd)\n        checkStrictTypes(it, types);\n    gen.block(() => {\n        for (const group of RULES.rules)\n            groupKeywords(group);\n        groupKeywords(RULES.post);\n    });\n    function groupKeywords(group) {\n        if (!(0, applicability_1.shouldUseGroup)(schema, group))\n            return;\n        if (group.type) {\n            gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));\n            iterateKeywords(it, group);\n            if (types.length === 1 && types[0] === group.type && typeErrors) {\n                gen.else();\n                (0, dataType_2.reportTypeError)(it);\n            }\n            gen.endIf();\n        }\n        else {\n            iterateKeywords(it, group);\n        }\n        // TODO make it \"ok\" call?\n        if (!allErrors)\n            gen.if((0, codegen_1._) `${names_1.default.errors} === ${errsCount || 0}`);\n    }\n}\nfunction iterateKeywords(it, group) {\n    const { gen, schema, opts: { useDefaults }, } = it;\n    if (useDefaults)\n        (0, defaults_1.assignDefaults)(it, group.type);\n    gen.block(() => {\n        for (const rule of group.rules) {\n            if ((0, applicability_1.shouldUseRule)(schema, rule)) {\n                keywordCode(it, rule.keyword, rule.definition, group.type);\n            }\n        }\n    });\n}\nfunction checkStrictTypes(it, types) {\n    if (it.schemaEnv.meta || !it.opts.strictTypes)\n        return;\n    checkContextTypes(it, types);\n    if (!it.opts.allowUnionTypes)\n        checkMultipleTypes(it, types);\n    checkKeywordTypes(it, it.dataTypes);\n}\nfunction checkContextTypes(it, types) {\n    if (!types.length)\n        return;\n    if (!it.dataTypes.length) {\n        it.dataTypes = types;\n        return;\n    }\n    types.forEach((t) => {\n        if (!includesType(it.dataTypes, t)) {\n            strictTypesError(it, `type \"${t}\" not allowed by context \"${it.dataTypes.join(\",\")}\"`);\n        }\n    });\n    narrowSchemaTypes(it, types);\n}\nfunction checkMultipleTypes(it, ts) {\n    if (ts.length > 1 && !(ts.length === 2 && ts.includes(\"null\"))) {\n        strictTypesError(it, \"use allowUnionTypes to allow union type keyword\");\n    }\n}\nfunction checkKeywordTypes(it, ts) {\n    const rules = it.self.RULES.all;\n    for (const keyword in rules) {\n        const rule = rules[keyword];\n        if (typeof rule == \"object\" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {\n            const { type } = rule.definition;\n            if (type.length && !type.some((t) => hasApplicableType(ts, t))) {\n                strictTypesError(it, `missing type \"${type.join(\",\")}\" for keyword \"${keyword}\"`);\n            }\n        }\n    }\n}\nfunction hasApplicableType(schTs, kwdT) {\n    return schTs.includes(kwdT) || (kwdT === \"number\" && schTs.includes(\"integer\"));\n}\nfunction includesType(ts, t) {\n    return ts.includes(t) || (t === \"integer\" && ts.includes(\"number\"));\n}\nfunction narrowSchemaTypes(it, withTypes) {\n    const ts = [];\n    for (const t of it.dataTypes) {\n        if (includesType(withTypes, t))\n            ts.push(t);\n        else if (withTypes.includes(\"integer\") && t === \"number\")\n            ts.push(\"integer\");\n    }\n    it.dataTypes = ts;\n}\nfunction strictTypesError(it, msg) {\n    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n    msg += ` at \"${schemaPath}\" (strictTypes)`;\n    (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);\n}\nclass KeywordCxt {\n    constructor(it, def, keyword) {\n        (0, keyword_1.validateKeywordUsage)(it, def, keyword);\n        this.gen = it.gen;\n        this.allErrors = it.allErrors;\n        this.keyword = keyword;\n        this.data = it.data;\n        this.schema = it.schema[keyword];\n        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;\n        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);\n        this.schemaType = def.schemaType;\n        this.parentSchema = it.schema;\n        this.params = {};\n        this.it = it;\n        this.def = def;\n        if (this.$data) {\n            this.schemaCode = it.gen.const(\"vSchema\", getData(this.$data, it));\n        }\n        else {\n            this.schemaCode = this.schemaValue;\n            if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {\n                throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);\n            }\n        }\n        if (\"code\" in def ? def.trackErrors : def.errors !== false) {\n            this.errsCount = it.gen.const(\"_errs\", names_1.default.errors);\n        }\n    }\n    result(condition, successAction, failAction) {\n        this.failResult((0, codegen_1.not)(condition), successAction, failAction);\n    }\n    failResult(condition, successAction, failAction) {\n        this.gen.if(condition);\n        if (failAction)\n            failAction();\n        else\n            this.error();\n        if (successAction) {\n            this.gen.else();\n            successAction();\n            if (this.allErrors)\n                this.gen.endIf();\n        }\n        else {\n            if (this.allErrors)\n                this.gen.endIf();\n            else\n                this.gen.else();\n        }\n    }\n    pass(condition, failAction) {\n        this.failResult((0, codegen_1.not)(condition), undefined, failAction);\n    }\n    fail(condition) {\n        if (condition === undefined) {\n            this.error();\n            if (!this.allErrors)\n                this.gen.if(false); // this branch will be removed by gen.optimize\n            return;\n        }\n        this.gen.if(condition);\n        this.error();\n        if (this.allErrors)\n            this.gen.endIf();\n        else\n            this.gen.else();\n    }\n    fail$data(condition) {\n        if (!this.$data)\n            return this.fail(condition);\n        const { schemaCode } = this;\n        this.fail((0, codegen_1._) `${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);\n    }\n    error(append, errorParams, errorPaths) {\n        if (errorParams) {\n            this.setParams(errorParams);\n            this._error(append, errorPaths);\n            this.setParams({});\n            return;\n        }\n        this._error(append, errorPaths);\n    }\n    _error(append, errorPaths) {\n        ;\n        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);\n    }\n    $dataError() {\n        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);\n    }\n    reset() {\n        if (this.errsCount === undefined)\n            throw new Error('add \"trackErrors\" to keyword definition');\n        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);\n    }\n    ok(cond) {\n        if (!this.allErrors)\n            this.gen.if(cond);\n    }\n    setParams(obj, assign) {\n        if (assign)\n            Object.assign(this.params, obj);\n        else\n            this.params = obj;\n    }\n    block$data(valid, codeBlock, $dataValid = codegen_1.nil) {\n        this.gen.block(() => {\n            this.check$data(valid, $dataValid);\n            codeBlock();\n        });\n    }\n    check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {\n        if (!this.$data)\n            return;\n        const { gen, schemaCode, schemaType, def } = this;\n        gen.if((0, codegen_1.or)((0, codegen_1._) `${schemaCode} === undefined`, $dataValid));\n        if (valid !== codegen_1.nil)\n            gen.assign(valid, true);\n        if (schemaType.length || def.validateSchema) {\n            gen.elseIf(this.invalid$data());\n            this.$dataError();\n            if (valid !== codegen_1.nil)\n                gen.assign(valid, false);\n        }\n        gen.else();\n    }\n    invalid$data() {\n        const { gen, schemaCode, schemaType, def, it } = this;\n        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());\n        function wrong$DataType() {\n            if (schemaType.length) {\n                /* istanbul ignore if */\n                if (!(schemaCode instanceof codegen_1.Name))\n                    throw new Error(\"ajv implementation error\");\n                const st = Array.isArray(schemaType) ? schemaType : [schemaType];\n                return (0, codegen_1._) `${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;\n            }\n            return codegen_1.nil;\n        }\n        function invalid$DataSchema() {\n            if (def.validateSchema) {\n                const validateSchemaRef = gen.scopeValue(\"validate$data\", { ref: def.validateSchema }); // TODO value.code for standalone\n                return (0, codegen_1._) `!${validateSchemaRef}(${schemaCode})`;\n            }\n            return codegen_1.nil;\n        }\n    }\n    subschema(appl, valid) {\n        const subschema = (0, subschema_1.getSubschema)(this.it, appl);\n        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);\n        (0, subschema_1.extendSubschemaMode)(subschema, appl);\n        const nextContext = { ...this.it, ...subschema, items: undefined, props: undefined };\n        subschemaCode(nextContext, valid);\n        return nextContext;\n    }\n    mergeEvaluated(schemaCxt, toName) {\n        const { it, gen } = this;\n        if (!it.opts.unevaluated)\n            return;\n        if (it.props !== true && schemaCxt.props !== undefined) {\n            it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);\n        }\n        if (it.items !== true && schemaCxt.items !== undefined) {\n            it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);\n        }\n    }\n    mergeValidEvaluated(schemaCxt, valid) {\n        const { it, gen } = this;\n        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {\n            gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));\n            return true;\n        }\n    }\n}\nexports.KeywordCxt = KeywordCxt;\nfunction keywordCode(it, keyword, def, ruleType) {\n    const cxt = new KeywordCxt(it, def, keyword);\n    if (\"code\" in def) {\n        def.code(cxt, ruleType);\n    }\n    else if (cxt.$data && def.validate) {\n        (0, keyword_1.funcKeywordCode)(cxt, def);\n    }\n    else if (\"macro\" in def) {\n        (0, keyword_1.macroKeywordCode)(cxt, def);\n    }\n    else if (def.compile || def.validate) {\n        (0, keyword_1.funcKeywordCode)(cxt, def);\n    }\n}\nconst JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/;\nconst RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/;\nfunction getData($data, { dataLevel, dataNames, dataPathArr }) {\n    let jsonPointer;\n    let data;\n    if ($data === \"\")\n        return names_1.default.rootData;\n    if ($data[0] === \"/\") {\n        if (!JSON_POINTER.test($data))\n            throw new Error(`Invalid JSON-pointer: ${$data}`);\n        jsonPointer = $data;\n        data = names_1.default.rootData;\n    }\n    else {\n        const matches = RELATIVE_JSON_POINTER.exec($data);\n        if (!matches)\n            throw new Error(`Invalid JSON-pointer: ${$data}`);\n        const up = +matches[1];\n        jsonPointer = matches[2];\n        if (jsonPointer === \"#\") {\n            if (up >= dataLevel)\n                throw new Error(errorMsg(\"property/index\", up));\n            return dataPathArr[dataLevel - up];\n        }\n        if (up > dataLevel)\n            throw new Error(errorMsg(\"data\", up));\n        data = dataNames[dataLevel - up];\n        if (!jsonPointer)\n            return data;\n    }\n    let expr = data;\n    const segments = jsonPointer.split(\"/\");\n    for (const segment of segments) {\n        if (segment) {\n            data = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;\n            expr = (0, codegen_1._) `${expr} && ${data}`;\n        }\n    }\n    return expr;\n    function errorMsg(pointerType, up) {\n        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;\n    }\n}\nexports.getData = getData;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv = void 0;\nconst core_1 = require(\"./core\");\nconst draft7_1 = require(\"./vocabularies/draft7\");\nconst discriminator_1 = require(\"./vocabularies/discriminator\");\nconst draft7MetaSchema = require(\"./refs/json-schema-draft-07.json\");\nconst META_SUPPORT_DATA = [\"/properties\"];\nconst META_SCHEMA_ID = \"http://json-schema.org/draft-07/schema\";\nclass Ajv extends core_1.default {\n    _addVocabularies() {\n        super._addVocabularies();\n        draft7_1.default.forEach((v) => this.addVocabulary(v));\n        if (this.opts.discriminator)\n            this.addKeyword(discriminator_1.default);\n    }\n    _addDefaultMetaSchema() {\n        super._addDefaultMetaSchema();\n        if (!this.opts.meta)\n            return;\n        const metaSchema = this.opts.$data\n            ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA)\n            : draft7MetaSchema;\n        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);\n        this.refs[\"http://json-schema.org/schema\"] = META_SCHEMA_ID;\n    }\n    defaultMeta() {\n        return (this.opts.defaultMeta =\n            super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined));\n    }\n}\nexports.Ajv = Ajv;\nmodule.exports = exports = Ajv;\nmodule.exports.Ajv = Ajv;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Ajv;\nvar validate_1 = require(\"./compile/validate\");\nObject.defineProperty(exports, \"KeywordCxt\", { enumerable: true, get: function () { return validate_1.KeywordCxt; } });\nvar codegen_1 = require(\"./compile/codegen\");\nObject.defineProperty(exports, \"_\", { enumerable: true, get: function () { return codegen_1._; } });\nObject.defineProperty(exports, \"str\", { enumerable: true, get: function () { return codegen_1.str; } });\nObject.defineProperty(exports, \"stringify\", { enumerable: true, get: function () { return codegen_1.stringify; } });\nObject.defineProperty(exports, \"nil\", { enumerable: true, get: function () { return codegen_1.nil; } });\nObject.defineProperty(exports, \"Name\", { enumerable: true, get: function () { return codegen_1.Name; } });\nObject.defineProperty(exports, \"CodeGen\", { enumerable: true, get: function () { return codegen_1.CodeGen; } });\nvar validation_error_1 = require(\"./runtime/validation_error\");\nObject.defineProperty(exports, \"ValidationError\", { enumerable: true, get: function () { return validation_error_1.default; } });\nvar ref_error_1 = require(\"./compile/ref_error\");\nObject.defineProperty(exports, \"MissingRefError\", { enumerable: true, get: function () { return ref_error_1.default; } });\n//# sourceMappingURL=ajv.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst error = {\n    message: ({ schemaCode }) => (0, codegen_1.str) `must be multiple of ${schemaCode}`,\n    params: ({ schemaCode }) => (0, codegen_1._) `{multipleOf: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"multipleOf\",\n    type: \"number\",\n    schemaType: \"number\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, schemaCode, it } = cxt;\n        // const bdt = bad$DataType(schemaCode, <string>def.schemaType, $data)\n        const prec = it.opts.multipleOfPrecision;\n        const res = gen.let(\"res\");\n        const invalid = prec\n            ? (0, codegen_1._) `Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}`\n            : (0, codegen_1._) `${res} !== parseInt(${res})`;\n        cxt.fail$data((0, codegen_1._) `(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);\n    },\n};\nexports.default = def;\n//# sourceMappingURL=multipleOf.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst items_1 = require(\"./items\");\nconst def = {\n    keyword: \"prefixItems\",\n    type: \"array\",\n    schemaType: [\"array\"],\n    before: \"uniqueItems\",\n    code: (cxt) => (0, items_1.validateTuple)(cxt, \"items\"),\n};\nexports.default = def;\n//# sourceMappingURL=prefixItems.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst dynamicAnchor_1 = require(\"./dynamicAnchor\");\nconst dynamicRef_1 = require(\"./dynamicRef\");\nconst recursiveAnchor_1 = require(\"./recursiveAnchor\");\nconst recursiveRef_1 = require(\"./recursiveRef\");\nconst dynamic = [dynamicAnchor_1.default, dynamicRef_1.default, recursiveAnchor_1.default, recursiveRef_1.default];\nexports.default = dynamic;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;\nconst util_1 = require(\"./util\");\nconst equal = require(\"fast-deep-equal\");\nconst traverse = require(\"json-schema-traverse\");\n// TODO refactor to use keyword definitions\nconst SIMPLE_INLINED = new Set([\n    \"type\",\n    \"format\",\n    \"pattern\",\n    \"maxLength\",\n    \"minLength\",\n    \"maxProperties\",\n    \"minProperties\",\n    \"maxItems\",\n    \"minItems\",\n    \"maximum\",\n    \"minimum\",\n    \"uniqueItems\",\n    \"multipleOf\",\n    \"required\",\n    \"enum\",\n    \"const\",\n]);\nfunction inlineRef(schema, limit = true) {\n    if (typeof schema == \"boolean\")\n        return true;\n    if (limit === true)\n        return !hasRef(schema);\n    if (!limit)\n        return false;\n    return countKeys(schema) <= limit;\n}\nexports.inlineRef = inlineRef;\nconst REF_KEYWORDS = new Set([\n    \"$ref\",\n    \"$recursiveRef\",\n    \"$recursiveAnchor\",\n    \"$dynamicRef\",\n    \"$dynamicAnchor\",\n]);\nfunction hasRef(schema) {\n    for (const key in schema) {\n        if (REF_KEYWORDS.has(key))\n            return true;\n        const sch = schema[key];\n        if (Array.isArray(sch) && sch.some(hasRef))\n            return true;\n        if (typeof sch == \"object\" && hasRef(sch))\n            return true;\n    }\n    return false;\n}\nfunction countKeys(schema) {\n    let count = 0;\n    for (const key in schema) {\n        if (key === \"$ref\")\n            return Infinity;\n        count++;\n        if (SIMPLE_INLINED.has(key))\n            continue;\n        if (typeof schema[key] == \"object\") {\n            (0, util_1.eachItem)(schema[key], (sch) => (count += countKeys(sch)));\n        }\n        if (count === Infinity)\n            return Infinity;\n    }\n    return count;\n}\nfunction getFullPath(resolver, id = \"\", normalize) {\n    if (normalize !== false)\n        id = normalizeId(id);\n    const p = resolver.parse(id);\n    return _getFullPath(resolver, p);\n}\nexports.getFullPath = getFullPath;\nfunction _getFullPath(resolver, p) {\n    const serialized = resolver.serialize(p);\n    return serialized.split(\"#\")[0] + \"#\";\n}\nexports._getFullPath = _getFullPath;\nconst TRAILING_SLASH_HASH = /#\\/?$/;\nfunction normalizeId(id) {\n    return id ? id.replace(TRAILING_SLASH_HASH, \"\") : \"\";\n}\nexports.normalizeId = normalizeId;\nfunction resolveUrl(resolver, baseId, id) {\n    id = normalizeId(id);\n    return resolver.resolve(baseId, id);\n}\nexports.resolveUrl = resolveUrl;\nconst ANCHOR = /^[a-z_][-a-z0-9._]*$/i;\nfunction getSchemaRefs(schema, baseId) {\n    if (typeof schema == \"boolean\")\n        return {};\n    const { schemaId, uriResolver } = this.opts;\n    const schId = normalizeId(schema[schemaId] || baseId);\n    const baseIds = { \"\": schId };\n    const pathPrefix = getFullPath(uriResolver, schId, false);\n    const localRefs = {};\n    const schemaRefs = new Set();\n    traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {\n        if (parentJsonPtr === undefined)\n            return;\n        const fullPath = pathPrefix + jsonPtr;\n        let innerBaseId = baseIds[parentJsonPtr];\n        if (typeof sch[schemaId] == \"string\")\n            innerBaseId = addRef.call(this, sch[schemaId]);\n        addAnchor.call(this, sch.$anchor);\n        addAnchor.call(this, sch.$dynamicAnchor);\n        baseIds[jsonPtr] = innerBaseId;\n        function addRef(ref) {\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            const _resolve = this.opts.uriResolver.resolve;\n            ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref);\n            if (schemaRefs.has(ref))\n                throw ambiguos(ref);\n            schemaRefs.add(ref);\n            let schOrRef = this.refs[ref];\n            if (typeof schOrRef == \"string\")\n                schOrRef = this.refs[schOrRef];\n            if (typeof schOrRef == \"object\") {\n                checkAmbiguosRef(sch, schOrRef.schema, ref);\n            }\n            else if (ref !== normalizeId(fullPath)) {\n                if (ref[0] === \"#\") {\n                    checkAmbiguosRef(sch, localRefs[ref], ref);\n                    localRefs[ref] = sch;\n                }\n                else {\n                    this.refs[ref] = fullPath;\n                }\n            }\n            return ref;\n        }\n        function addAnchor(anchor) {\n            if (typeof anchor == \"string\") {\n                if (!ANCHOR.test(anchor))\n                    throw new Error(`invalid anchor \"${anchor}\"`);\n                addRef.call(this, `#${anchor}`);\n            }\n        }\n    });\n    return localRefs;\n    function checkAmbiguosRef(sch1, sch2, ref) {\n        if (sch2 !== undefined && !equal(sch1, sch2))\n            throw ambiguos(ref);\n    }\n    function ambiguos(ref) {\n        return new Error(`reference \"${ref}\" resolves to more than one schema`);\n    }\n}\nexports.getSchemaRefs = getSchemaRefs;\n//# sourceMappingURL=resolve.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst limitNumber_1 = require(\"./limitNumber\");\nconst multipleOf_1 = require(\"./multipleOf\");\nconst limitLength_1 = require(\"./limitLength\");\nconst pattern_1 = require(\"./pattern\");\nconst limitProperties_1 = require(\"./limitProperties\");\nconst required_1 = require(\"./required\");\nconst limitItems_1 = require(\"./limitItems\");\nconst uniqueItems_1 = require(\"./uniqueItems\");\nconst const_1 = require(\"./const\");\nconst enum_1 = require(\"./enum\");\nconst validation = [\n    // number\n    limitNumber_1.default,\n    multipleOf_1.default,\n    // string\n    limitLength_1.default,\n    pattern_1.default,\n    // object\n    limitProperties_1.default,\n    required_1.default,\n    // array\n    limitItems_1.default,\n    uniqueItems_1.default,\n    // any\n    { keyword: \"type\", schemaType: [\"string\", \"array\"] },\n    { keyword: \"nullable\", schemaType: \"boolean\" },\n    const_1.default,\n    enum_1.default,\n];\nexports.default = validation;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.contentVocabulary = exports.metadataVocabulary = void 0;\nexports.metadataVocabulary = [\n    \"title\",\n    \"description\",\n    \"default\",\n    \"deprecated\",\n    \"readOnly\",\n    \"writeOnly\",\n    \"examples\",\n];\nexports.contentVocabulary = [\n    \"contentMediaType\",\n    \"contentEncoding\",\n    \"contentSchema\",\n];\n//# sourceMappingURL=metadata.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst metaSchema = require(\"./schema.json\");\nconst applicator = require(\"./meta/applicator.json\");\nconst content = require(\"./meta/content.json\");\nconst core = require(\"./meta/core.json\");\nconst format = require(\"./meta/format.json\");\nconst metadata = require(\"./meta/meta-data.json\");\nconst validation = require(\"./meta/validation.json\");\nconst META_SUPPORT_DATA = [\"/properties\"];\nfunction addMetaSchema2019($data) {\n    ;\n    [\n        metaSchema,\n        applicator,\n        content,\n        core,\n        with$data(this, format),\n        metadata,\n        with$data(this, validation),\n    ].forEach((sch) => this.addMetaSchema(sch, undefined, false));\n    return this;\n    function with$data(ajv, sch) {\n        return $data ? ajv.$dataMetaSchema(sch, META_SUPPORT_DATA) : sch;\n    }\n}\nexports.default = addMetaSchema2019;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst id_1 = require(\"./id\");\nconst ref_1 = require(\"./ref\");\nconst core = [\n    \"$schema\",\n    \"$id\",\n    \"$defs\",\n    \"$vocabulary\",\n    { keyword: \"$comment\" },\n    \"definitions\",\n    id_1.default,\n    ref_1.default,\n];\nexports.default = core;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.dynamicAnchor = void 0;\nconst codegen_1 = require(\"../../compile/codegen\");\nconst names_1 = require(\"../../compile/names\");\nconst compile_1 = require(\"../../compile\");\nconst ref_1 = require(\"../core/ref\");\nconst def = {\n    keyword: \"$dynamicAnchor\",\n    schemaType: \"string\",\n    code: (cxt) => dynamicAnchor(cxt, cxt.schema),\n};\nfunction dynamicAnchor(cxt, anchor) {\n    const { gen, it } = cxt;\n    it.schemaEnv.root.dynamicAnchors[anchor] = true;\n    const v = (0, codegen_1._) `${names_1.default.dynamicAnchors}${(0, codegen_1.getProperty)(anchor)}`;\n    const validate = it.errSchemaPath === \"#\" ? it.validateName : _getValidate(cxt);\n    gen.if((0, codegen_1._) `!${v}`, () => gen.assign(v, validate));\n}\nexports.dynamicAnchor = dynamicAnchor;\nfunction _getValidate(cxt) {\n    const { schemaEnv, schema, self } = cxt.it;\n    const { root, baseId, localRefs, meta } = schemaEnv.root;\n    const { schemaId } = self.opts;\n    const sch = new compile_1.SchemaEnv({ schema, schemaId, root, baseId, localRefs, meta });\n    compile_1.compileSchema.call(self, sch);\n    return (0, ref_1.getValidate)(cxt, sch);\n}\nexports.default = def;\n//# sourceMappingURL=dynamicAnchor.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst unevaluatedProperties_1 = require(\"./unevaluatedProperties\");\nconst unevaluatedItems_1 = require(\"./unevaluatedItems\");\nconst unevaluated = [unevaluatedProperties_1.default, unevaluatedItems_1.default];\nexports.default = unevaluated;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;\nconst codegen_1 = require(\"./codegen\");\nconst validation_error_1 = require(\"../runtime/validation_error\");\nconst names_1 = require(\"./names\");\nconst resolve_1 = require(\"./resolve\");\nconst util_1 = require(\"./util\");\nconst validate_1 = require(\"./validate\");\nclass SchemaEnv {\n    constructor(env) {\n        var _a;\n        this.refs = {};\n        this.dynamicAnchors = {};\n        let schema;\n        if (typeof env.schema == \"object\")\n            schema = env.schema;\n        this.schema = env.schema;\n        this.schemaId = env.schemaId;\n        this.root = env.root || this;\n        this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || \"$id\"]);\n        this.schemaPath = env.schemaPath;\n        this.localRefs = env.localRefs;\n        this.meta = env.meta;\n        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;\n        this.refs = {};\n    }\n}\nexports.SchemaEnv = SchemaEnv;\n// let codeSize = 0\n// let nodeCount = 0\n// Compiles schema in SchemaEnv\nfunction compileSchema(sch) {\n    // TODO refactor - remove compilations\n    const _sch = getCompilingSchema.call(this, sch);\n    if (_sch)\n        return _sch;\n    const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId); // TODO if getFullPath removed 1 tests fails\n    const { es5, lines } = this.opts.code;\n    const { ownProperties } = this.opts;\n    const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });\n    let _ValidationError;\n    if (sch.$async) {\n        _ValidationError = gen.scopeValue(\"Error\", {\n            ref: validation_error_1.default,\n            code: (0, codegen_1._) `require(\"ajv/dist/runtime/validation_error\").default`,\n        });\n    }\n    const validateName = gen.scopeName(\"validate\");\n    sch.validateName = validateName;\n    const schemaCxt = {\n        gen,\n        allErrors: this.opts.allErrors,\n        data: names_1.default.data,\n        parentData: names_1.default.parentData,\n        parentDataProperty: names_1.default.parentDataProperty,\n        dataNames: [names_1.default.data],\n        dataPathArr: [codegen_1.nil], // TODO can its length be used as dataLevel if nil is removed?\n        dataLevel: 0,\n        dataTypes: [],\n        definedProperties: new Set(),\n        topSchemaRef: gen.scopeValue(\"schema\", this.opts.code.source === true\n            ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) }\n            : { ref: sch.schema }),\n        validateName,\n        ValidationError: _ValidationError,\n        schema: sch.schema,\n        schemaEnv: sch,\n        rootId,\n        baseId: sch.baseId || rootId,\n        schemaPath: codegen_1.nil,\n        errSchemaPath: sch.schemaPath || (this.opts.jtd ? \"\" : \"#\"),\n        errorPath: (0, codegen_1._) `\"\"`,\n        opts: this.opts,\n        self: this,\n    };\n    let sourceCode;\n    try {\n        this._compilations.add(sch);\n        (0, validate_1.validateFunctionCode)(schemaCxt);\n        gen.optimize(this.opts.code.optimize);\n        // gen.optimize(1)\n        const validateCode = gen.toString();\n        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;\n        // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))\n        if (this.opts.code.process)\n            sourceCode = this.opts.code.process(sourceCode, sch);\n        // console.log(\"\\n\\n\\n *** \\n\", sourceCode)\n        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);\n        const validate = makeValidate(this, this.scope.get());\n        this.scope.value(validateName, { ref: validate });\n        validate.errors = null;\n        validate.schema = sch.schema;\n        validate.schemaEnv = sch;\n        if (sch.$async)\n            validate.$async = true;\n        if (this.opts.code.source === true) {\n            validate.source = { validateName, validateCode, scopeValues: gen._values };\n        }\n        if (this.opts.unevaluated) {\n            const { props, items } = schemaCxt;\n            validate.evaluated = {\n                props: props instanceof codegen_1.Name ? undefined : props,\n                items: items instanceof codegen_1.Name ? undefined : items,\n                dynamicProps: props instanceof codegen_1.Name,\n                dynamicItems: items instanceof codegen_1.Name,\n            };\n            if (validate.source)\n                validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);\n        }\n        sch.validate = validate;\n        return sch;\n    }\n    catch (e) {\n        delete sch.validate;\n        delete sch.validateName;\n        if (sourceCode)\n            this.logger.error(\"Error compiling schema, function code:\", sourceCode);\n        // console.log(\"\\n\\n\\n *** \\n\", sourceCode, this.opts)\n        throw e;\n    }\n    finally {\n        this._compilations.delete(sch);\n    }\n}\nexports.compileSchema = compileSchema;\nfunction resolveRef(root, baseId, ref) {\n    var _a;\n    ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);\n    const schOrFunc = root.refs[ref];\n    if (schOrFunc)\n        return schOrFunc;\n    let _sch = resolve.call(this, root, ref);\n    if (_sch === undefined) {\n        const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref]; // TODO maybe localRefs should hold SchemaEnv\n        const { schemaId } = this.opts;\n        if (schema)\n            _sch = new SchemaEnv({ schema, schemaId, root, baseId });\n    }\n    if (_sch === undefined)\n        return;\n    return (root.refs[ref] = inlineOrCompile.call(this, _sch));\n}\nexports.resolveRef = resolveRef;\nfunction inlineOrCompile(sch) {\n    if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))\n        return sch.schema;\n    return sch.validate ? sch : compileSchema.call(this, sch);\n}\n// Index of schema compilation in the currently compiled list\nfunction getCompilingSchema(schEnv) {\n    for (const sch of this._compilations) {\n        if (sameSchemaEnv(sch, schEnv))\n            return sch;\n    }\n}\nexports.getCompilingSchema = getCompilingSchema;\nfunction sameSchemaEnv(s1, s2) {\n    return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;\n}\n// resolve and compile the references ($ref)\n// TODO returns AnySchemaObject (if the schema can be inlined) or validation function\nfunction resolve(root, // information about the root schema for the current schema\nref // reference to resolve\n) {\n    let sch;\n    while (typeof (sch = this.refs[ref]) == \"string\")\n        ref = sch;\n    return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);\n}\n// Resolve schema, its root and baseId\nfunction resolveSchema(root, // root object with properties schema, refs TODO below SchemaEnv is assigned to it\nref // reference to resolve\n) {\n    const p = this.opts.uriResolver.parse(ref);\n    const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);\n    let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, undefined);\n    // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests\n    if (Object.keys(root.schema).length > 0 && refPath === baseId) {\n        return getJsonPointer.call(this, p, root);\n    }\n    const id = (0, resolve_1.normalizeId)(refPath);\n    const schOrRef = this.refs[id] || this.schemas[id];\n    if (typeof schOrRef == \"string\") {\n        const sch = resolveSchema.call(this, root, schOrRef);\n        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== \"object\")\n            return;\n        return getJsonPointer.call(this, p, sch);\n    }\n    if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== \"object\")\n        return;\n    if (!schOrRef.validate)\n        compileSchema.call(this, schOrRef);\n    if (id === (0, resolve_1.normalizeId)(ref)) {\n        const { schema } = schOrRef;\n        const { schemaId } = this.opts;\n        const schId = schema[schemaId];\n        if (schId)\n            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);\n        return new SchemaEnv({ schema, schemaId, root, baseId });\n    }\n    return getJsonPointer.call(this, p, schOrRef);\n}\nexports.resolveSchema = resolveSchema;\nconst PREVENT_SCOPE_CHANGE = new Set([\n    \"properties\",\n    \"patternProperties\",\n    \"enum\",\n    \"dependencies\",\n    \"definitions\",\n]);\nfunction getJsonPointer(parsedRef, { baseId, schema, root }) {\n    var _a;\n    if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== \"/\")\n        return;\n    for (const part of parsedRef.fragment.slice(1).split(\"/\")) {\n        if (typeof schema === \"boolean\")\n            return;\n        const partSchema = schema[(0, util_1.unescapeFragment)(part)];\n        if (partSchema === undefined)\n            return;\n        schema = partSchema;\n        // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?\n        const schId = typeof schema === \"object\" && schema[this.opts.schemaId];\n        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {\n            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);\n        }\n    }\n    let env;\n    if (typeof schema != \"boolean\" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {\n        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);\n        env = resolveSchema.call(this, root, $ref);\n    }\n    // even though resolution failed we need to return SchemaEnv to throw exception\n    // so that compileAsync loads missing schema.\n    const { schemaId } = this.opts;\n    env = env || new SchemaEnv({ schema, schemaId, root, baseId });\n    if (env.schema !== env.root.schema)\n        return env;\n    return undefined;\n}\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst ops = codegen_1.operators;\nconst KWDs = {\n    maximum: { okStr: \"<=\", ok: ops.LTE, fail: ops.GT },\n    minimum: { okStr: \">=\", ok: ops.GTE, fail: ops.LT },\n    exclusiveMaximum: { okStr: \"<\", ok: ops.LT, fail: ops.GTE },\n    exclusiveMinimum: { okStr: \">\", ok: ops.GT, fail: ops.LTE },\n};\nconst error = {\n    message: ({ keyword, schemaCode }) => (0, codegen_1.str) `must be ${KWDs[keyword].okStr} ${schemaCode}`,\n    params: ({ keyword, schemaCode }) => (0, codegen_1._) `{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`,\n};\nconst def = {\n    keyword: Object.keys(KWDs),\n    type: \"number\",\n    schemaType: \"number\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { keyword, data, schemaCode } = cxt;\n        cxt.fail$data((0, codegen_1._) `${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);\n    },\n};\nexports.default = def;\n//# sourceMappingURL=limitNumber.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// https://github.com/ajv-validator/ajv/issues/889\nconst equal = require(\"fast-deep-equal\");\nequal.code = 'require(\"ajv/dist/runtime/equal\").default';\nexports.default = equal;\n//# sourceMappingURL=equal.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst ucs2length_1 = require(\"../../runtime/ucs2length\");\nconst error = {\n    message({ keyword, schemaCode }) {\n        const comp = keyword === \"maxLength\" ? \"more\" : \"fewer\";\n        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} characters`;\n    },\n    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,\n};\nconst def = {\n    keyword: [\"maxLength\", \"minLength\"],\n    type: \"string\",\n    schemaType: \"number\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { keyword, data, schemaCode, it } = cxt;\n        const op = keyword === \"maxLength\" ? codegen_1.operators.GT : codegen_1.operators.LT;\n        const len = it.opts.unicode === false ? (0, codegen_1._) `${data}.length` : (0, codegen_1._) `${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;\n        cxt.fail$data((0, codegen_1._) `${len} ${op} ${schemaCode}`);\n    },\n};\nexports.default = def;\n//# sourceMappingURL=limitLength.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst names_1 = require(\"../../compile/names\");\nconst error = {\n    message: \"must NOT have unevaluated properties\",\n    params: ({ params }) => (0, codegen_1._) `{unevaluatedProperty: ${params.unevaluatedProperty}}`,\n};\nconst def = {\n    keyword: \"unevaluatedProperties\",\n    type: \"object\",\n    schemaType: [\"boolean\", \"object\"],\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, schema, data, errsCount, it } = cxt;\n        /* istanbul ignore if */\n        if (!errsCount)\n            throw new Error(\"ajv implementation error\");\n        const { allErrors, props } = it;\n        if (props instanceof codegen_1.Name) {\n            gen.if((0, codegen_1._) `${props} !== true`, () => gen.forIn(\"key\", data, (key) => gen.if(unevaluatedDynamic(props, key), () => unevaluatedPropCode(key))));\n        }\n        else if (props !== true) {\n            gen.forIn(\"key\", data, (key) => props === undefined\n                ? unevaluatedPropCode(key)\n                : gen.if(unevaluatedStatic(props, key), () => unevaluatedPropCode(key)));\n        }\n        it.props = true;\n        cxt.ok((0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);\n        function unevaluatedPropCode(key) {\n            if (schema === false) {\n                cxt.setParams({ unevaluatedProperty: key });\n                cxt.error();\n                if (!allErrors)\n                    gen.break();\n                return;\n            }\n            if (!(0, util_1.alwaysValidSchema)(it, schema)) {\n                const valid = gen.name(\"valid\");\n                cxt.subschema({\n                    keyword: \"unevaluatedProperties\",\n                    dataProp: key,\n                    dataPropType: util_1.Type.Str,\n                }, valid);\n                if (!allErrors)\n                    gen.if((0, codegen_1.not)(valid), () => gen.break());\n            }\n        }\n        function unevaluatedDynamic(evaluatedProps, key) {\n            return (0, codegen_1._) `!${evaluatedProps} || !${evaluatedProps}[${key}]`;\n        }\n        function unevaluatedStatic(evaluatedProps, key) {\n            const ps = [];\n            for (const p in evaluatedProps) {\n                if (evaluatedProps[p] === true)\n                    ps.push((0, codegen_1._) `${key} !== ${p}`);\n            }\n            return (0, codegen_1.and)(...ps);\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=unevaluatedProperties.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst code_1 = require(\"../code\");\nexports.error = {\n    message: ({ params: { property, depsCount, deps } }) => {\n        const property_ies = depsCount === 1 ? \"property\" : \"properties\";\n        return (0, codegen_1.str) `must have ${property_ies} ${deps} when property ${property} is present`;\n    },\n    params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._) `{property: ${property},\n    missingProperty: ${missingProperty},\n    depsCount: ${depsCount},\n    deps: ${deps}}`, // TODO change to reference\n};\nconst def = {\n    keyword: \"dependencies\",\n    type: \"object\",\n    schemaType: \"object\",\n    error: exports.error,\n    code(cxt) {\n        const [propDeps, schDeps] = splitDependencies(cxt);\n        validatePropertyDeps(cxt, propDeps);\n        validateSchemaDeps(cxt, schDeps);\n    },\n};\nfunction splitDependencies({ schema }) {\n    const propertyDeps = {};\n    const schemaDeps = {};\n    for (const key in schema) {\n        if (key === \"__proto__\")\n            continue;\n        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;\n        deps[key] = schema[key];\n    }\n    return [propertyDeps, schemaDeps];\n}\nfunction validatePropertyDeps(cxt, propertyDeps = cxt.schema) {\n    const { gen, data, it } = cxt;\n    if (Object.keys(propertyDeps).length === 0)\n        return;\n    const missing = gen.let(\"missing\");\n    for (const prop in propertyDeps) {\n        const deps = propertyDeps[prop];\n        if (deps.length === 0)\n            continue;\n        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);\n        cxt.setParams({\n            property: prop,\n            depsCount: deps.length,\n            deps: deps.join(\", \"),\n        });\n        if (it.allErrors) {\n            gen.if(hasProperty, () => {\n                for (const depProp of deps) {\n                    (0, code_1.checkReportMissingProp)(cxt, depProp);\n                }\n            });\n        }\n        else {\n            gen.if((0, codegen_1._) `${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);\n            (0, code_1.reportMissingProp)(cxt, missing);\n            gen.else();\n        }\n    }\n}\nexports.validatePropertyDeps = validatePropertyDeps;\nfunction validateSchemaDeps(cxt, schemaDeps = cxt.schema) {\n    const { gen, data, keyword, it } = cxt;\n    const valid = gen.name(\"valid\");\n    for (const prop in schemaDeps) {\n        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))\n            continue;\n        gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties), () => {\n            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);\n            cxt.mergeValidEvaluated(schCxt, valid);\n        }, () => gen.var(valid, true) // TODO var\n        );\n        cxt.ok(valid);\n    }\n}\nexports.validateSchemaDeps = validateSchemaDeps;\nexports.default = def;\n//# sourceMappingURL=dependencies.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst def = {\n    keyword: \"id\",\n    code() {\n        throw new Error('NOT SUPPORTED: keyword \"id\", use \"$id\" for schema ID');\n    },\n};\nexports.default = def;\n//# sourceMappingURL=id.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst core_1 = require(\"./core\");\nconst validation_1 = require(\"./validation\");\nconst applicator_1 = require(\"./applicator\");\nconst format_1 = require(\"./format\");\nconst metadata_1 = require(\"./metadata\");\nconst draft7Vocabularies = [\n    core_1.default,\n    validation_1.default,\n    (0, applicator_1.default)(),\n    format_1.default,\n    metadata_1.metadataVocabulary,\n    metadata_1.contentVocabulary,\n];\nexports.default = draft7Vocabularies;\n//# sourceMappingURL=draft7.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst error = {\n    message: ({ schemaCode }) => (0, codegen_1.str) `must match pattern \"${schemaCode}\"`,\n    params: ({ schemaCode }) => (0, codegen_1._) `{pattern: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"pattern\",\n    type: \"string\",\n    schemaType: \"string\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { data, $data, schema, schemaCode, it } = cxt;\n        // TODO regexp should be wrapped in try/catchs\n        const u = it.opts.unicodeRegExp ? \"u\" : \"\";\n        const regExp = $data ? (0, codegen_1._) `(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);\n        cxt.fail$data((0, codegen_1._) `!${regExp}.test(${data})`);\n    },\n};\nexports.default = def;\n//# sourceMappingURL=pattern.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst code_1 = require(\"../code\");\nconst additionalItems_1 = require(\"./additionalItems\");\nconst error = {\n    message: ({ params: { len } }) => (0, codegen_1.str) `must NOT have more than ${len} items`,\n    params: ({ params: { len } }) => (0, codegen_1._) `{limit: ${len}}`,\n};\nconst def = {\n    keyword: \"items\",\n    type: \"array\",\n    schemaType: [\"object\", \"boolean\"],\n    before: \"uniqueItems\",\n    error,\n    code(cxt) {\n        const { schema, parentSchema, it } = cxt;\n        const { prefixItems } = parentSchema;\n        it.items = true;\n        if ((0, util_1.alwaysValidSchema)(it, schema))\n            return;\n        if (prefixItems)\n            (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);\n        else\n            cxt.ok((0, code_1.validateArray)(cxt));\n    },\n};\nexports.default = def;\n//# sourceMappingURL=items2020.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;\nconst codegen_1 = require(\"./codegen\");\nconst code_1 = require(\"./codegen/code\");\n// TODO refactor to use Set\nfunction toHash(arr) {\n    const hash = {};\n    for (const item of arr)\n        hash[item] = true;\n    return hash;\n}\nexports.toHash = toHash;\nfunction alwaysValidSchema(it, schema) {\n    if (typeof schema == \"boolean\")\n        return schema;\n    if (Object.keys(schema).length === 0)\n        return true;\n    checkUnknownRules(it, schema);\n    return !schemaHasRules(schema, it.self.RULES.all);\n}\nexports.alwaysValidSchema = alwaysValidSchema;\nfunction checkUnknownRules(it, schema = it.schema) {\n    const { opts, self } = it;\n    if (!opts.strictSchema)\n        return;\n    if (typeof schema === \"boolean\")\n        return;\n    const rules = self.RULES.keywords;\n    for (const key in schema) {\n        if (!rules[key])\n            checkStrictMode(it, `unknown keyword: \"${key}\"`);\n    }\n}\nexports.checkUnknownRules = checkUnknownRules;\nfunction schemaHasRules(schema, rules) {\n    if (typeof schema == \"boolean\")\n        return !schema;\n    for (const key in schema)\n        if (rules[key])\n            return true;\n    return false;\n}\nexports.schemaHasRules = schemaHasRules;\nfunction schemaHasRulesButRef(schema, RULES) {\n    if (typeof schema == \"boolean\")\n        return !schema;\n    for (const key in schema)\n        if (key !== \"$ref\" && RULES.all[key])\n            return true;\n    return false;\n}\nexports.schemaHasRulesButRef = schemaHasRulesButRef;\nfunction schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {\n    if (!$data) {\n        if (typeof schema == \"number\" || typeof schema == \"boolean\")\n            return schema;\n        if (typeof schema == \"string\")\n            return (0, codegen_1._) `${schema}`;\n    }\n    return (0, codegen_1._) `${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;\n}\nexports.schemaRefOrVal = schemaRefOrVal;\nfunction unescapeFragment(str) {\n    return unescapeJsonPointer(decodeURIComponent(str));\n}\nexports.unescapeFragment = unescapeFragment;\nfunction escapeFragment(str) {\n    return encodeURIComponent(escapeJsonPointer(str));\n}\nexports.escapeFragment = escapeFragment;\nfunction escapeJsonPointer(str) {\n    if (typeof str == \"number\")\n        return `${str}`;\n    return str.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n}\nexports.escapeJsonPointer = escapeJsonPointer;\nfunction unescapeJsonPointer(str) {\n    return str.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n}\nexports.unescapeJsonPointer = unescapeJsonPointer;\nfunction eachItem(xs, f) {\n    if (Array.isArray(xs)) {\n        for (const x of xs)\n            f(x);\n    }\n    else {\n        f(xs);\n    }\n}\nexports.eachItem = eachItem;\nfunction makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName, }) {\n    return (gen, from, to, toName) => {\n        const res = to === undefined\n            ? from\n            : to instanceof codegen_1.Name\n                ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to)\n                : from instanceof codegen_1.Name\n                    ? (mergeToName(gen, to, from), from)\n                    : mergeValues(from, to);\n        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;\n    };\n}\nexports.mergeEvaluated = {\n    props: makeMergeEvaluated({\n        mergeNames: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true && ${from} !== undefined`, () => {\n            gen.if((0, codegen_1._) `${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._) `${to} || {}`).code((0, codegen_1._) `Object.assign(${to}, ${from})`));\n        }),\n        mergeToName: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true`, () => {\n            if (from === true) {\n                gen.assign(to, true);\n            }\n            else {\n                gen.assign(to, (0, codegen_1._) `${to} || {}`);\n                setEvaluated(gen, to, from);\n            }\n        }),\n        mergeValues: (from, to) => (from === true ? true : { ...from, ...to }),\n        resultToName: evaluatedPropsToName,\n    }),\n    items: makeMergeEvaluated({\n        mergeNames: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._) `${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),\n        mergeToName: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._) `${to} > ${from} ? ${to} : ${from}`)),\n        mergeValues: (from, to) => (from === true ? true : Math.max(from, to)),\n        resultToName: (gen, items) => gen.var(\"items\", items),\n    }),\n};\nfunction evaluatedPropsToName(gen, ps) {\n    if (ps === true)\n        return gen.var(\"props\", true);\n    const props = gen.var(\"props\", (0, codegen_1._) `{}`);\n    if (ps !== undefined)\n        setEvaluated(gen, props, ps);\n    return props;\n}\nexports.evaluatedPropsToName = evaluatedPropsToName;\nfunction setEvaluated(gen, props, ps) {\n    Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._) `${props}${(0, codegen_1.getProperty)(p)}`, true));\n}\nexports.setEvaluated = setEvaluated;\nconst snippets = {};\nfunction useFunc(gen, f) {\n    return gen.scopeValue(\"func\", {\n        ref: f,\n        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code)),\n    });\n}\nexports.useFunc = useFunc;\nvar Type;\n(function (Type) {\n    Type[Type[\"Num\"] = 0] = \"Num\";\n    Type[Type[\"Str\"] = 1] = \"Str\";\n})(Type || (exports.Type = Type = {}));\nfunction getErrorPath(dataProp, dataPropType, jsPropertySyntax) {\n    // let path\n    if (dataProp instanceof codegen_1.Name) {\n        const isNumber = dataPropType === Type.Num;\n        return jsPropertySyntax\n            ? isNumber\n                ? (0, codegen_1._) `\"[\" + ${dataProp} + \"]\"`\n                : (0, codegen_1._) `\"['\" + ${dataProp} + \"']\"`\n            : isNumber\n                ? (0, codegen_1._) `\"/\" + ${dataProp}`\n                : (0, codegen_1._) `\"/\" + ${dataProp}.replace(/~/g, \"~0\").replace(/\\\\//g, \"~1\")`; // TODO maybe use global escapePointer\n    }\n    return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : \"/\" + escapeJsonPointer(dataProp);\n}\nexports.getErrorPath = getErrorPath;\nfunction checkStrictMode(it, msg, mode = it.opts.strictSchema) {\n    if (!mode)\n        return;\n    msg = `strict mode: ${msg}`;\n    if (mode === true)\n        throw new Error(msg);\n    it.self.logger.warn(msg);\n}\nexports.checkStrictMode = checkStrictMode;\n//# sourceMappingURL=util.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv2019 = void 0;\nconst core_1 = require(\"./core\");\nconst draft7_1 = require(\"./vocabularies/draft7\");\nconst dynamic_1 = require(\"./vocabularies/dynamic\");\nconst next_1 = require(\"./vocabularies/next\");\nconst unevaluated_1 = require(\"./vocabularies/unevaluated\");\nconst discriminator_1 = require(\"./vocabularies/discriminator\");\nconst json_schema_2019_09_1 = require(\"./refs/json-schema-2019-09\");\nconst META_SCHEMA_ID = \"https://json-schema.org/draft/2019-09/schema\";\nclass Ajv2019 extends core_1.default {\n    constructor(opts = {}) {\n        super({\n            ...opts,\n            dynamicRef: true,\n            next: true,\n            unevaluated: true,\n        });\n    }\n    _addVocabularies() {\n        super._addVocabularies();\n        this.addVocabulary(dynamic_1.default);\n        draft7_1.default.forEach((v) => this.addVocabulary(v));\n        this.addVocabulary(next_1.default);\n        this.addVocabulary(unevaluated_1.default);\n        if (this.opts.discriminator)\n            this.addKeyword(discriminator_1.default);\n    }\n    _addDefaultMetaSchema() {\n        super._addDefaultMetaSchema();\n        const { $data, meta } = this.opts;\n        if (!meta)\n            return;\n        json_schema_2019_09_1.default.call(this, $data);\n        this.refs[\"http://json-schema.org/schema\"] = META_SCHEMA_ID;\n    }\n    defaultMeta() {\n        return (this.opts.defaultMeta =\n            super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined));\n    }\n}\nexports.Ajv2019 = Ajv2019;\nmodule.exports = exports = Ajv2019;\nmodule.exports.Ajv2019 = Ajv2019;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Ajv2019;\nvar validate_1 = require(\"./compile/validate\");\nObject.defineProperty(exports, \"KeywordCxt\", { enumerable: true, get: function () { return validate_1.KeywordCxt; } });\nvar codegen_1 = require(\"./compile/codegen\");\nObject.defineProperty(exports, \"_\", { enumerable: true, get: function () { return codegen_1._; } });\nObject.defineProperty(exports, \"str\", { enumerable: true, get: function () { return codegen_1.str; } });\nObject.defineProperty(exports, \"stringify\", { enumerable: true, get: function () { return codegen_1.stringify; } });\nObject.defineProperty(exports, \"nil\", { enumerable: true, get: function () { return codegen_1.nil; } });\nObject.defineProperty(exports, \"Name\", { enumerable: true, get: function () { return codegen_1.Name; } });\nObject.defineProperty(exports, \"CodeGen\", { enumerable: true, get: function () { return codegen_1.CodeGen; } });\nvar validation_error_1 = require(\"./runtime/validation_error\");\nObject.defineProperty(exports, \"ValidationError\", { enumerable: true, get: function () { return validation_error_1.default; } });\nvar ref_error_1 = require(\"./compile/ref_error\");\nObject.defineProperty(exports, \"MissingRefError\", { enumerable: true, get: function () { return ref_error_1.default; } });\n//# sourceMappingURL=2019.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst error = {\n    message: ({ schemaCode }) => (0, codegen_1.str) `must match format \"${schemaCode}\"`,\n    params: ({ schemaCode }) => (0, codegen_1._) `{format: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"format\",\n    type: [\"number\", \"string\"],\n    schemaType: \"string\",\n    $data: true,\n    error,\n    code(cxt, ruleType) {\n        const { gen, data, $data, schema, schemaCode, it } = cxt;\n        const { opts, errSchemaPath, schemaEnv, self } = it;\n        if (!opts.validateFormats)\n            return;\n        if ($data)\n            validate$DataFormat();\n        else\n            validateFormat();\n        function validate$DataFormat() {\n            const fmts = gen.scopeValue(\"formats\", {\n                ref: self.formats,\n                code: opts.code.formats,\n            });\n            const fDef = gen.const(\"fDef\", (0, codegen_1._) `${fmts}[${schemaCode}]`);\n            const fType = gen.let(\"fType\");\n            const format = gen.let(\"format\");\n            // TODO simplify\n            gen.if((0, codegen_1._) `typeof ${fDef} == \"object\" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._) `${fDef}.type || \"string\"`).assign(format, (0, codegen_1._) `${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._) `\"string\"`).assign(format, fDef));\n            cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));\n            function unknownFmt() {\n                if (opts.strictSchema === false)\n                    return codegen_1.nil;\n                return (0, codegen_1._) `${schemaCode} && !${format}`;\n            }\n            function invalidFmt() {\n                const callFormat = schemaEnv.$async\n                    ? (0, codegen_1._) `(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`\n                    : (0, codegen_1._) `${format}(${data})`;\n                const validData = (0, codegen_1._) `(typeof ${format} == \"function\" ? ${callFormat} : ${format}.test(${data}))`;\n                return (0, codegen_1._) `${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;\n            }\n        }\n        function validateFormat() {\n            const formatDef = self.formats[schema];\n            if (!formatDef) {\n                unknownFormat();\n                return;\n            }\n            if (formatDef === true)\n                return;\n            const [fmtType, format, fmtRef] = getFormat(formatDef);\n            if (fmtType === ruleType)\n                cxt.pass(validCondition());\n            function unknownFormat() {\n                if (opts.strictSchema === false) {\n                    self.logger.warn(unknownMsg());\n                    return;\n                }\n                throw new Error(unknownMsg());\n                function unknownMsg() {\n                    return `unknown format \"${schema}\" ignored in schema at path \"${errSchemaPath}\"`;\n                }\n            }\n            function getFormat(fmtDef) {\n                const code = fmtDef instanceof RegExp\n                    ? (0, codegen_1.regexpCode)(fmtDef)\n                    : opts.code.formats\n                        ? (0, codegen_1._) `${opts.code.formats}${(0, codegen_1.getProperty)(schema)}`\n                        : undefined;\n                const fmt = gen.scopeValue(\"formats\", { key: schema, ref: fmtDef, code });\n                if (typeof fmtDef == \"object\" && !(fmtDef instanceof RegExp)) {\n                    return [fmtDef.type || \"string\", fmtDef.validate, (0, codegen_1._) `${fmt}.validate`];\n                }\n                return [\"string\", fmtDef, fmt];\n            }\n            function validCondition() {\n                if (typeof formatDef == \"object\" && !(formatDef instanceof RegExp) && formatDef.async) {\n                    if (!schemaEnv.$async)\n                        throw new Error(\"async format in sync schema\");\n                    return (0, codegen_1._) `await ${fmtRef}(${data})`;\n                }\n                return typeof format == \"function\" ? (0, codegen_1._) `${fmtRef}(${data})` : (0, codegen_1._) `${fmtRef}.test(${data})`;\n            }\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=format.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: \"must match exactly one schema in oneOf\",\n    params: ({ params }) => (0, codegen_1._) `{passingSchemas: ${params.passing}}`,\n};\nconst def = {\n    keyword: \"oneOf\",\n    schemaType: \"array\",\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, schema, parentSchema, it } = cxt;\n        /* istanbul ignore if */\n        if (!Array.isArray(schema))\n            throw new Error(\"ajv implementation error\");\n        if (it.opts.discriminator && parentSchema.discriminator)\n            return;\n        const schArr = schema;\n        const valid = gen.let(\"valid\", false);\n        const passing = gen.let(\"passing\", null);\n        const schValid = gen.name(\"_valid\");\n        cxt.setParams({ passing });\n        // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas\n        gen.block(validateOneOf);\n        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));\n        function validateOneOf() {\n            schArr.forEach((sch, i) => {\n                let schCxt;\n                if ((0, util_1.alwaysValidSchema)(it, sch)) {\n                    gen.var(schValid, true);\n                }\n                else {\n                    schCxt = cxt.subschema({\n                        keyword: \"oneOf\",\n                        schemaProp: i,\n                        compositeRule: true,\n                    }, schValid);\n                }\n                if (i > 0) {\n                    gen\n                        .if((0, codegen_1._) `${schValid} && ${valid}`)\n                        .assign(valid, false)\n                        .assign(passing, (0, codegen_1._) `[${passing}, ${i}]`)\n                        .else();\n                }\n                gen.if(schValid, () => {\n                    gen.assign(valid, true);\n                    gen.assign(passing, i);\n                    if (schCxt)\n                        cxt.mergeEvaluated(schCxt, codegen_1.Name);\n                });\n            });\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=oneOf.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst format_1 = require(\"./format\");\nconst format = [format_1.default];\nexports.default = format;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DiscrError = void 0;\nvar DiscrError;\n(function (DiscrError) {\n    DiscrError[\"Tag\"] = \"tag\";\n    DiscrError[\"Mapping\"] = \"mapping\";\n})(DiscrError || (exports.DiscrError = DiscrError = {}));\n//# sourceMappingURL=types.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;\nconst code_1 = require(\"./code\");\nconst scope_1 = require(\"./scope\");\nvar code_2 = require(\"./code\");\nObject.defineProperty(exports, \"_\", { enumerable: true, get: function () { return code_2._; } });\nObject.defineProperty(exports, \"str\", { enumerable: true, get: function () { return code_2.str; } });\nObject.defineProperty(exports, \"strConcat\", { enumerable: true, get: function () { return code_2.strConcat; } });\nObject.defineProperty(exports, \"nil\", { enumerable: true, get: function () { return code_2.nil; } });\nObject.defineProperty(exports, \"getProperty\", { enumerable: true, get: function () { return code_2.getProperty; } });\nObject.defineProperty(exports, \"stringify\", { enumerable: true, get: function () { return code_2.stringify; } });\nObject.defineProperty(exports, \"regexpCode\", { enumerable: true, get: function () { return code_2.regexpCode; } });\nObject.defineProperty(exports, \"Name\", { enumerable: true, get: function () { return code_2.Name; } });\nvar scope_2 = require(\"./scope\");\nObject.defineProperty(exports, \"Scope\", { enumerable: true, get: function () { return scope_2.Scope; } });\nObject.defineProperty(exports, \"ValueScope\", { enumerable: true, get: function () { return scope_2.ValueScope; } });\nObject.defineProperty(exports, \"ValueScopeName\", { enumerable: true, get: function () { return scope_2.ValueScopeName; } });\nObject.defineProperty(exports, \"varKinds\", { enumerable: true, get: function () { return scope_2.varKinds; } });\nexports.operators = {\n    GT: new code_1._Code(\">\"),\n    GTE: new code_1._Code(\">=\"),\n    LT: new code_1._Code(\"<\"),\n    LTE: new code_1._Code(\"<=\"),\n    EQ: new code_1._Code(\"===\"),\n    NEQ: new code_1._Code(\"!==\"),\n    NOT: new code_1._Code(\"!\"),\n    OR: new code_1._Code(\"||\"),\n    AND: new code_1._Code(\"&&\"),\n    ADD: new code_1._Code(\"+\"),\n};\nclass Node {\n    optimizeNodes() {\n        return this;\n    }\n    optimizeNames(_names, _constants) {\n        return this;\n    }\n}\nclass Def extends Node {\n    constructor(varKind, name, rhs) {\n        super();\n        this.varKind = varKind;\n        this.name = name;\n        this.rhs = rhs;\n    }\n    render({ es5, _n }) {\n        const varKind = es5 ? scope_1.varKinds.var : this.varKind;\n        const rhs = this.rhs === undefined ? \"\" : ` = ${this.rhs}`;\n        return `${varKind} ${this.name}${rhs};` + _n;\n    }\n    optimizeNames(names, constants) {\n        if (!names[this.name.str])\n            return;\n        if (this.rhs)\n            this.rhs = optimizeExpr(this.rhs, names, constants);\n        return this;\n    }\n    get names() {\n        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};\n    }\n}\nclass Assign extends Node {\n    constructor(lhs, rhs, sideEffects) {\n        super();\n        this.lhs = lhs;\n        this.rhs = rhs;\n        this.sideEffects = sideEffects;\n    }\n    render({ _n }) {\n        return `${this.lhs} = ${this.rhs};` + _n;\n    }\n    optimizeNames(names, constants) {\n        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)\n            return;\n        this.rhs = optimizeExpr(this.rhs, names, constants);\n        return this;\n    }\n    get names() {\n        const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };\n        return addExprNames(names, this.rhs);\n    }\n}\nclass AssignOp extends Assign {\n    constructor(lhs, op, rhs, sideEffects) {\n        super(lhs, rhs, sideEffects);\n        this.op = op;\n    }\n    render({ _n }) {\n        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;\n    }\n}\nclass Label extends Node {\n    constructor(label) {\n        super();\n        this.label = label;\n        this.names = {};\n    }\n    render({ _n }) {\n        return `${this.label}:` + _n;\n    }\n}\nclass Break extends Node {\n    constructor(label) {\n        super();\n        this.label = label;\n        this.names = {};\n    }\n    render({ _n }) {\n        const label = this.label ? ` ${this.label}` : \"\";\n        return `break${label};` + _n;\n    }\n}\nclass Throw extends Node {\n    constructor(error) {\n        super();\n        this.error = error;\n    }\n    render({ _n }) {\n        return `throw ${this.error};` + _n;\n    }\n    get names() {\n        return this.error.names;\n    }\n}\nclass AnyCode extends Node {\n    constructor(code) {\n        super();\n        this.code = code;\n    }\n    render({ _n }) {\n        return `${this.code};` + _n;\n    }\n    optimizeNodes() {\n        return `${this.code}` ? this : undefined;\n    }\n    optimizeNames(names, constants) {\n        this.code = optimizeExpr(this.code, names, constants);\n        return this;\n    }\n    get names() {\n        return this.code instanceof code_1._CodeOrName ? this.code.names : {};\n    }\n}\nclass ParentNode extends Node {\n    constructor(nodes = []) {\n        super();\n        this.nodes = nodes;\n    }\n    render(opts) {\n        return this.nodes.reduce((code, n) => code + n.render(opts), \"\");\n    }\n    optimizeNodes() {\n        const { nodes } = this;\n        let i = nodes.length;\n        while (i--) {\n            const n = nodes[i].optimizeNodes();\n            if (Array.isArray(n))\n                nodes.splice(i, 1, ...n);\n            else if (n)\n                nodes[i] = n;\n            else\n                nodes.splice(i, 1);\n        }\n        return nodes.length > 0 ? this : undefined;\n    }\n    optimizeNames(names, constants) {\n        const { nodes } = this;\n        let i = nodes.length;\n        while (i--) {\n            // iterating backwards improves 1-pass optimization\n            const n = nodes[i];\n            if (n.optimizeNames(names, constants))\n                continue;\n            subtractNames(names, n.names);\n            nodes.splice(i, 1);\n        }\n        return nodes.length > 0 ? this : undefined;\n    }\n    get names() {\n        return this.nodes.reduce((names, n) => addNames(names, n.names), {});\n    }\n}\nclass BlockNode extends ParentNode {\n    render(opts) {\n        return \"{\" + opts._n + super.render(opts) + \"}\" + opts._n;\n    }\n}\nclass Root extends ParentNode {\n}\nclass Else extends BlockNode {\n}\nElse.kind = \"else\";\nclass If extends BlockNode {\n    constructor(condition, nodes) {\n        super(nodes);\n        this.condition = condition;\n    }\n    render(opts) {\n        let code = `if(${this.condition})` + super.render(opts);\n        if (this.else)\n            code += \"else \" + this.else.render(opts);\n        return code;\n    }\n    optimizeNodes() {\n        super.optimizeNodes();\n        const cond = this.condition;\n        if (cond === true)\n            return this.nodes; // else is ignored here\n        let e = this.else;\n        if (e) {\n            const ns = e.optimizeNodes();\n            e = this.else = Array.isArray(ns) ? new Else(ns) : ns;\n        }\n        if (e) {\n            if (cond === false)\n                return e instanceof If ? e : e.nodes;\n            if (this.nodes.length)\n                return this;\n            return new If(not(cond), e instanceof If ? [e] : e.nodes);\n        }\n        if (cond === false || !this.nodes.length)\n            return undefined;\n        return this;\n    }\n    optimizeNames(names, constants) {\n        var _a;\n        this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);\n        if (!(super.optimizeNames(names, constants) || this.else))\n            return;\n        this.condition = optimizeExpr(this.condition, names, constants);\n        return this;\n    }\n    get names() {\n        const names = super.names;\n        addExprNames(names, this.condition);\n        if (this.else)\n            addNames(names, this.else.names);\n        return names;\n    }\n}\nIf.kind = \"if\";\nclass For extends BlockNode {\n}\nFor.kind = \"for\";\nclass ForLoop extends For {\n    constructor(iteration) {\n        super();\n        this.iteration = iteration;\n    }\n    render(opts) {\n        return `for(${this.iteration})` + super.render(opts);\n    }\n    optimizeNames(names, constants) {\n        if (!super.optimizeNames(names, constants))\n            return;\n        this.iteration = optimizeExpr(this.iteration, names, constants);\n        return this;\n    }\n    get names() {\n        return addNames(super.names, this.iteration.names);\n    }\n}\nclass ForRange extends For {\n    constructor(varKind, name, from, to) {\n        super();\n        this.varKind = varKind;\n        this.name = name;\n        this.from = from;\n        this.to = to;\n    }\n    render(opts) {\n        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;\n        const { name, from, to } = this;\n        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);\n    }\n    get names() {\n        const names = addExprNames(super.names, this.from);\n        return addExprNames(names, this.to);\n    }\n}\nclass ForIter extends For {\n    constructor(loop, varKind, name, iterable) {\n        super();\n        this.loop = loop;\n        this.varKind = varKind;\n        this.name = name;\n        this.iterable = iterable;\n    }\n    render(opts) {\n        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);\n    }\n    optimizeNames(names, constants) {\n        if (!super.optimizeNames(names, constants))\n            return;\n        this.iterable = optimizeExpr(this.iterable, names, constants);\n        return this;\n    }\n    get names() {\n        return addNames(super.names, this.iterable.names);\n    }\n}\nclass Func extends BlockNode {\n    constructor(name, args, async) {\n        super();\n        this.name = name;\n        this.args = args;\n        this.async = async;\n    }\n    render(opts) {\n        const _async = this.async ? \"async \" : \"\";\n        return `${_async}function ${this.name}(${this.args})` + super.render(opts);\n    }\n}\nFunc.kind = \"func\";\nclass Return extends ParentNode {\n    render(opts) {\n        return \"return \" + super.render(opts);\n    }\n}\nReturn.kind = \"return\";\nclass Try extends BlockNode {\n    render(opts) {\n        let code = \"try\" + super.render(opts);\n        if (this.catch)\n            code += this.catch.render(opts);\n        if (this.finally)\n            code += this.finally.render(opts);\n        return code;\n    }\n    optimizeNodes() {\n        var _a, _b;\n        super.optimizeNodes();\n        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();\n        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();\n        return this;\n    }\n    optimizeNames(names, constants) {\n        var _a, _b;\n        super.optimizeNames(names, constants);\n        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);\n        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);\n        return this;\n    }\n    get names() {\n        const names = super.names;\n        if (this.catch)\n            addNames(names, this.catch.names);\n        if (this.finally)\n            addNames(names, this.finally.names);\n        return names;\n    }\n}\nclass Catch extends BlockNode {\n    constructor(error) {\n        super();\n        this.error = error;\n    }\n    render(opts) {\n        return `catch(${this.error})` + super.render(opts);\n    }\n}\nCatch.kind = \"catch\";\nclass Finally extends BlockNode {\n    render(opts) {\n        return \"finally\" + super.render(opts);\n    }\n}\nFinally.kind = \"finally\";\nclass CodeGen {\n    constructor(extScope, opts = {}) {\n        this._values = {};\n        this._blockStarts = [];\n        this._constants = {};\n        this.opts = { ...opts, _n: opts.lines ? \"\\n\" : \"\" };\n        this._extScope = extScope;\n        this._scope = new scope_1.Scope({ parent: extScope });\n        this._nodes = [new Root()];\n    }\n    toString() {\n        return this._root.render(this.opts);\n    }\n    // returns unique name in the internal scope\n    name(prefix) {\n        return this._scope.name(prefix);\n    }\n    // reserves unique name in the external scope\n    scopeName(prefix) {\n        return this._extScope.name(prefix);\n    }\n    // reserves unique name in the external scope and assigns value to it\n    scopeValue(prefixOrName, value) {\n        const name = this._extScope.value(prefixOrName, value);\n        const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set());\n        vs.add(name);\n        return name;\n    }\n    getScopeValue(prefix, keyOrRef) {\n        return this._extScope.getValue(prefix, keyOrRef);\n    }\n    // return code that assigns values in the external scope to the names that are used internally\n    // (same names that were returned by gen.scopeName or gen.scopeValue)\n    scopeRefs(scopeName) {\n        return this._extScope.scopeRefs(scopeName, this._values);\n    }\n    scopeCode() {\n        return this._extScope.scopeCode(this._values);\n    }\n    _def(varKind, nameOrPrefix, rhs, constant) {\n        const name = this._scope.toName(nameOrPrefix);\n        if (rhs !== undefined && constant)\n            this._constants[name.str] = rhs;\n        this._leafNode(new Def(varKind, name, rhs));\n        return name;\n    }\n    // `const` declaration (`var` in es5 mode)\n    const(nameOrPrefix, rhs, _constant) {\n        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);\n    }\n    // `let` declaration with optional assignment (`var` in es5 mode)\n    let(nameOrPrefix, rhs, _constant) {\n        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);\n    }\n    // `var` declaration with optional assignment\n    var(nameOrPrefix, rhs, _constant) {\n        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);\n    }\n    // assignment code\n    assign(lhs, rhs, sideEffects) {\n        return this._leafNode(new Assign(lhs, rhs, sideEffects));\n    }\n    // `+=` code\n    add(lhs, rhs) {\n        return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));\n    }\n    // appends passed SafeExpr to code or executes Block\n    code(c) {\n        if (typeof c == \"function\")\n            c();\n        else if (c !== code_1.nil)\n            this._leafNode(new AnyCode(c));\n        return this;\n    }\n    // returns code for object literal for the passed argument list of key-value pairs\n    object(...keyValues) {\n        const code = [\"{\"];\n        for (const [key, value] of keyValues) {\n            if (code.length > 1)\n                code.push(\",\");\n            code.push(key);\n            if (key !== value || this.opts.es5) {\n                code.push(\":\");\n                (0, code_1.addCodeArg)(code, value);\n            }\n        }\n        code.push(\"}\");\n        return new code_1._Code(code);\n    }\n    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)\n    if(condition, thenBody, elseBody) {\n        this._blockNode(new If(condition));\n        if (thenBody && elseBody) {\n            this.code(thenBody).else().code(elseBody).endIf();\n        }\n        else if (thenBody) {\n            this.code(thenBody).endIf();\n        }\n        else if (elseBody) {\n            throw new Error('CodeGen: \"else\" body without \"then\" body');\n        }\n        return this;\n    }\n    // `else if` clause - invalid without `if` or after `else` clauses\n    elseIf(condition) {\n        return this._elseNode(new If(condition));\n    }\n    // `else` clause - only valid after `if` or `else if` clauses\n    else() {\n        return this._elseNode(new Else());\n    }\n    // end `if` statement (needed if gen.if was used only with condition)\n    endIf() {\n        return this._endBlockNode(If, Else);\n    }\n    _for(node, forBody) {\n        this._blockNode(node);\n        if (forBody)\n            this.code(forBody).endFor();\n        return this;\n    }\n    // a generic `for` clause (or statement if `forBody` is passed)\n    for(iteration, forBody) {\n        return this._for(new ForLoop(iteration), forBody);\n    }\n    // `for` statement for a range of values\n    forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {\n        const name = this._scope.toName(nameOrPrefix);\n        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));\n    }\n    // `for-of` statement (in es5 mode replace with a normal for loop)\n    forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {\n        const name = this._scope.toName(nameOrPrefix);\n        if (this.opts.es5) {\n            const arr = iterable instanceof code_1.Name ? iterable : this.var(\"_arr\", iterable);\n            return this.forRange(\"_i\", 0, (0, code_1._) `${arr}.length`, (i) => {\n                this.var(name, (0, code_1._) `${arr}[${i}]`);\n                forBody(name);\n            });\n        }\n        return this._for(new ForIter(\"of\", varKind, name, iterable), () => forBody(name));\n    }\n    // `for-in` statement.\n    // With option `ownProperties` replaced with a `for-of` loop for object keys\n    forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {\n        if (this.opts.ownProperties) {\n            return this.forOf(nameOrPrefix, (0, code_1._) `Object.keys(${obj})`, forBody);\n        }\n        const name = this._scope.toName(nameOrPrefix);\n        return this._for(new ForIter(\"in\", varKind, name, obj), () => forBody(name));\n    }\n    // end `for` loop\n    endFor() {\n        return this._endBlockNode(For);\n    }\n    // `label` statement\n    label(label) {\n        return this._leafNode(new Label(label));\n    }\n    // `break` statement\n    break(label) {\n        return this._leafNode(new Break(label));\n    }\n    // `return` statement\n    return(value) {\n        const node = new Return();\n        this._blockNode(node);\n        this.code(value);\n        if (node.nodes.length !== 1)\n            throw new Error('CodeGen: \"return\" should have one node');\n        return this._endBlockNode(Return);\n    }\n    // `try` statement\n    try(tryBody, catchCode, finallyCode) {\n        if (!catchCode && !finallyCode)\n            throw new Error('CodeGen: \"try\" without \"catch\" and \"finally\"');\n        const node = new Try();\n        this._blockNode(node);\n        this.code(tryBody);\n        if (catchCode) {\n            const error = this.name(\"e\");\n            this._currNode = node.catch = new Catch(error);\n            catchCode(error);\n        }\n        if (finallyCode) {\n            this._currNode = node.finally = new Finally();\n            this.code(finallyCode);\n        }\n        return this._endBlockNode(Catch, Finally);\n    }\n    // `throw` statement\n    throw(error) {\n        return this._leafNode(new Throw(error));\n    }\n    // start self-balancing block\n    block(body, nodeCount) {\n        this._blockStarts.push(this._nodes.length);\n        if (body)\n            this.code(body).endBlock(nodeCount);\n        return this;\n    }\n    // end the current self-balancing block\n    endBlock(nodeCount) {\n        const len = this._blockStarts.pop();\n        if (len === undefined)\n            throw new Error(\"CodeGen: not in self-balancing block\");\n        const toClose = this._nodes.length - len;\n        if (toClose < 0 || (nodeCount !== undefined && toClose !== nodeCount)) {\n            throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);\n        }\n        this._nodes.length = len;\n        return this;\n    }\n    // `function` heading (or definition if funcBody is passed)\n    func(name, args = code_1.nil, async, funcBody) {\n        this._blockNode(new Func(name, args, async));\n        if (funcBody)\n            this.code(funcBody).endFunc();\n        return this;\n    }\n    // end function definition\n    endFunc() {\n        return this._endBlockNode(Func);\n    }\n    optimize(n = 1) {\n        while (n-- > 0) {\n            this._root.optimizeNodes();\n            this._root.optimizeNames(this._root.names, this._constants);\n        }\n    }\n    _leafNode(node) {\n        this._currNode.nodes.push(node);\n        return this;\n    }\n    _blockNode(node) {\n        this._currNode.nodes.push(node);\n        this._nodes.push(node);\n    }\n    _endBlockNode(N1, N2) {\n        const n = this._currNode;\n        if (n instanceof N1 || (N2 && n instanceof N2)) {\n            this._nodes.pop();\n            return this;\n        }\n        throw new Error(`CodeGen: not in block \"${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}\"`);\n    }\n    _elseNode(node) {\n        const n = this._currNode;\n        if (!(n instanceof If)) {\n            throw new Error('CodeGen: \"else\" without \"if\"');\n        }\n        this._currNode = n.else = node;\n        return this;\n    }\n    get _root() {\n        return this._nodes[0];\n    }\n    get _currNode() {\n        const ns = this._nodes;\n        return ns[ns.length - 1];\n    }\n    set _currNode(node) {\n        const ns = this._nodes;\n        ns[ns.length - 1] = node;\n    }\n}\nexports.CodeGen = CodeGen;\nfunction addNames(names, from) {\n    for (const n in from)\n        names[n] = (names[n] || 0) + (from[n] || 0);\n    return names;\n}\nfunction addExprNames(names, from) {\n    return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;\n}\nfunction optimizeExpr(expr, names, constants) {\n    if (expr instanceof code_1.Name)\n        return replaceName(expr);\n    if (!canOptimize(expr))\n        return expr;\n    return new code_1._Code(expr._items.reduce((items, c) => {\n        if (c instanceof code_1.Name)\n            c = replaceName(c);\n        if (c instanceof code_1._Code)\n            items.push(...c._items);\n        else\n            items.push(c);\n        return items;\n    }, []));\n    function replaceName(n) {\n        const c = constants[n.str];\n        if (c === undefined || names[n.str] !== 1)\n            return n;\n        delete names[n.str];\n        return c;\n    }\n    function canOptimize(e) {\n        return (e instanceof code_1._Code &&\n            e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== undefined));\n    }\n}\nfunction subtractNames(names, from) {\n    for (const n in from)\n        names[n] = (names[n] || 0) - (from[n] || 0);\n}\nfunction not(x) {\n    return typeof x == \"boolean\" || typeof x == \"number\" || x === null ? !x : (0, code_1._) `!${par(x)}`;\n}\nexports.not = not;\nconst andCode = mappend(exports.operators.AND);\n// boolean AND (&&) expression with the passed arguments\nfunction and(...args) {\n    return args.reduce(andCode);\n}\nexports.and = and;\nconst orCode = mappend(exports.operators.OR);\n// boolean OR (||) expression with the passed arguments\nfunction or(...args) {\n    return args.reduce(orCode);\n}\nexports.or = or;\nfunction mappend(op) {\n    return (x, y) => (x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._) `${par(x)} ${op} ${par(y)}`);\n}\nfunction par(x) {\n    return x instanceof code_1.Name ? x : (0, code_1._) `(${x})`;\n}\n//# sourceMappingURL=index.js.map"],"names":["Object","defineProperty","exports","value","codegen_1","util_1","def","keyword","schemaType","trackErrors","error","message","params","str","ifClause","_","code","cxt","gen","parentSchema","it","undefined","then","else","checkStrictMode","hasThen","hasSchema","hasElse","valid","let","schValid","name","schCxt","subschema","compositeRule","createErrors","allErrors","mergeEvaluated","validateIf","reset","setParams","if","validateClause","not","assign","mergeValidEvaluated","pass","schema","alwaysValidSchema","CodeGen","Name","nil","stringify","KeywordCxt","validate_1","enumerable","get","validation_error_1","ref_error_1","rules_1","compile_1","codegen_2","resolve_1","dataType_1","$dataRefSchema","uri_1","defaultRegExp","flags","RegExp","META_IGNORE_OPTIONS","EXT_SCOPE_NAMES","Set","removedOptions","errorDataPath","format","nullable","jsonPointers","extendRefs","missingRefs","processCode","sourceCode","strictDefaults","strictKeywords","uniqueItems","unknownFormats","cache","serialize","ajvErrors","deprecatedOptions","ignoreKeywordsWithRef","jsPropertySyntax","unicode","requiredOptions","o","_a","_b","_c","_d","_e","_f","_g","_h","_j","_k","_l","_m","_o","_p","_q","_r","_s","_t","_u","_v","_w","_x","_y","_z","_0","s","strict","_optz","optimize","regExp","uriResolver","default","strictSchema","strictNumbers","strictTypes","strictTuples","strictRequired","loopRequired","loopEnum","meta","messages","inlineRefs","schemaId","addUsedSchema","validateSchema","validateFormats","unicodeRegExp","int32range","Ajv","constructor","opts","this","schemas","refs","formats","_compilations","_loading","_cache","Map","es5","lines","scope","ValueScope","prefixes","logger","noLogs","console","log","warn","Error","getLogger","formatOpt","RULES","getRules","checkOptions","call","_metaOpts","getMetaSchemaOptions","addInitialFormats","_addVocabularies","_addDefaultMetaSchema","keywords","addInitialKeywords","addMetaSchema","addInitialSchemas","addKeyword","$data","_dataRefSchema","id","$id","defaultMeta","validate","schemaKeyRef","data","v","getSchema","compile","errors","_meta","sch","_addSchema","_compileSchemaEnv","compileAsync","loadSchema","runCompileAsync","async","_schema","loadMetaSchema","$schema","_compileAsync","$ref","e","checkLoaded","loadMissingSchema","missingSchema","ref","missingRef","_loadSchema","addSchema","p","key","_validateSchema","Array","isArray","normalizeId","_checkUnique","throwOrLogError","errorsText","keyRef","getSchEnv","root","SchemaEnv","resolveSchema","removeSchema","_removeAllSchemas","clear","delete","cacheKey","addVocabulary","definitions","kwdOrDef","length","checkKeyword","eachItem","kwd","addRule","keywordMetaschema","definition","type","getJSONTypes","k","forEach","t","getKeyword","rule","all","removeKeyword","group","rules","i","findIndex","splice","addFormat","separator","dataVar","map","instancePath","reduce","text","msg","$dataMetaSchema","metaSchema","keywordsJsonPointers","JSON","parse","jsonPointer","segments","split","slice","seg","schemaOrData","regex","test","baseId","jtd","localRefs","getSchemaRefs","set","startsWith","_compileMetaSchema","compileSchema","currentOpts","checkOpts","options","opt","optsSchemas","defs","metaOpts","ValidationError","MissingRefError","KEYWORD_NAME","dataType","post","ruleGroup","find","push","before","addBeforeRule","implements","_rule","$dataRef","anyOf","assignDefaults","assignDefault","prop","defaultValue","childData","getProperty","condition","useDefaults","ty","properties","items","shouldUseGroup","some","shouldUseRule","schemaHasRulesForType","self","types","reportTypeError","checkDataTypes","checkDataType","coerceAndCheckDataType","getSchemaTypes","DataType","applicability_1","errors_1","ts","every","isJSONType","join","includes","coerceTo","coerceTypes","filter","COERCIBLE","has","coerceToTypes","checkTypes","wrongType","Wrong","coerced","coerceSpecificType","elseIf","endIf","parentData","parentDataProperty","expr","assignParentData","coerceData","strictNums","correct","Correct","EQ","operators","NEQ","cond","numCond","_cond","and","dataTypes","toHash","array","object","notObj","null","number","integer","typeError","schemaValue","schemaCode","schemaRefOrVal","getTypeErrorContext","reportError","jsonTypes","x","groups","string","boolean","min","max","minContains","maxContains","next","len","const","fail","validateItemsWithCount","count","validateItems","break","checkLimits","_valid","block","forRange","dataProp","dataPropType","Type","Num","result","dynamicAnchor_1","dynamicAnchor","var","from","ok","super","ajv","validation","callRef","getValidate","code_1","names_1","schemaEnv","env","validateName","$async","rootName","scopeValue","callRootRef","schOrEnv","resolveRef","callValidate","schName","source","schemaPath","topSchemaRef","errSchemaPath","inlineRefSchema","passCxt","passContext","addErrorsFrom","errs","vErrors","addEvaluatedFrom","unevaluated","schEvaluated","evaluated","props","dynamicProps","dynamicItems","try","callValidateCode","throw","callAsyncRef","validateAdditionalItems","validateUnion","validateArray","usePattern","schemaProperties","allSchemaProperties","noPropertyInData","propertyInData","isOwnProperty","hasPropFunc","reportMissingProp","checkMissingProp","checkReportMissingProp","util_2","prototype","hasOwnProperty","property","ownProperties","or","schemaMap","keys","missingProperty","missing","errorPath","func","context","passSchema","dataAndSchema","valCxt","strConcat","rootData","dynamicRef","dynamicAnchors","args","newRegExp","pattern","u","rx","toString","useFunc","validArr","notValid","_sch","schemaProp","propertyName","forIn","validateTuple","extraItems","schArr","l","fullTuple","minItems","maxItems","checkStrictTuple","dynamicRef_1","extendSubschemaMode","extendSubschemaData","getSubschema","escapeFragment","dpType","dataPathArr","dataContextProps","getErrorPath","_nextData","dataLevel","definedProperties","dataNames","jtdDiscriminator","jtdMetadata","dependentRequired_1","dependentSchemas_1","limitContains_1","equal_1","fail$data","useLoop","eql","getEql","block$data","forOf","vSchema","equalCode","boolOrEmptySchema","topBoolOrEmptySchema","boolError","falseSchemaError","overrideAllErrors","return","dependencies_1","validatePropertyDeps","contains","ref_1","anchor","_dynamicRef","_callRef","validateKeywordUsage","validSchemaType","funcKeywordCode","macroKeywordCode","modifyData","useKeyword","macroSchema","macro","schemaRef","checkAsyncKeyword","validateRef","assignValid","_await","modifying","reportErrs","ruleErrs","validateAsync","validateErrs","validateSync","extendErrors","addErrs","allowUndefined","st","deps","dependencies","loopAllRequired","allErrorsMode","loopUntilMissing","exitOnErrorMode","requiredKey","comp","op","GT","LT","resolver","resolveUrl","getFullPath","validateSchemaDeps","types_1","discrError","tagName","DiscrError","Tag","tag","oneOf","discriminator","mapping","applyTagSchema","oneOfMapping","topRequired","hasRequired","tagRequired","schemaHasRulesButRef","propSch","addMappings","required","addMapping","enum","tagValue","getMapping","Mapping","validateMapping","additionalProperty","errsCount","removeAdditional","patProps","patternProperties","deleteAdditional","additionalPropertyCode","applyAdditionalSchema","Str","definedProp","propsSchema","isAdditional","additionalProperties_1","additionalProperties","allProps","add","hasDefault","applyPropertySchema","regexpCode","getEsmExportName","safeStringify","addCodeArg","_Code","IDENTIFIER","_CodeOrName","emptyStr","names","_items","item","_str","c","_names","strs","plus","res","mergeExprItems","arg","a","b","replace","c1","c2","json","jsonPos","jsonLen","jsonPart","patterns","alwaysValidPatterns","checkProperties","allowMatchingProperties","evaluatedPropsToName","checkMatchingProperties","pat","validateProperties","alwaysValid","validatePatternProperties","resetErrorsCount","reportExtraError","keyword$DataError","keywordError","addError","errObj","err","returnErrors","errorPaths","errorObjectCode","verbose","E","keyValues","errorInstancePath","errorSchemaPath","extraErrorProps","errorObject","instPath","schPath","ucs2length","pos","charCodeAt","uri","additionalItems_1","prefixItems_1","items_1","items2020_1","contains_1","propertyNames_1","properties_1","patternProperties_1","not_1","anyOf_1","oneOf_1","allOf_1","if_1","thenElse_1","draft2020","applicator","ValueScopeName","Scope","varKinds","UsedValueState","ValueError","parent","_prefixes","_parent","toName","nameOrPrefix","prefix","_newName","_nameGroup","index","nameStr","setValue","itemIndex","scopePath","line","_values","_scope","_n","valueKey","vs","_name","getValue","keyOrRef","scopeRefs","scopeName","values","_reduceValues","scopeCode","usedValues","getCode","valueCode","nameSet","Started","Completed","failResult","j","itemTypes","loopN","indices","for","loopN2","outer","label","getData","validateFunctionCode","boolSchema_1","dataType_2","defaults_1","keyword_1","subschema_1","validateFunction","body","funcSourceUrl","destructureValCxtES5","destructureValCxt","schId","process","schemaCxtHasRules","isSchemaObj","checkKeywords","checkUnknownRules","checkRefsAndKeywords","typeAndKeywords","schemaKeywords","commentKeyword","$comment","typeErrors","groupKeywords","iterateKeywords","includesType","strictTypesError","withTypes","narrowSchemaTypes","checkContextTypes","allowUnionTypes","checkMultipleTypes","hasApplicableType","kwdT","schTs","checkKeywordTypes","checkStrictTypes","keywordCode","checkNoDefault","resetEvaluated","assignEvaluated","returnResults","topSchemaObjCode","successAction","failAction","invalid$data","append","errorParams","_error","$dataError","obj","codeBlock","$dataValid","check$data","wrong$DataType","validateSchemaRef","invalid$DataSchema","appl","nextContext","updateContext","checkAsyncSchema","subSchemaObjCode","subschemaCode","schemaCxt","ruleType","JSON_POINTER","RELATIVE_JSON_POINTER","matches","exec","up","errorMsg","segment","unescapeJsonPointer","pointerType","core_1","draft7_1","discriminator_1","draft7MetaSchema","META_SUPPORT_DATA","META_SCHEMA_ID","module","prec","multipleOfPrecision","invalid","recursiveAnchor_1","recursiveRef_1","dynamic","_getFullPath","inlineRef","equal","traverse","SIMPLE_INLINED","limit","hasRef","countKeys","REF_KEYWORDS","Infinity","normalize","TRAILING_SLASH_HASH","resolve","ANCHOR","baseIds","pathPrefix","schemaRefs","allKeys","jsonPtr","parentJsonPtr","fullPath","innerBaseId","addRef","_resolve","ambiguos","schOrRef","checkAmbiguosRef","addAnchor","$anchor","$dynamicAnchor","sch1","sch2","limitNumber_1","multipleOf_1","limitLength_1","pattern_1","limitProperties_1","required_1","limitItems_1","uniqueItems_1","const_1","enum_1","contentVocabulary","metadataVocabulary","content","core","metadata","with$data","id_1","_getValidate","unevaluatedProperties_1","unevaluatedItems_1","getCompilingSchema","rootId","_ValidationError","validateCode","Function","makeValidate","scopeValues","inlineOrCompile","schEnv","s2","s1","refPath","getJsonPointer","schOrFunc","PREVENT_SCOPE_CHANGE","parsedRef","fragment","part","partSchema","unescapeFragment","ops","KWDs","maximum","okStr","LTE","minimum","GTE","exclusiveMaximum","exclusiveMinimum","ucs2length_1","unevaluatedProperty","unevaluatedPropCode","evaluatedProps","unevaluatedDynamic","ps","unevaluatedStatic","depsCount","property_ies","propDeps","schDeps","propertyDeps","schemaDeps","splitDependencies","hasProperty","depProp","validation_1","applicator_1","format_1","metadata_1","draft7Vocabularies","prefixItems","setEvaluated","escapeJsonPointer","schemaHasRules","makeMergeEvaluated","mergeNames","mergeToName","mergeValues","resultToName","to","arr","hash","decodeURIComponent","encodeURIComponent","xs","f","Math","snippets","mode","isNumber","Ajv2019","dynamic_1","next_1","unevaluated_1","json_schema_2019_09_1","fmts","fDef","fType","callFormat","validData","invalidFmt","validate$DataFormat","formatDef","unknownMsg","unknownFormat","fmtType","fmtRef","fmtDef","fmt","getFormat","validCondition","validateFormat","passing","scope_1","code_2","scope_2","NOT","OR","AND","ADD","Node","optimizeNodes","optimizeNames","_constants","Def","varKind","rhs","render","constants","optimizeExpr","Assign","lhs","sideEffects","addExprNames","AssignOp","Label","Break","Throw","AnyCode","ParentNode","nodes","n","subtractNames","addNames","BlockNode","Root","Else","kind","If","ns","For","ForLoop","iteration","ForRange","ForIter","loop","iterable","Func","Return","Try","catch","finally","Catch","Finally","replaceName","par","extScope","_blockStarts","_extScope","_nodes","_root","prefixOrName","getScopeValue","_def","constant","_leafNode","_constant","thenBody","elseBody","_blockNode","_elseNode","_endBlockNode","_for","node","forBody","endFor","tryBody","catchCode","finallyCode","_currNode","nodeCount","endBlock","pop","toClose","funcBody","endFunc","N1","N2","andCode","mappend","orCode","y"],"sourceRoot":""}