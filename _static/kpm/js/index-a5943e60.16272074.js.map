{"version":3,"file":"js/index-a5943e60.16272074.js","mappings":"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","sources":["webpack://pipeline-manager/./src/core/Clipboard.ts","webpack://pipeline-manager/./src/core/InterfaceTypes.js","webpack://pipeline-manager/./src/core/ConnectionRenderer.js","webpack://pipeline-manager/./src/core/EditorManager.js","webpack://pipeline-manager/./src/core/History.ts","webpack://pipeline-manager/./src/core/LayoutManager.js"],"sourcesContent":["/*\n * Copyright (c) 2022-2024 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n/*\nThe baklavajs functionality was fully copied to this file, as the original\nimplementation is not exported and cannot be integrated with custom history\nas the Commands have been replaced.\n\nThe original source is slightly adjusted to integrate with the customized history\nand the new command handler\n*/\nimport { computed, reactive, ref, } from 'vue';\nimport { v4 as uuidv4 } from 'uuid';\nimport { useViewModel, } from '@baklavajs/renderer-vue';\nimport { startTransaction, commitTransaction, } from './History.ts';\nimport { removeNode } from '../custom/CustomNode.js';\nexport const COPY_COMMAND = 'COPY';\nexport const DELETE_COMMAND = 'DELETE';\nexport const UNHIGHLIGHT_COMMAND = 'UNHIGHLIGHT';\nexport const PASTE_COMMAND = 'PASTE';\nexport const CLEAR_CLIPBOARD_COMMAND = 'CLEAR_CLIPBOARD';\nexport function useClipboard(displayedGraph, editor, commandHandler) {\n    const token = Symbol('ClipboardToken');\n    const nodeBuffer = ref('');\n    const connectionBuffer = ref('');\n    const consecutivePasteNumber = ref(0);\n    const isEmpty = computed(() => !nodeBuffer.value);\n    const clear = () => {\n        nodeBuffer.value = '';\n        connectionBuffer.value = '';\n    };\n    const copy = () => {\n        // find all connections from and to the selected nodes\n        const interfacesOfSelectedNodes = displayedGraph.value.selectedNodes.flatMap((n) => [\n            ...Object.values(n.inputs),\n            ...Object.values(n.outputs),\n        ]);\n        const connections = displayedGraph.value.connections\n            .filter((conn) => interfacesOfSelectedNodes.includes(conn.from) ||\n            interfacesOfSelectedNodes.includes(conn.to))\n            .map((conn) => ({ from: conn.from.id, to: conn.to.id }));\n        connectionBuffer.value = JSON.stringify(connections);\n        nodeBuffer.value = JSON.stringify(displayedGraph.value.selectedNodes.map((n) => n.save()));\n        consecutivePasteNumber.value = 0;\n    };\n    const del = () => {\n        const { viewModel } = useViewModel();\n        if (viewModel.value.editor.readonly)\n            return;\n        startTransaction();\n        displayedGraph.value.selectedNodes.forEach((node) => {\n            removeNode(node);\n        });\n        commitTransaction();\n    };\n    const findInterface = (nodes, id, io) => {\n        for (let i = 0; i < nodes.length; i += 1) {\n            let intf;\n            if (!io || io === 'input') {\n                intf = Object.values(nodes[i].inputs).find((iface) => iface.id === id);\n            }\n            if (!intf && (!io || io === 'output')) {\n                intf = Object.values(nodes[i].outputs).find((iface) => iface.id === id);\n            }\n            if (intf) {\n                return intf;\n            }\n        }\n        return undefined;\n    };\n    const paste = () => {\n        var _a;\n        const { viewModel } = useViewModel();\n        if (isEmpty.value || viewModel.value.editor.readonly) {\n            return;\n        }\n        startTransaction();\n        const movementStep = (_a = viewModel.value.movementStep) !== null && _a !== void 0 ? _a : 1;\n        // Map old IDs to new IDs\n        const idmap = new Map();\n        const parsedNodeBuffer = JSON.parse(nodeBuffer.value);\n        const parsedConnectionBuffer = JSON.parse(connectionBuffer.value);\n        const newNodes = [];\n        const newConnections = [];\n        const graph = displayedGraph.value;\n        commandHandler.executeCommand('START_TRANSACTION');\n        for (let i = 0; i < parsedNodeBuffer.length; i += 1) {\n            const nodeType = editor.value.nodeTypes.get(parsedNodeBuffer[i].name);\n            if (!nodeType) {\n                return;\n            }\n            /* eslint-disable-next-line new-cap */\n            let copiedNode = new nodeType.type();\n            newNodes.push(copiedNode);\n            copiedNode.hooks.beforeLoad.subscribe(token, (nodeState) => {\n                const ns = nodeState;\n                if (ns.position) {\n                    consecutivePasteNumber.value += 1;\n                    ns.position.x += consecutivePasteNumber.value * Math.max(40, movementStep);\n                    ns.position.y += consecutivePasteNumber.value * Math.max(40, movementStep);\n                }\n                if (parsedNodeBuffer[i].graphState !== undefined) {\n                    parsedNodeBuffer[i].graphState.nodes.forEach((n) => {\n                        /* eslint-disable-next-line no-param-reassign */\n                        if (n.type !== undefined)\n                            n.name = n.type;\n                    });\n                }\n                copiedNode.hooks.beforeLoad.unsubscribe(token);\n                return ns;\n            });\n            copiedNode = graph.addNode(copiedNode);\n            const mapNewId = (obj) => {\n                /* eslint-disable no-param-reassign */\n                const newId = uuidv4();\n                idmap.set(obj.id, newId);\n                obj.id = newId;\n            };\n            const assignNewIds = (node) => {\n                /* eslint-disable no-param-reassign */\n                // New node id\n                mapNewId(node);\n                if (node.graphState !== undefined) {\n                    mapNewId(node.graphState);\n                    node.graphState.nodes.forEach((subNode) => {\n                        assignNewIds(subNode);\n                    });\n                    // If it is a subgraph node, then some interfaces have to have the same IDs\n                    // as the ones in the subgraph\n                    node.interfaces.forEach((intf) => {\n                        var _a;\n                        intf.id = (_a = idmap.get(intf.id)) !== null && _a !== void 0 ? _a : intf.id;\n                        // If the node has any external interfaces, then their names have\n                        // to be resolved as they cannot conflict with the existing ones.\n                        if (intf.externalName !== undefined) {\n                            intf.externalName = graph.resolveNewExposedName(intf.externalName);\n                        }\n                    });\n                    node.graphState.connections.forEach((conn) => {\n                        if (idmap.get(conn.from) === undefined ||\n                            idmap.get(conn.to) === undefined) {\n                            throw new Error('Error when executing copy and paste. ' +\n                                `Connection from interface ${conn.from} to ${conn.to} is invalid`);\n                        }\n                        conn.from = idmap.get(conn.from);\n                        conn.to = idmap.get(conn.to);\n                    });\n                }\n                else {\n                    // If it is a regular node, then interfaces need new IDs.\n                    node.interfaces.forEach((intf) => {\n                        mapNewId(intf);\n                        // If the node has any external interfaces, then their names have\n                        // to be resolved as they cannot conflict with the existing ones.\n                        if (intf.externalName !== undefined) {\n                            intf.externalName = graph.resolveNewExposedName(intf.externalName);\n                        }\n                    });\n                }\n            };\n            assignNewIds(parsedNodeBuffer[i]);\n            copiedNode.load(Object.assign(Object.assign({}, parsedNodeBuffer[i]), { id: copiedNode.id }));\n            // If the pasted graph was inside of a graph node, then the graph node has to\n            // have its exposed interfaces refreshed\n            if (displayedGraph.value.graphNode !== undefined) {\n                displayedGraph.value.graphNode.updateExposedInterfaces();\n            }\n        }\n        for (let i = 0; i < parsedConnectionBuffer.length; i += 1) {\n            const fromId = idmap.get(parsedConnectionBuffer[i].from);\n            const toId = idmap.get(parsedConnectionBuffer[i].to);\n            if (fromId && toId) {\n                const fromIntf = findInterface(newNodes, fromId, 'output');\n                const toIntf = findInterface(newNodes, toId, 'input');\n                if (fromIntf && toIntf) {\n                    const newConnection = graph.addConnection(fromIntf, toIntf);\n                    if (newConnection) {\n                        newConnections.push(newConnection);\n                    }\n                }\n            }\n        }\n        commitTransaction();\n        /* eslint-disable-next-line consistent-return */\n        return {\n            newNodes,\n            newConnections,\n        };\n    };\n    commandHandler.registerCommand(DELETE_COMMAND, {\n        canExecute: () => displayedGraph.value.selectedNodes.length > 0,\n        execute: del,\n    });\n    commandHandler.registerHotkey(['Delete'], DELETE_COMMAND);\n    commandHandler.registerCommand(UNHIGHLIGHT_COMMAND, {\n        canExecute: () => true,\n        execute: () => {\n            displayedGraph.value.selectedNodes = []; // eslint-disable-line no-param-reassign\n        },\n    });\n    commandHandler.registerHotkey(['Escape'], UNHIGHLIGHT_COMMAND);\n    commandHandler.registerCommand(COPY_COMMAND, {\n        canExecute: () => true,\n        execute: copy,\n    });\n    commandHandler.registerHotkey(['Control', 'c'], COPY_COMMAND);\n    commandHandler.registerCommand(PASTE_COMMAND, {\n        canExecute: () => !isEmpty.value,\n        execute: paste,\n    });\n    commandHandler.registerHotkey(['Control', 'v'], PASTE_COMMAND);\n    commandHandler.registerCommand(CLEAR_CLIPBOARD_COMMAND, {\n        canExecute: () => true,\n        execute: clear,\n    });\n    return reactive({ isEmpty });\n}\n","/*\n * Copyright (c) 2022-2024 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n *\n */\n\n/* eslint-disable class-methods-use-this */\nexport default class BaklavaInterfaceTypes {\n    types = new Map();\n\n    defaultStyle = {\n        interfaceConnectionPattern: 'solid',\n        interfaceConnectionColor: '#FFFFFF', // $white\n        interfaceColor: '#00E58D', // $green\n    };\n\n    /**\n     * Initialize Interface types instance used to manager styles of interfaces and connections\n     * and validate adding connections.\n     */\n    constructor(viewPlugin) {\n        viewPlugin.hooks.renderInterface.subscribe(this, ({ intf, el }) => {\n            if (intf.type) {\n                const types = this.normalizeType(intf.type);\n                const firstType = types.find((t) => this.types[t]?.interfaceColor !== undefined);\n\n                if (firstType !== undefined) {\n                    const color = this.types[firstType].interfaceColor;\n                    const arrow = el.querySelector('.__port:not(.greyedout_arrow)'); // eslint-disable-line no-param-reassign\n                    if (arrow !== null) arrow.style.backgroundColor = color;\n                    else {\n                        const greyArrow = el.querySelector('.__port');\n                        if (greyArrow !== null) {\n                            greyArrow.style.backgroundColor =\n                                getComputedStyle(greyArrow).getPropertyValue('$gray-500');\n                        }\n                    }\n                }\n            }\n\n            return { intf, el };\n        });\n    }\n\n    normalizeType(type) {\n        return typeof type === 'string' || type instanceof String ? [type] : type;\n    }\n\n    /**\n     * Returns connection style for a given from and to interfaces.\n     * It takes style of a common type of those interfaces and completes its missing values\n     * with default ones. If there are multiple common types, a default style is returned.\n     *\n     * If there is no `to` interface then a style for `from` interface is returned.\n     * Again with completed missing values.\n     *\n     * @param {Interface} from connection source\n     * @param {Interface} to connection target\n     * @returns style for a defined connection\n     */\n    getConnectionStyle(from, to) {\n        const fromTypes = this.normalizeType(from?.type);\n        const toTypes = this.normalizeType(to?.type);\n\n        if (from?.type === undefined) {\n            return this.defaultStyle;\n        }\n\n        if (to?.type === undefined) {\n            const firstType = fromTypes.find((t) => this.types[t] !== undefined);\n            return { ...this.defaultStyle, ...this.types[firstType] };\n        }\n\n        const commonTypes = fromTypes.filter((t) => toTypes.includes(t));\n        if (Array.isArray(commonTypes) && commonTypes.length > 1) {\n            return this.defaultStyle;\n        }\n\n        const firstType = commonTypes.find((t) => this.types[t] !== undefined);\n        return { ...this.defaultStyle, ...this.types[firstType] };\n    }\n\n    /**\n     * Function that reads all nodes in the specification and creates `NodeInterfaceType` objects\n     * for their inputs' and outputs' types so that a simple validation based on those\n     * types can be performed.\n     *\n     * The read interface types are stored in `interfaceTypes` object which is returned by\n     * this function\n     * @param {*} metadata metadata containing information about styling\n     * @returns read interface types\n     */\n    readInterfaceTypes(metadata) {\n        this.types = {};\n        if (metadata?.interfaces) {\n            Object.entries(metadata.interfaces).forEach(([type, io]) => {\n                this.types[type] = { ...io, name: type };\n            });\n        }\n    }\n}\n","/*\n * Copyright (c) 2022-2024 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Handles calculation of a SVG path a connection should have based on it's characteristic\n * (for example loopback) and style. It is handled by `ConnectionRenderer`, which\n * deals with saving the style user has chosen and delegating away the calculation to\n * suitable renderer\n */\n\n/* eslint-disable max-classes-per-file */\n\n/**\n * Retrieves top point of a node based on it's DOM element If the element does not yet exists,\n * returns 0\n *\n * @param interfaceRef interface reference\n * @param scaling number from viewModel defining the scaling of canvas\n * @param panning (x, y) point from viewModel defining the translation of canvas\n * @returns Y coordinate of a bottom of a node, adjusted for canvas transformation\n */\n/* eslint-disable no-unused-vars */\nfunction nodeTopPoint(interfaceRef, scaling, panning) {\n    const nodeHtml = document.getElementById(interfaceRef.nodeId);\n    const nodeTop = nodeHtml ? nodeHtml.offsetTop : 0;\n    return (nodeTop + panning.y) * scaling;\n}\n\n/**\n * Used for loopback connections, calculates the y coordinate of a bottom point of a node\n * based on it's DOM element. If the element does not yet exists, returns 0\n *\n * @param interfaceRef interface reference\n * @param scaling number from viewModel defining the scaling of canvas\n * @param panning (x, y) point from viewModel defining the translation of canvas\n * @returns Y coordinate of a bottom of a node, adjusted for canvas transformation\n */\nfunction nodeBottomPoint(interfaceRef, scaling, panning) {\n    const nodeHtml = document.getElementById(interfaceRef.nodeId);\n    const nodeBottom = nodeHtml ? nodeHtml.offsetTop + nodeHtml.offsetHeight : 0;\n    return (nodeBottom + panning.y) * scaling;\n}\n\n/**\n * Utility function that calculates the x and y radius of an ellipse given center point and\n * a slope at a specified point\n *\n * @param x X coordinate of a point on an ellipse\n * @param y Y coordinate of a point on an ellipse\n * @param cx X coordinate of a center point\n * @param cy Y coordinate of a center point\n * @param slope dy/dx value on a (x, y) point\n * @returns Array of two elements: radius parallel to x axis and y axis respectively\n */\nfunction calculateEllipseR(x, y, cx, cy, slope) {\n    const rx = Math.sqrt(Math.abs((x - cx) * (x - cx) + ((x - cx) * (y - cy)) / slope));\n    const ry = Math.sqrt(Math.abs((y - cy) * (y - cy) + (y - cy) * (x - cx) * slope));\n    return [rx, ry];\n}\n\nclass NormalizedConnection {\n    /**\n     * Class that makes sure that the connection is in correct order, which means that from and to\n     * sockets and their coordinates are properly set.\n     */\n    constructor(x1, y1, x2, y2, connection) {\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2;\n        this.y2 = y2;\n        this.from = connection.from;\n        if (connection.to) {\n            this.to = connection.to;\n            if (\n                (this.from.direction === 'input' && this.to.direction === 'output') ||\n                (this.from.direction === 'input' && this.to.direction === 'inout') ||\n                (this.from.direction === 'inout' && this.to.direction === 'output')\n            ) {\n                [this.x1, this.x2, this.y1, this.y2] = [this.x2, this.x1, this.y2, this.y1];\n                [this.from, this.to] = [this.to, this.from];\n            }\n        }\n    }\n}\n\nexport default class ConnectionRenderer {\n    style = 'curved';\n\n    viewModel = null;\n\n    randomizedOffset = false;\n\n    shiftDistance = 15;\n\n    /**\n     * Defines the shift the connection should have compared to the default position based on the\n     * index of the `from` interface and `to` interface bound to the connection in the nodes.\n     * It allows to make a visual distinction between connections going to different interfaces\n     * in the same node. The value of the shift is constant distance times the index of an\n     * interface, adjusted for any canvas transformation\n     * This funnction is symmetrical.\n     *\n     * @param ncFrom from node reference\n     * @param ncTo to node reference\n     * @param graph the graph definition\n     * @param scaling number from viewModel defining the scaling of canvas\n     * @returns Value the connection should shift from it's default position\n     */\n    getShift(ncFrom, ncTo, graph, scaling) {\n        const fromPosition = ncFrom.sidePosition;\n        const toPosition = ncTo.sidePosition;\n\n        const shiftIndex = (fromPosition + toPosition) / 2;\n\n        if (this.randomizedOffset) {\n            const fromInterfaceNeighbours = this.getInterfaceNeighbors(ncFrom, graph);\n            const toInterfaceNeighbours = this.getInterfaceNeighbors(ncTo, graph);\n\n            // the string is a sum of utf16 representation of each character\n            let toRandomIndex =\n                [...ncTo.id].reduce((accumulator, char) => accumulator + char.charCodeAt(0), 0) ??\n                0;\n            let fromRandomIndex =\n                [...ncFrom.id].reduce((accumulator, char) => accumulator + char.charCodeAt(0), 0) ??\n                0;\n\n            const randomIndex = (toRandomIndex ^ fromRandomIndex); // eslint-disable-line no-bitwise\n            fromRandomIndex = randomIndex % fromInterfaceNeighbours.length;\n            toRandomIndex = randomIndex % toInterfaceNeighbours.length;\n            const randomShiftIndex = (fromRandomIndex + toRandomIndex) / 2;\n            return this.shiftDistance * (randomShiftIndex / 2 + shiftIndex / 2) * scaling;\n        }\n\n        return this.shiftDistance * shiftIndex * scaling;\n    }\n\n    /**\n     * Checks maximum number of interfaces and computes maximum shift.\n     *\n     * @param ncFrom node from reference\n     * @param ncTo to node reference\n     * @param graph the graph definition\n     * @param scaling number from viewModel defining the scaling of canvas\n     * @returns Maximum value of the shift that the connection can obtain\n     */\n    getMaxShift(ncFrom, ncTo, graph, scaling) {\n        const maxFrom = this.getInterfaceNeighbors(ncFrom, graph).length - 1;\n        const maxTo = this.getInterfaceNeighbors(ncTo, graph).length - 1;\n        return this.shiftDistance * ((maxFrom + maxTo) / 2) * scaling;\n    }\n\n    /**\n     * Checks node and returns interfaces on the same side.\n     *\n     * @param interfaceRef node reference\n     * @param graph the graph definition\n     * @returns Array of neighboring intefraces on the same side\n     */\n    // eslint-disable-next-line class-methods-use-this\n    getInterfaceNeighbors(interfaceRef, graph) {\n        const node = graph.findNodeById(interfaceRef.nodeId);\n        return [\n            ...Object.values(node.inputs),\n            ...Object.values(node.outputs),\n        ].filter((c) => c.side === interfaceRef.side && c.port);\n    }\n\n    /**\n     * Checks whether one of the nodes is above or below the other one.\n     *\n     * @param ncFrom from interface reference\n     * @param ncTo to interface reference\n     * @param graph the graph definition\n     * @returns True if one node is higher than the other one\n     */\n    // eslint-disable-next-line class-methods-use-this\n    someAboveOrBelow(ncFrom, ncTo, graph) {\n        const nodeFromTop = nodeTopPoint(ncFrom, graph.scaling, graph.panning);\n        const nodeToTop = nodeTopPoint(ncTo, graph.scaling, graph.panning);\n        const nodeFromBottom = nodeBottomPoint(ncFrom, graph.scaling, graph.panning);\n        const nodeToBottom = nodeBottomPoint(ncTo, graph.scaling, graph.panning);\n        return nodeFromBottom < nodeToTop || nodeFromTop > nodeToBottom;\n    }\n\n    /* eslint-disable class-methods-use-this */\n    curvedRender(x1, y1, x2, y2, connection) {\n        const nc = new NormalizedConnection(x1, y1, x2, y2, connection);\n        const dx = 0.3 * Math.abs(nc.x1 - nc.x2);\n\n        if (nc.to) {\n            if (nc.from.side === 'right' && nc.to.side === 'left') {\n                return `M ${nc.x1} ${nc.y1} C ${nc.x1 + dx} ${nc.y1}, ${nc.x2 - dx} ${nc.y2}, ${\n                    nc.x2\n                } ${nc.y2}`;\n            }\n            if (nc.from.side === 'left' && nc.to.side === 'right') {\n                return `M ${nc.x1} ${nc.y1} C ${nc.x1 - dx} ${nc.y1}, ${nc.x2 + dx} ${nc.y2}, ${\n                    nc.x2\n                } ${nc.y2}`;\n            }\n            if (nc.from.side === 'right' && nc.to.side === 'right') {\n                const rightmost = Math.max(nc.x1 + dx, nc.x2 + dx);\n                return `M ${nc.x1} ${nc.y1} C ${rightmost} ${nc.y1}, ${rightmost} ${nc.y2}, ${nc.x2} ${nc.y2}`;\n            }\n            if (nc.from.side === 'left' && nc.to.side === 'left') {\n                const leftmost = Math.min(nc.x1 - dx, nc.x2 - dx);\n                return `M ${nc.x1} ${nc.y1} C ${leftmost} ${nc.y1}, ${leftmost} ${nc.y2}, ${nc.x2} ${nc.y2}`;\n            }\n        }\n\n        if (nc.from.side === 'right') {\n            return `M ${nc.x1} ${nc.y1} C ${nc.x1 + dx} ${nc.y1}, ${nc.x2 - dx} ${nc.y2}, ${\n                nc.x2\n            } ${nc.y2}`;\n        }\n        if (nc.from.side === 'left') {\n            return `M ${nc.x1} ${nc.y1} C ${nc.x1 - dx} ${nc.y1}, ${nc.x2 + dx} ${nc.y2}, ${\n                nc.x2\n            } ${nc.y2}`;\n        }\n\n        // unreachable, added to make eslint happy\n        return undefined;\n    }\n\n    curvedRenderLoopback(x1, y1, x2, y2, connection) {\n        const graph = this.viewModel.displayedGraph;\n        const nc = new NormalizedConnection(x1, y1, x2, y2, connection);\n        const sideMargin = 10 * graph.scaling;\n\n        if (nc.from.id === nc.to.id) {\n            // The same interface\n            const shift = this.getShift(nc.from, nc.to, graph, graph.scaling) + 30 * graph.scaling;\n            const x = nc.from.side === 'right' ? nc.x1 + shift : nc.x1 - shift;\n            return `M ${nc.x1} ${nc.y1}\n            A ${sideMargin} ${sideMargin / 2} 0 0 0 ${x} ${nc.y1}\n            A ${sideMargin} ${sideMargin / 2} 0 0 0 ${nc.x1} ${nc.y1}`;\n        }\n        if (nc.from.side === 'left' && nc.to.side === 'left') {\n            const leftRx = sideMargin;\n            const leftRy = Math.abs(nc.y1 - nc.y2) / 2;\n            const renderingSide = nc.y1 > nc.y2 ? 1 : 0;\n\n            return `M ${nc.x1} ${nc.y1}\n            A ${leftRx} ${leftRy} 0 0 ${renderingSide} ${nc.x2} ${nc.y2}`;\n        }\n        if (nc.from.side === 'right' && nc.to.side === 'right') {\n            const leftRx = sideMargin;\n            const leftRy = Math.abs(nc.y1 - nc.y2) / 2;\n            const renderingSide = nc.y1 > nc.y2 ? 0 : 1;\n\n            return `M ${nc.x1} ${nc.y1}\n            A ${leftRx} ${leftRy} 0 0 ${renderingSide} ${nc.x2} ${nc.y2}`;\n        }\n\n        const shift = this.getShift(nc.from, nc.to, graph, graph.scaling) + 30 * graph.scaling;\n\n        const leftx = nc.from.side === 'left' ? nc.x1 : nc.x2;\n        const rightx = nc.to.side === 'right' ? nc.x2 : nc.x1;\n\n        const lefty = nc.from.side === 'left' ? nc.y1 : nc.y2;\n        const righty = nc.to.side === 'right' ? nc.y2 : nc.y1;\n        const bottomY = nodeBottomPoint(nc.from, graph.scaling, graph.panning);\n\n        const y = bottomY + shift;\n\n        const rightCx = rightx - shift;\n        const rightCy = (y + righty) / 2;\n        const [rightRx, rightRy] = calculateEllipseR(rightx, y, rightCx, rightCy, 1);\n\n        const bottomCx = (rightx + leftx) / 2;\n        const bottomCy = bottomY;\n        const [bottomRx, bottomRy] = calculateEllipseR(rightx, y, bottomCx, bottomCy, 1);\n\n        const leftCx = leftx + shift;\n        const leftCy = (y + lefty) / 2;\n        const [leftRx, leftRy] = calculateEllipseR(leftx, y, leftCx, leftCy, -1);\n\n        return `M ${rightx} ${righty}\n        A ${rightRx} ${rightRy} 0 0 1 ${rightx} ${y}\n        A ${bottomRx} ${bottomRy} 0 0 1 ${leftx} ${y}\n        A ${leftRx} ${leftRy} 0 0 1 ${leftx} ${lefty}`;\n    }\n\n    orthogonalAnchorsPath(anchors, nc, graph) {\n        const calculatedAnchors = anchors.map((anchor) => {\n            const transform = (a) => {\n                const tx = (a.x + graph.panning.x) * graph.scaling;\n                const ty = (a.y + graph.panning.y) * graph.scaling;\n                return { x: tx, y: ty };\n            };\n\n            return transform(anchor);\n        });\n\n        const path = [{ x: nc.x1, y: nc.y1 }];\n        let direction = nc.from.side;\n        if (direction === 'right') {\n            path.push({ x: nc.x1 + 10, y: nc.y1 });\n        } else if (direction === 'left') {\n            path.push({ x: nc.x1 - 10, y: nc.y1 });\n        }\n        direction = 'horizontal';\n        calculatedAnchors.forEach((anchor) => {\n            if (direction === 'vertical') {\n                path.push({\n                    x: path[path.length - 1].x + (anchor.x - path[path.length - 1].x) / 2,\n                    y: path[path.length - 1].y,\n                });\n                path.push({\n                    x: path[path.length - 2].x + (anchor.x - path[path.length - 2].x) / 2,\n                    y: anchor.y,\n                });\n                path.push({\n                    x: anchor.x,\n                    y: anchor.y,\n                });\n                direction = 'horizontal';\n            } else {\n                path.push({\n                    x: path[path.length - 1].x,\n                    y: path[path.length - 1].y + (anchor.y - path[path.length - 1].y) / 2,\n                });\n                path.push({\n                    x: anchor.x,\n                    y: path[path.length - 2].y + (anchor.y - path[path.length - 2].y) / 2,\n                });\n                path.push({\n                    x: anchor.x,\n                    y: anchor.y,\n                });\n                direction = 'vertical';\n            }\n        });\n        if (direction === 'vertical') {\n            path.push({\n                x: path[path.length - 1].x + (nc.x2 - path[path.length - 1].x) / 2,\n                y: path[path.length - 1].y,\n            });\n            path.push({\n                x: path[path.length - 2].x + (nc.x2 - path[path.length - 2].x) / 2,\n                y: nc.y2,\n            });\n            path.push({\n                x: nc.x2,\n                y: nc.y2,\n            });\n        } else {\n            path.push({\n                x: path[path.length - 1].x,\n                y: path[path.length - 1].y + (nc.y2 - path[path.length - 1].y) / 2,\n            });\n            let offset = 0;\n            if (nc.to.side === 'left') offset = 10;\n            else offset = -10;\n            path.push({\n                x: nc.x2 - offset,\n                y: path[path.length - 2].y + (nc.y2 - path[path.length - 2].y) / 2,\n            });\n            path.push({\n                x: nc.x2 - offset,\n                y: nc.y2,\n            });\n            path.push({\n                x: nc.x2,\n                y: nc.y2,\n            });\n        }\n        return path;\n    }\n\n    orthogonalRender(x1, y1, x2, y2, connection) {\n        const graph = this.viewModel.displayedGraph;\n        const nc = new NormalizedConnection(x1, y1, x2, y2, connection);\n\n        if (connection.anchors !== undefined && connection.anchors.length) {\n            return this.orthogonalAnchorsPath(connection.anchors, nc, graph);\n        }\n\n        const minMargin = 30 * graph.scaling;\n        const middlePoint = (nc.x1 + nc.x2) / 2;\n\n        if (connection.to) {\n            const shift = this.getShift(nc.from, nc.to, graph, graph.scaling);\n\n            if (nc.from.side === 'right' && nc.to.side === 'left') {\n                const mid = Math.max(nc.x1, middlePoint) + shift + minMargin;\n\n                const firstTurn = mid < nc.x2 - shift - minMargin ? nc.x1 + shift + minMargin : mid;\n                const lastTurn = nc.x2 - shift - minMargin;\n\n                // S connection\n                if (\n                    mid >= nc.x2 - shift - minMargin &&\n                    (firstTurn > nc.x2 - minMargin || lastTurn < nc.x1 - minMargin)\n                ) {\n                    return `M ${nc.x1} ${nc.y1}\n                    H ${firstTurn}\n                    V ${(nc.y1 + nc.y2) / 2}\n                    H ${lastTurn}\n                    V ${nc.y2}\n                    H ${nc.x2}`;\n                }\n\n                // Z connection\n                return `M ${nc.x1} ${nc.y1} H ${mid} V ${nc.y2} H ${nc.x2}`;\n            }\n            if (nc.from.side === 'left' && nc.to.side === 'right') {\n                const mid = Math.max(nc.x2, middlePoint) + shift + minMargin;\n\n                const firstTurn = mid < nc.x1 - shift - minMargin ? nc.x2 + shift + minMargin : mid;\n                const lastTurn = nc.x1 - shift - minMargin;\n\n                // S connection\n                if (\n                    mid >= nc.x1 - shift - minMargin &&\n                    (firstTurn > nc.x1 - minMargin || lastTurn < nc.x2 - minMargin)\n                ) {\n                    return `M ${nc.x2} ${nc.y2}\n                    H ${firstTurn}\n                    V ${(nc.y1 + nc.y2) / 2}\n                    H ${lastTurn}\n                    V ${nc.y1}\n                    H ${nc.x1}`;\n                }\n\n                // Z connection\n                return `M ${nc.x2} ${nc.y2} H ${mid} V ${nc.y1} H ${nc.x1}`;\n            }\n            if (nc.from.side === 'right' && nc.to.side === 'right') {\n                return `M ${nc.x1} ${nc.y1} H ${\n                    Math.max(nc.x1, nc.x2, middlePoint) + shift + minMargin\n                } V ${nc.y2} H ${nc.x2}`;\n            }\n            if (nc.from.side === 'left' && nc.to.side === 'left') {\n                return `M ${nc.x1} ${nc.y1} H ${\n                    Math.min(nc.x1, nc.x2, middlePoint) - shift - minMargin\n                } V ${nc.y2} H ${nc.x2}`;\n            }\n        }\n        return `M ${nc.x1} ${nc.y1} H ${middlePoint} V ${nc.y2} H ${nc.x2}`;\n    }\n\n    orthogonalRenderLoopback(x1, y1, x2, y2, connection) {\n        const graph = this.viewModel.displayedGraph;\n        const nc = new NormalizedConnection(x1, y1, x2, y2, connection);\n        const shift = this.getShift(nc.from, nc.to, graph, graph.scaling) + 30 * graph.scaling;\n\n        if (connection.anchors !== undefined && connection.anchors.length) {\n            const anchors = connection.anchors.map((a) => {\n                const tx = (a.x + graph.panning.x) * graph.scaling;\n                const ty = (a.y + graph.panning.y) * graph.scaling;\n                return { x: tx, y: ty };\n            });\n\n            const path = [{ x: nc.x1, y: nc.y1 }];\n            const direction = nc.from.side;\n            const xShift = direction === 'right' ? shift : -shift;\n            path.push({ x: nc.x1 + xShift, y: nc.y1 });\n            anchors.forEach((anchor) => {\n                path.push({\n                    x: path[path.length - 1].x,\n                    y: anchor.y,\n                });\n                path.push({\n                    x: anchor.x,\n                    y: anchor.y,\n                });\n                // NOTE: Duplicate path is for proper anchor position calculation\n                path.push({\n                    x: anchor.x,\n                    y: anchor.y,\n                });\n            });\n            path.push({\n                x: path[path.length - 1].x,\n                y: nc.y2,\n            });\n            path.push({\n                x: nc.x2 + xShift,\n                y: nc.y2,\n            });\n            path.push({\n                x: nc.x2,\n                y: nc.y2,\n            });\n            return path;\n        }\n\n        const bottomY = nodeBottomPoint(nc.from, graph.scaling, graph.panning);\n        const y = bottomY + shift;\n\n        if (nc.from.side === 'right' && nc.to.side === 'left') {\n            return `M ${nc.x1} ${nc.y1}\n            h ${shift}\n            V ${y} H ${nc.x2 - shift} V ${nc.y2} H ${nc.x2}`;\n        }\n        if (nc.from.side === 'left' && nc.to.side === 'right') {\n            return `M ${nc.x2} ${nc.y2}\n            h ${shift}\n            V ${y} H ${nc.x1 - shift} V ${nc.y1} H ${nc.x1}`;\n        }\n        if (nc.from.side === 'right' && nc.to.side === 'right') {\n            return `M ${nc.x2} ${nc.y2}\n            h ${shift}\n            V ${nc.y1} H ${nc.x1}`;\n        }\n        if (nc.from.side === 'left' && nc.to.side === 'left') {\n            return `M ${nc.x2} ${nc.y2}\n            h ${-shift}\n            V ${nc.y1} H ${nc.x1}`;\n        }\n        // unreachable, added to make eslint happy\n        return undefined;\n    }\n\n    alternativeOrthogonalRender(x1, y1, x2, y2, connection) {\n        const graph = this.viewModel.displayedGraph;\n        const nc = new NormalizedConnection(x1, y1, x2, y2, connection);\n\n        if (connection.anchors !== undefined && connection.anchors.length) {\n            return this.orthogonalAnchorsPath(connection.anchors, nc, graph);\n        }\n\n        const minMargin = 30 * graph.scaling;\n        const middlePoint = (nc.x1 + nc.x2) / 2;\n\n        if (connection.to) {\n            const shift = this.getShift(nc.from, nc.to, graph, graph.scaling);\n            const maxShift = this.getMaxShift(nc.from, nc.to, graph, graph.scaling) || 1;\n\n            const turnDistance = Math.abs(nc.x1 - nc.x2) - 2 * minMargin;\n            const minTurnDistance = minMargin * (2 + maxShift / graph.scaling / 30);\n            const minTurnDistanceViolated = turnDistance < minTurnDistance;\n            const maxTurnDistance = minTurnDistance * 2;\n\n            let interpolatedShift;\n            if (turnDistance < maxTurnDistance) {\n                interpolatedShift = (shift / maxShift) * turnDistance;\n            } else {\n                interpolatedShift = (shift / maxShift) * maxTurnDistance\n                    + (turnDistance - maxTurnDistance) / 2;\n            }\n\n            const differentLevels = this.someAboveOrBelow(nc.from, nc.to, graph);\n\n            if (nc.from.side === 'right' && nc.to.side === 'left') {\n                // S connection\n                const nodeOverlap = nc.x1 > nc.x2;\n                if ((differentLevels && minTurnDistanceViolated) || nodeOverlap) {\n                    const firstTurn = nc.x1 + minMargin + (shift / maxShift) * minTurnDistance;\n                    const lastTurn = nc.x2 - minMargin + (shift / maxShift - 1) * minTurnDistance;\n                    return `M ${nc.x1} ${nc.y1}\n                    H ${firstTurn}\n                    V ${(nc.y1 + nc.y2) / 2}\n                    H ${lastTurn}\n                    V ${nc.y2}\n                    H ${nc.x2}`;\n                }\n\n                // Z connection\n                const mid = nc.x1 + minMargin + interpolatedShift;\n                return `M ${nc.x1} ${nc.y1} H ${mid} V ${nc.y2} H ${nc.x2}`;\n            }\n            if (nc.from.side === 'left' && nc.to.side === 'right') {\n                // S connection\n                const nodeOverlap = nc.x2 > nc.x1;\n                if ((differentLevels && minTurnDistanceViolated) || nodeOverlap) {\n                    const firstTurn = nc.x2 + minMargin + (shift / maxShift) * minTurnDistance;\n                    const lastTurn = nc.x1 - minMargin + (shift / maxShift - 1) * minTurnDistance;\n                    return `M ${nc.x2} ${nc.y2}\n                    H ${firstTurn}\n                    V ${(nc.y1 + nc.y2) / 2}\n                    H ${lastTurn}\n                    V ${nc.y1}\n                    H ${nc.x1}`;\n                }\n\n                // Z connection\n                const mid = nc.x2 + minMargin + interpolatedShift;\n                return `M ${nc.x2} ${nc.y2} H ${mid} V ${nc.y1} H ${nc.x1}`;\n            }\n            if (nc.from.side === 'right' && nc.to.side === 'right') {\n                return `M ${nc.x1} ${nc.y1} H ${\n                    Math.max(nc.x1, nc.x2, middlePoint) + shift + minMargin\n                } V ${nc.y2} H ${nc.x2}`;\n            }\n            if (nc.from.side === 'left' && nc.to.side === 'left') {\n                return `M ${nc.x1} ${nc.y1} H ${\n                    Math.min(nc.x1, nc.x2, middlePoint) - shift - minMargin\n                } V ${nc.y2} H ${nc.x2}`;\n            }\n        }\n        return `M ${nc.x1} ${nc.y1} H ${middlePoint} V ${nc.y2} H ${nc.x2}`;\n    }\n\n    alternativeOrthogonalRenderLoopback(x1, y1, x2, y2, connection) {\n        return this.orthogonalRenderLoopback(x1, y1, x2, y2, connection);\n    }\n\n    straightRender(x1, y1, x2, y2, connection) {\n        const graph = this.viewModel.displayedGraph;\n        return [{ x: x1, y: y1 }]\n            .concat((connection.anchors ?? []).map((a) => {\n                const tx = (a.x + graph.panning.x) * graph.scaling;\n                const ty = (a.y + graph.panning.y) * graph.scaling;\n                return { x: tx, y: ty };\n            }))\n            .concat([{ x: x2, y: y2 }]);\n    }\n\n    straightRenderLoopback(x1, y1, x2, y2, connection) {\n        return this.curvedRenderLoopback(x1, y1, x2, y2, connection);\n    }\n\n    constructor(viewModel, style, randomizedOffset = false) {\n        this.viewModel = viewModel;\n        this.style = style;\n        this.randomizedOffset = randomizedOffset;\n    }\n\n    /**\n     * Chooses the render method based on active style and connection characteristic\n     *\n     * @param x1 X coordinate of from interface\n     * @param y1 Y coordinate of from interface\n     * @param x2 X coordinate of to interface\n     * @param y2 Y coordinate of to interface\n     * @param connection BaklavaJS-defined connection to render\n     * @returns String defining connection path in SVG format\n     */\n    render(x1, y1, x2, y2, connection) {\n        const loopback = this.isLoopback(connection) ? 'Loopback' : '';\n        return this[`${this.style}Render${loopback}`](x1, y1, x2, y2, connection);\n    }\n\n    /**\n     * Tests whether the connection is loopback (connects the node with itself)\n     *\n     * @param connection BaklavaJS-defined connection to test\n     * @returns True if connection is loopback.\n     */\n    isLoopback(connection) {\n        // Temporary connections that are not connected to any output (.to is undefined)\n        // are not loopback\n        return !!connection.to && connection.from.nodeId === connection.to.nodeId;\n    }\n\n    /**\n     * Checks whether the current style supports anchors.\n     *\n     * @returns True if style supports anchors.\n     */\n    supportsAnchors() {\n        return ['orthogonal', 'alternativeOrthogonal', 'straight'].includes(this.style);\n    }\n}\n","/*\n * Copyright (c) 2022-2024 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/* eslint-disable max-classes-per-file */\n\nimport { stringify } from 'ajv';\nimport Ajv2019 from 'ajv/dist/2019.js';\nimport jsonMap from 'json-source-map';\nimport jsonlint from 'jsonlint-webpack';\n\nimport { useBaklava, useCommandHandler, useViewModel } from '@baklavajs/renderer-vue';\nimport { toRaw, ref, reactive } from 'vue';\nimport { Graph } from '@baklavajs/core';\nimport { v4 as uuidv4 } from 'uuid';\nimport { useHistory } from './History.ts';\nimport { useClipboard } from './Clipboard.ts';\n\nimport PipelineManagerEditor from '../custom/Editor.js';\nimport InterfaceTypes from './InterfaceTypes.js';\n\nimport { CustomNodeFactory, GraphFactory } from './NodeFactory.js';\nimport unresolvedSpecificationSchema from '../../../resources/schemas/unresolved_specification_schema.json' with {type: 'json'};\nimport specificationSchema from '../../../resources/schemas/specification_schema.json' with {type: 'json'};\nimport metadataSchema from '../../../resources/schemas/metadata_schema.json' with {type: 'json'};\nimport dataflowSchema from '../../../resources/schemas/dataflow_schema.json' with {type: 'json'};\nimport graphSchema from '../../../resources/schemas/graph_schema.json' with {type: 'json'};\nimport messageSchema from '../../../resources/schemas/message_schema.json' with {type: 'json'};\nimport ConnectionRenderer from './ConnectionRenderer.js';\nimport Specification from './Specification.js';\n\n/* eslint-disable lines-between-class-members */\n/**\n * Readonly helper class that reads and stores default values from metadata schema.\n */\nclass Metadata {\n    constructor() {\n        Object.entries(metadataSchema.properties).forEach(([name, state]) => {\n            this[name] = state.default;\n        });\n    }\n}\n\nexport const DEFAULT_CUSTOM_NODE_CATEGORY = 'Default';\nexport const DEFAULT_CUSTOM_NODE_NAME = 'New Node Type';\nexport const DEFAULT_CUSTOM_NODE_TYPE = 'New Node Type';\n\n// If a graph node entry does not have a category assigned, this values is used\n// as a fallback category\nexport const DEFAULT_GRAPH_NODE_CATEGORY = 'Graphs';\nexport const DEFAULT_GRAPH_NODE_NAME = 'New Graph Node';\nexport const DEFAULT_GRAPH_NODE_TYPE = 'New Graph Node';\n\n// Styles\nexport const NEW_NODE_STYLE = '__new';\nexport const EDITED_NODE_STYLE = '__edited';\n\n/**\n * Translates the provided url according to\n * the optional substitution spec provided at compile time.\n *\n * @param loc the encoded URL location of the resource\n * @returns a translated URL\n */\nfunction parseLocation(loc) {\n    if (loc.startsWith('data:application/json')) {\n        return loc;\n    }\n\n    let relativeurl = '{}';\n    if (typeof document !== 'undefined') {\n        const urlparent = document.location.href.split('/').slice(0, -1).join('/');\n        relativeurl = `${urlparent}/{}`;\n    }\n    const defaultsubs = `{\"https\": \"https://{}\", \"http\": \"http://{}\", \"relative\": \"${relativeurl}\"}`;\n    const jsonsubs = process.env.VUE_APP_JSON_URL_SUBSTITUTES ?? defaultsubs;\n    const subs = JSON.parse(jsonsubs);\n    const parts = loc.split('//');\n\n    if (parts.length < 2) return undefined;\n\n    const key = parts[0].substring(0, parts[0].length - 1);\n    const specifiedUrl = parts.slice(1).join('');\n\n    if (!Object.keys(subs).includes(key)) return undefined;\n    return subs[key].replace('{}', specifiedUrl);\n}\n\n/**\n * Loads the JSON file from the remote location given in URL.\n *\n * @param customLocation the URL location of the resource\n * @returns a tuple of a boolean and a JSON object or an error message.\n * The boolean is true if the JSON was successfully loaded and parsed\n */\nexport async function loadJsonFromRemoteLocation(customLocation) {\n    const location = parseLocation(customLocation);\n    if (location === undefined) {\n        return [false, `Could not download the resource from:  ${customLocation}.`];\n    }\n    let fetchedContent;\n    try {\n        fetchedContent = await fetch(location, { mode: 'cors' });\n    } catch (error) {\n        return [false, error.message];\n    }\n    try {\n        const jsonContent = await fetchedContent.json();\n        return [true, jsonContent];\n    } catch (error) {\n        return [false, error.message];\n    }\n}\n\nexport default class EditorManager {\n    static instance;\n\n    defaultMetadata = new Metadata();\n\n    editor = new PipelineManagerEditor();\n\n    baklavaView = useBaklava(this.editor);\n\n    specificationLoaded = ref(false);\n\n    specification = Specification.getInstance();\n\n    updatedMetadata = {};\n\n    relatedGraphsStore = [];\n\n    /**\n     * 'externalApplicationManager' property is set when ExternalApplicationManager\n     * is initialized, in its constructor, to avoid the cycle problem if it were\n     * imported normally.\n     */\n\n    externalApplicationManager;\n\n    constructor() {\n        this.editor.editorManager = this;\n\n        // Baklava's view registers subgraph input and output nodes\n        // This call un-registers them as obsolete\n        this.editor.unregisterNodes();\n\n        this.baklavaView.connectionRenderer = new ConnectionRenderer(\n            this.baklavaView,\n            this.defaultMetadata.connectionStyle,\n            this.defaultMetadata.randomizedOffset,\n        );\n\n        this.baklavaView.editor.layoutManager.useAlgorithm(this.defaultMetadata.layout);\n        this.baklavaView.interfaceTypes = new InterfaceTypes(this.baklavaView);\n\n        // need to be set here as settings try to use this value\n        // before this value can be loaded from specification\n        this.baklavaView.layers = this.defaultMetadata.layers;\n        this.baklavaView.collapseSidebar = this.defaultMetadata.collapseSidebar;\n        this.baklavaView.movementStep = this.defaultMetadata.movementStep;\n        this.baklavaView.editor.allowLoopbacks = this.defaultMetadata.allowLoopbacks;\n        this.baklavaView.navbarItems = this.defaultMetadata.navbarItems;\n        this.baklavaView.cache = {};\n        this.baklavaView.logLevel = this.defaultMetadata.logLevel;\n        this.baklavaView.settings.editableNodeTypes = this.defaultMetadata.editableNodeTypes;\n        this.baklavaView.settings.hideAnchors = this.defaultMetadata.hideAnchors;\n        this.baklavaView.settings.showIds = this.defaultMetadata.showIds;\n        this.baklavaView.settings.newGraphNode = this.defaultMetadata.newGraphNode;\n\n        this.specificationVersion = unresolvedSpecificationSchema.version;\n        this.baklavaView.commandHandler = useCommandHandler();\n        this.baklavaView.history = null;\n        this.baklavaView.history = useHistory(\n            toRaw(this.baklavaView).displayedGraph,\n            this.baklavaView.commandHandler,\n        );\n        this.baklavaView.clipboard = useClipboard(\n            toRaw(this.baklavaView).displayedGraph,\n            ref(this.baklavaView.editor),\n            this.baklavaView.commandHandler,\n        );\n\n        this.modifiedNodeSpecificationRegistry = {};\n    }\n\n    /**\n     * Loads the dataflow specification passed in `dataflowSpecification`.\n     * The specification describes what nodes are available in the editor.\n     *\n     * If the current editor already has a specification loaded then the editor\n     * and its plugins are reinitialized and then the specification is loaded.\n     *\n     * @param dataflowSpecification Specification to load, can be either an object or a string\n     * @param lazyLoad Decides whether to actually load the specification or just store\n     * @param unmarkNewNodes Decides whether to remove styling of new nodes.\n     * @param urloverrides Override mapping for included URLs.\n     * it and check its versioning. Can be used when loading parts of specification manually.\n     * @returns An object consisting of errors and warnings arrays. If any array is empty\n     * the updating process was successful.\n     */\n    /* eslint-disable no-underscore-dangle,no-param-reassign */\n    async updateEditorSpecification(\n        dataflowSpecification, lazyLoad = false, unmarkNewNodes = true, urloverrides = null,\n    ) {\n        if (!dataflowSpecification) return ['No specification passed'];\n\n        if (typeof dataflowSpecification === 'string' || dataflowSpecification instanceof String) {\n            try {\n                dataflowSpecification = jsonlint.parse(dataflowSpecification);\n            } catch (error) {\n                return { errors: [error], warnings: [] };\n            }\n        }\n\n        let state;\n        let stateNodeId;\n        if (this.isSpecificationLoaded()) {\n            state = this.saveDataflow();\n            stateNodeId = this.baklavaView.displayedGraph.sidebar.nodeId;\n            this.clearEditorManagerState();\n        }\n\n        const warnings = [];\n        const errors = [];\n        const info = [];\n\n        const { version } = dataflowSpecification; // eslint-disable-line object-curly-newline,max-len\n        if (!this.specification.currentSpecification) {\n            if (version === undefined) {\n                warnings.push(\n                    `Loaded specification has no version assigned. Please update the specification to version ${this.specificationVersion}.`,\n                );\n            } else if (version !== this.specificationVersion) {\n                info.push(\n                    `The specification format version (${version}) differs from the current specification format version (${this.specificationVersion}). It may result in unexpected behaviour.`,\n                );\n            }\n        }\n\n        if (unmarkNewNodes) {\n            warnings.push(...EditorManager.unmarkNewNodes(dataflowSpecification));\n        }\n\n        this.specification.unresolvedSpecification = reactive(\n            JSON.parse(JSON.stringify(dataflowSpecification)));\n        this.specification.currentSpecification = dataflowSpecification;\n        if (!lazyLoad) {\n            // Preprocess includes\n            this.globalVisitedSpecs = new Set();\n            const toInclude = Object.fromEntries(Object.entries({\n                include: dataflowSpecification.include,\n                urloverrides: dataflowSpecification.urloverrides,\n            }).filter(([_, value]) => value !== undefined));\n\n            const {\n                specification: includedSpecification,\n                errors: includeErrors,\n                warnings: includeWarnings,\n            } = await this.downloadNestedImports(toInclude, undefined, urloverrides);\n            errors.push(...includeErrors);\n            warnings.push(...includeWarnings);\n            if (errors.length) {\n                return { errors, warnings, info };\n            }\n\n            if (unmarkNewNodes) {\n                warnings.push(...EditorManager.unmarkNewNodes(includedSpecification));\n            }\n\n            // Include graphs\n            const {\n                graphs, errors: includeGraphsErrors,\n            } = await EditorManager.includeGraphs(dataflowSpecification.includeGraphs ?? []);\n            errors.push(...includeGraphsErrors);\n            if (errors.length) {\n                return { errors, warnings, info };\n            }\n\n            includedSpecification.graphs = (includedSpecification.graphs ?? []).concat(graphs);\n            this.specification.includedSpecification =\n                JSON.parse(JSON.stringify(includedSpecification));\n\n            // Merge included specification\n            const {\n                errors: mergeErrors, warnings: mergeWarnings,\n            } = EditorManager.mergeObjects(dataflowSpecification, includedSpecification);\n            errors.push(...mergeErrors);\n            warnings.push(...mergeWarnings);\n            if (errors.length) {\n                return { errors, warnings, info };\n            }\n\n            // Update metadata\n            const { metadata } = dataflowSpecification;\n            errors.push(...this.updateMetadata(metadata, false, true));\n            if (errors.length) {\n                return { errors, warnings, info };\n            }\n\n            // Update graph specification\n            const {\n                errors: newErrors, warnings: newWarnings,\n            } = await this.updateGraphSpecification(dataflowSpecification);\n            errors.push(...newErrors);\n            warnings.push(...newWarnings);\n        }\n\n        if (errors.length === 0) {\n            this.setSpecificationLoaded(true);\n        } else {\n            this.clearEditorManagerState();\n        }\n\n        if (state !== undefined && dataflowSpecification.entryGraph === undefined) {\n            const ret = await this.loadDataflow(state);\n            if (!ret.errors.length && stateNodeId) {\n                this.baklavaView.displayedGraph.sidebar.nodeId = stateNodeId;\n                this.baklavaView.displayedGraph.sidebar.visible = true;\n            } else {\n                this.relatedGraphsStore.forEach((g) => this.baklavaView.editor.registerGraph(g));\n            }\n        }\n\n        if (this.externalApplicationManager) {\n            const spec = this.specification.currentSpecification;\n            await this.externalApplicationManager.notifyAboutChange('specification_on_change', {\n                specification: spec,\n            });\n        }\n\n        return { errors, warnings, info };\n    }\n\n    clearEditorManagerState() {\n        this.baklavaView.editor.unregisterGraphs();\n        this.baklavaView.editor.deepCleanEditor();\n        this.baklavaView.editor.unregisterNodes();\n        this.baklavaView.editor.nodeStyles.clear();\n        this.setSpecificationLoaded(false);\n        this.specification.currentSpecification = {};\n        this.specification.includedSpecification = {};\n        this.specification.unresolvedSpecification = reactive({});\n    }\n\n    isSpecificationLoaded() {\n        if (typeof this.specificationLoaded === 'boolean') return this.specificationLoaded;\n        return this.specificationLoaded.value;\n    }\n\n    setSpecificationLoaded(value) {\n        if (typeof this.specificationLoaded === 'boolean') {\n            this.specificationLoaded = value;\n        } else {\n            this.specificationLoaded.value = value;\n        }\n    }\n\n    /**\n     * Downloads nested imports from the specification and returns an object\n     * consisting of nodes, graphs, and errors arrays.\n     *\n     * @param specification Specification to load.\n     * @param trace Set of visited specifications to detect circular imports.\n     * @returns Merged specification and errors.\n     */\n    async downloadNestedImports(specification, trace = new Set(), urloverrides = null) {\n        const warnings = [];\n        const errors = [];\n\n        // Download specifications and verify for circular imports\n        const specificationAndTrace = [];\n        const currentImports = new Set();\n        const include = specification.include ?? [];\n        await Promise.all(include.map(async (specificationUrl) => {\n            let style;\n            if (typeof specificationUrl === 'object' && specificationUrl !== null) {\n                ({ url: specificationUrl, style } = specificationUrl);\n            }\n            if (currentImports.has(specificationUrl)) {\n                errors.push(`Specification is included multiple times, skipping ${specificationUrl}`);\n                return;\n            }\n            if (trace.has(specificationUrl)) {\n                errors.push(`Circular dependency detected in included specification ${specificationUrl}`);\n                return;\n            }\n            currentImports.add(specificationUrl);\n\n            if (!this.globalVisitedSpecs.has(specificationUrl)) {\n                this.globalVisitedSpecs.add(specificationUrl);\n                const [status, val] = await loadJsonFromRemoteLocation(specificationUrl);\n                if (status === false) {\n                    errors.push(`Could not load the included specification from ${specificationUrl}. Reason: ${val}`);\n                } else {\n                    specificationAndTrace.push(\n                        {\n                            specification: val,\n                            trace: new Set([...trace, specificationUrl]), // Detect circular imports\n                            style,\n                        },\n                    );\n                }\n            }\n        }));\n\n        if (errors.length) {\n            return { specification, errors, warnings };\n        }\n\n        // Download nested imports\n        await Promise.all(specificationAndTrace.map(\n            async ({ specification: spec, trace: specTrace, style }) => {\n                const {\n                    specification: newSpecification, errors: newErrors, warnings: newWarnings,\n                } = await this.downloadNestedImports(spec, specTrace, urloverrides);\n                errors.push(...newErrors);\n                warnings.push(...newWarnings);\n\n                if (style !== undefined) EditorManager.includeWithStyle(newSpecification, style);\n\n                EditorManager.applyUrlOverrides(\n                    newSpecification,\n                    { ...(specification.urloverrides ?? {}), ...(urloverrides ?? {}) },\n                );\n\n                const {\n                    errors: mergeErrors, warnings: mergeWarnings,\n                } = EditorManager.mergeObjects(specification, newSpecification);\n                errors.push(...mergeErrors);\n                warnings.push(...mergeWarnings);\n            }));\n        return { specification, errors, warnings };\n    }\n\n    /**\n     * Downloads included dataflows from the specification and converts them to the\n     * graphs format to be included into the specification.\n     *\n     * @param includeGraphs Array of included graphs\n     * @returns Array graphs and an array of errors that occurred during the process.\n     */\n    static async includeGraphs(includeGraphs) {\n        const errors = [];\n        const graphs = [];\n\n        if (includeGraphs.length === 0) {\n            return { graphs, errors };\n        } if (includeGraphs.length !== new Set(includeGraphs).size) {\n            errors.push('Duplicate subgraph includes detected. Aborting.');\n            return { graphs, errors };\n        }\n\n        const dataflows = [];\n        await Promise.all(includeGraphs.map(async (dataflow) => {\n            const [status, val] = await loadJsonFromRemoteLocation(dataflow.url);\n            if (status === false) {\n                errors.push(`Could not load the included dataflow from '${dataflow.url}'. Reason: ${val}`);\n                return;\n            }\n\n            dataflows.push(val);\n        }));\n\n        if (errors.length) return { graphs, errors };\n\n        for (let i = 0; i < includeGraphs.length; i += 1) {\n            const dataflow = dataflows[i];\n            const dataflowMetadata = includeGraphs[i];\n\n            if (dataflow.graphs.length !== 1) {\n                errors.push(`Only single graph dataflows are supported. Aborting loading subgraph include from ${dataflowMetadata.url}.`);\n                continue; // eslint-disable-line no-continue\n            }\n\n            const targetGraph = dataflow.graphs[0];\n            targetGraph.name = dataflowMetadata.name ?? targetGraph.name;\n\n            if (targetGraph.name === undefined) {\n                errors.push(`Included subgraph from ${dataflowMetadata.url} does not have a name defined.`);\n                continue; // eslint-disable-line no-continue\n            }\n\n            if (graphs.find((graph) => graph.name === targetGraph.name) !== undefined) {\n                errors.push(`Included graph from ${dataflowMetadata.url} has a duplicate name`);\n                continue; // eslint-disable-line no-continue\n            }\n\n            graphs.push(targetGraph);\n        }\n\n        return { graphs, errors };\n    }\n\n    /**\n     * Registers default nodes, that are always present in the editor.\n     * The default nodes are the graph node and the new custom node.\n     * If the nodes are already present in the editor, an error is returned.\n     *\n     * @returns {object} Object consisting of errors and warnings arrays.\n     */\n    registerDefaultNodes() {\n        const errors = [];\n        const warnings = [];\n        // Adding a default graph node to the editor so that custom graphs can be created\n        if (this.editor.nodeTypes.has(DEFAULT_GRAPH_NODE_TYPE)) {\n            errors.push(\n                `Node name '${DEFAULT_GRAPH_NODE_NAME}' is reserved by the editor, ` +\n                'but it was included in the specification. ' +\n                'Please change the name of the graph node to avoid conflicts.',\n            );\n            return { errors, warnings };\n        }\n        if (this.editor.nodeTypes.has(DEFAULT_CUSTOM_NODE_TYPE)) {\n            errors.push(\n                `Node name '${DEFAULT_CUSTOM_NODE_NAME}' is reserved by the editor, ` +\n                'but it was included in the specification. ' +\n                'Please change the name of the graph node to avoid conflicts.',\n            );\n            return { errors, warnings };\n        }\n        const customNodeType = {\n            name: DEFAULT_CUSTOM_NODE_NAME,\n            category: DEFAULT_CUSTOM_NODE_CATEGORY,\n        };\n        this._registerNodeType(customNodeType);\n\n        const defaultGraphNode = {\n            name: DEFAULT_GRAPH_NODE_NAME,\n            category: DEFAULT_GRAPH_NODE_CATEGORY,\n        };\n\n        const myGraph = GraphFactory(\n            [],\n            [],\n            DEFAULT_GRAPH_NODE_NAME,\n            this.baklavaView.editor,\n        );\n\n        defaultGraphNode.subgraphId = myGraph.id;\n\n        // If `myGraph` is any array then it is an array of errors\n        if (Array.isArray(myGraph) && myGraph.length) {\n            errors.push(...myGraph);\n        } else {\n            this.baklavaView.editor.addGraphTemplate(\n                myGraph,\n                defaultGraphNode,\n            );\n        }\n        return { errors, warnings };\n    }\n\n    /**\n     * Propagates changes to nodes extending a category node.\n     * Called when the category node type is edited.\n     *\n     * @param {object} nodeSpecification Node specification to add\n     * @param {object} nodeToUpdate Node type to update\n     */\n    updateExtendingNodes(nodeSpecification, nodeToUpdate) {\n        const unresolvedChildNodes = this.specification.unresolvedSpecification.nodes\n            .filter((node) => node.extends?.includes(nodeToUpdate)) ?? [];\n        const resolvedChildNodes = this.specification.currentSpecification.nodes\n            .filter((node) => node.extends?.includes(nodeToUpdate)) ?? [];\n\n        const childNodes = [...unresolvedChildNodes, ...resolvedChildNodes];\n        childNodes.forEach((node) => {\n            node.category = nodeSpecification.category;\n            node.extends.forEach((parent, i) => {\n                if (parent === nodeToUpdate) {\n                    node.extends[i] = EditorManager.getNodeName(nodeSpecification);\n                }\n            });\n        });\n\n        const resolvedMap = new Map(\n            resolvedChildNodes.map((node) => [node.name, node]),\n        );\n        resolvedMap.forEach((resolvedNode, nodeName) => {\n            this._unregisterNodeType(nodeName);\n\n            const { viewModel } = useViewModel();\n            const { editor } = viewModel.value;\n            const allNodes = Array.from(editor.graphs).map((graph) => graph.nodes).flat();\n            const nodes = allNodes.filter((n) => n.type === nodeName);\n            nodes.forEach((n) => {\n                Object.entries(structuredClone(toRaw(resolvedNode))).forEach(([key, value]) => {\n                    if (value !== undefined && key !== 'interfaces' && key !== 'properties') {\n                        n[key] = structuredClone(toRaw(value));\n                    }\n                });\n            });\n\n            this._registerNodeType(structuredClone(toRaw(resolvedNode)));\n        });\n    }\n\n    /**\n     * Updates the list of extending nodes in all parent nodes.\n     * Called when the name of the node type is changed.\n     *\n     * @param {object} nodeSpecification Updated node data\n     * @param {object} nodeToUpdate Node type to update\n     */\n    updateParentNode(nodeSpecification, nodeToUpdate) {\n        nodeSpecification?.extends?.forEach((parentType) => {\n            const parentSpec = this.baklavaView.editor.parentNodes.get(parentType);\n            if (parentSpec.extending?.includes(nodeToUpdate)) {\n                parentSpec.extending.splice(\n                    parentSpec.extending.indexOf(nodeToUpdate),\n                    1,\n                    nodeSpecification.name,\n                );\n            }\n        });\n        if (this.baklavaView.editor.parentNodes.has(nodeToUpdate)) {\n            this.baklavaView.editor.parentNodes.delete(nodeToUpdate);\n        }\n        this.baklavaView.editor.parentNodes.set(nodeSpecification.name, nodeSpecification);\n    }\n\n    /**\n     * Validates the node specification passed in `nodeSpecification` and if\n     * it is correct adds it to the unresolved specification.\n     * If there is no current specification loaded then a new one is created.\n     * If node to update is provided, the specification is assigned to that node.\n     * The node specification should be in the format of the node schema.\n     *\n     * @param {object} nodeSpecification Node specification to add\n     * @param {object} nodeToUpdate Node type to update\n     * @param {boolean} removeUnused Whether keys missing from nodeSpecification should be removed\n     * @returns An object consisting of errors and warnings arrays. If both arrays are empty\n     * the updating process was successful.\n     */\n    addNodeToEditorSpecification(nodeSpecification, nodeToUpdate = undefined, removeUnused = true) {\n        // Remove undefined fields\n        Object.entries(nodeSpecification.properties ?? {}).forEach(([_, value]) => {\n            Object.keys(value).forEach((key) => {\n                if (value[key] === undefined) {\n                    delete value[key];\n                }\n            });\n        });\n        Object.entries(nodeSpecification.interfaces ?? {}).forEach(([_, value]) => {\n            Object.keys(value).forEach((key) => {\n                if (value[key] === undefined) {\n                    delete value[key];\n                }\n            });\n        });\n\n        let validationErrors = this.validateNode(nodeSpecification);\n        if (validationErrors.length) return validationErrors;\n\n        if (this.specification.currentSpecification === undefined) {\n            const newSpecification = {\n                nodes: [nodeSpecification],\n            };\n            return this.updateEditorSpecification(newSpecification, false, false);\n        }\n\n        this.specification.unresolvedSpecification.nodes ??= [];\n\n        // Modify existing node specification\n        if (nodeToUpdate !== undefined) {\n            const unresolvedNodeSpecification = this.specification.unresolvedSpecification\n                .nodes.find(\n                    (node) => EditorManager.getNodeName(node) === nodeToUpdate,\n                );\n            const resolvedNodeSpecification = this.specification.currentSpecification.nodes.find(\n                (node) => EditorManager.getNodeName(node) === nodeToUpdate,\n            );\n\n            if (resolvedNodeSpecification === undefined) {\n                // The node is newly created - it is not in registered specification yet\n                Object.entries(nodeSpecification).forEach(([key, value]) => {\n                    if (value !== undefined) {\n                        unresolvedNodeSpecification[key] = structuredClone(toRaw(value));\n                    }\n                });\n                validationErrors = this._registerNodeType(unresolvedNodeSpecification);\n                if (validationErrors.length) {\n                    return { errors: validationErrors, warnings: [] };\n                }\n            } else {\n                if (unresolvedNodeSpecification === undefined) {\n                    // The node is included - push new spec to unresolvedSpecification to override\n                    nodeSpecification.includeName = nodeToUpdate;\n                    this.specification.unresolvedSpecification.nodes.push(nodeSpecification);\n                } else {\n                    if (removeUnused) {\n                        Object.keys(unresolvedNodeSpecification)\n                            .filter((key) => !(key in nodeSpecification))\n                            .forEach((key) => { delete unresolvedNodeSpecification[key]; });\n                    }\n                    Object.entries(nodeSpecification).forEach(([key, value]) => {\n                        if (value !== undefined) {\n                            unresolvedNodeSpecification[key] = JSON.parse(JSON.stringify(value));\n                        }\n                    });\n                }\n                Object.entries(nodeSpecification).forEach(([key, value]) => {\n                    if (value !== undefined) {\n                        resolvedNodeSpecification[key] = JSON.parse(JSON.stringify(value));\n                    }\n                });\n\n                const nodeName = EditorManager.getNodeName(nodeSpecification);\n                resolvedNodeSpecification.name = nodeName;\n\n                const extendingNodes = this.specification.currentSpecification.nodes\n                    .filter((node) => node.extends?.includes(nodeToUpdate))\n                    .map((node) => EditorManager.getNodeName(node));\n                if (extendingNodes !== undefined) {\n                    resolvedNodeSpecification.extending = extendingNodes;\n                }\n\n                validationErrors = this._registerNodeType(resolvedNodeSpecification);\n                if (validationErrors.length) {\n                    return { errors: validationErrors, warnings: [] };\n                }\n\n                if (this.baklavaView.editor.nodeTypes.get(nodeName).isCategory) {\n                    this.updateExtendingNodes(\n                        JSON.parse(JSON.stringify(nodeSpecification)),\n                        nodeToUpdate,\n                    );\n                }\n\n                if (nodeSpecification.name !== nodeToUpdate) {\n                    this.updateParentNode(resolvedNodeSpecification, nodeToUpdate);\n                }\n\n                if (resolvedNodeSpecification.subgraphId !== undefined) {\n                    // Attach subgraph to the updated subgraph node\n                    let graphNode;\n                    let subgraph;\n                    this.specification.currentSpecification.graphs.forEach((graph) => {\n                        if (resolvedNodeSpecification.subgraphId === graph.id) {\n                            graphNode = resolvedNodeSpecification;\n                            subgraph = graph;\n                        }\n                    });\n\n                    const myGraph = GraphFactory(\n                        subgraph.nodes,\n                        subgraph.connections,\n                        subgraph.name,\n                        this.baklavaView.editor,\n                    );\n\n                    this.baklavaView.editor.addGraphTemplate(\n                        myGraph,\n                        graphNode,\n                    );\n                }\n            }\n        } else {\n            validationErrors = this._registerNodeType(nodeSpecification);\n            if (validationErrors.length) {\n                return { errors: validationErrors, warnings: [] };\n            }\n            this.specification.unresolvedSpecification.nodes.push(nodeSpecification);\n        }\n\n        if (this.externalApplicationManager) {\n            const spec = this.specification.unresolvedSpecification;\n            this.externalApplicationManager.notifyAboutChange('specification_on_change', {\n                specification: spec,\n            }).then();\n        }\n\n        return { errors: [], warnings: [] };\n    }\n\n    /**\n     * Assigns a new subgraph to the node.\n     *\n     * @param {object} node Node that the subgraph will be attached to\n     * @param {Array} nodes Nodes in the subgraph\n     * @param {Array} connections Connections in the subgraph\n     * @returns An array of errors that occurred.\n     */\n    addSubgraphToNode(node, nodes = [], connections = []) {\n        this._unregisterNodeType(node.type);\n\n        // Create new graph\n        const newGraph = GraphFactory(nodes, connections, node.type, this.baklavaView.editor);\n        if (Array.isArray(newGraph) && newGraph.length) {\n            return newGraph;\n        }\n\n        // Update node specification\n        const unresolvedNodeSpecification = this.specification.unresolvedSpecification.nodes.find(\n            (n) => EditorManager.getNodeName(n) === node.type,\n        );\n        const resolvedNodeSpecification = this.specification.currentSpecification.nodes.find(\n            (n) => EditorManager.getNodeName(n) === node.type,\n        );\n        if (resolvedNodeSpecification === undefined) {\n            unresolvedNodeSpecification.subgraphId = newGraph.id;\n            this.baklavaView.editor.addGraphTemplate(newGraph, unresolvedNodeSpecification);\n        } else {\n            resolvedNodeSpecification.subgraphId = newGraph.id;\n            if (unresolvedNodeSpecification === undefined) {\n                this.specification.unresolvedSpecification.nodes.push(resolvedNodeSpecification);\n            } else {\n                unresolvedNodeSpecification.subgraphId = newGraph.id;\n            }\n            this.baklavaView.editor.addGraphTemplate(newGraph, resolvedNodeSpecification);\n        }\n\n        // Update editor nodes\n        const { viewModel } = useViewModel();\n        const { displayedGraph } = viewModel.value;\n        const nodesToReplace = displayedGraph.nodes.filter(\n            (n) => n.type === node.type,\n        );\n        nodesToReplace.forEach((n) => {\n            displayedGraph.replaceNode(n, node.type);\n        });\n        return [];\n    }\n\n    /**\n     * Creates a new nodeType and registers it in the editor.\n     * If the nodeType is not valid then an array of errors is returned.\n     * If the nodeType is valid then it is registered in the editor and an empty array is returned.\n     *\n     * @param {object} node Node to register\n     * @returns An array of errors that occurred during the node registration.\n     */\n    _registerNodeType(node) {\n        if (this.baklavaView.editor.nodeTypes.has(node.name)) {\n            return [`Node of type ${node.name} is already registered`];\n        }\n\n        const myNode = CustomNodeFactory(\n            node.name,\n            node.layer,\n            node.interfaces ?? [],\n            node.properties ?? [],\n            node.interfaceGroups ?? [],\n            node.defaultInterfaceGroups ?? [],\n            node.twoColumn ?? this.baklavaView.twoColumn ?? false,\n            node.description ?? '',\n            node.extends ?? [],\n            node.extending ?? [],\n            node.siblings ?? [],\n            node.width ?? 300,\n        );\n\n        // If my node is any array then it is an array of errors\n        if (Array.isArray(myNode) && myNode.length) {\n            return myNode;\n        }\n\n        this.baklavaView.editor.registerNodeType(myNode, {\n            title: node.name,\n            category: node.category,\n            isCategory: node.isCategory ?? false,\n            color: node.color,\n            style: node.style,\n            pill: node.pill,\n            subgraphId: node.subgraphId,\n            relatedGraphs: node.relatedGraphs,\n        });\n        if ('icon' in node) {\n            const icon = typeof node.icon === 'string' ? node.icon : this.getMetadataIcon(node.icon);\n            this.baklavaView.editor.nodeIcons.set(node.name, icon);\n        }\n        if ('urls' in node) {\n            Object.entries(node.urls).forEach(([urlName, url]) => {\n                if (!this.baklavaView.editor.nodeURLs.has(node.name)) {\n                    this.baklavaView.editor.nodeURLs.set(node.name, {});\n                }\n                this.baklavaView.editor.nodeURLs.get(node.name)[urlName] = url;\n            });\n        }\n        return [];\n    }\n\n    /**\n     * Takes the first key-value pair of icon mapping and looks up the base value in the metadata.\n     * @rapam {object} icon icon mapping.\n     * @returns Full URL with substituted base.\n     */\n    getMetadataIcon(icon) {\n        const [[baseName, suffix]] = Object.entries(icon);\n        const baseUrl = this.baklavaView.editor.baseIconUrls.get(baseName);\n        return `${baseUrl}${baseUrl.endsWith('/') ? '' : '/'}${suffix}`;\n    }\n\n    /**\n     * Unregisters a node type\n     * If there is no such node type then an array of errors is returned.\n     *\n     * @param {object} nodeType Node to unregister\n     * @returns An array of errors that occurred during the node unregistration.\n     */\n    _unregisterNodeType(nodeType) {\n        if (this.baklavaView.editor.nodeTypes.has(nodeType)) {\n            this.baklavaView.editor.unregisterNodeType(nodeType);\n            return [];\n        }\n        return [`Node of type ${nodeType} is not registered`];\n    }\n\n    /**\n     * Filters graphs that are recursively included by the graph with a given ID.\n     *\n     * @param {string} entryGraphId root graph.\n     * @param {Object[]} graphs graphs to be filtered.\n     * @param {Boolean} Whether to include the entry graph.\n     * @returns {Object[]} Filtered graphs\n     */\n    static getSubgraphs(entryGraphId, graphs, includeEntry = true) {\n        const entryGraph = graphs?.find((graph) => graph.id === entryGraphId);\n        const graphMapping = Object.fromEntries(graphs.map((graph) => [graph.id, graph]));\n        const usedGraphs = [];\n        const dfs = (subgraph) => {\n            if (usedGraphs.includes(subgraph.id)) return;\n            usedGraphs.push(subgraph.id);\n\n            const subgraphs = subgraph.nodes\n                ?.map((node) => node.subgraph) ?? [];\n            const relatedGraphs = subgraph.nodes\n                ?.map((node) => node.relatedGraphs?.map(({ id }) => id) ?? [])\n                .flat() ?? [];\n\n            subgraphs\n                .concat(relatedGraphs)\n                .filter((id) => id !== undefined)\n                .map((id) => graphMapping[id])\n                .forEach(dfs);\n        };\n        dfs(entryGraph);\n\n        return usedGraphs\n            .filter((id) => id !== entryGraphId || includeEntry)\n            .map((id) => graphMapping[id]);\n    }\n\n    /**\n     * Reads and validates part of specification related to nodes and subgraphs\n     * @param dataflowSpecification Specification to load\n     * @param includedGraphs Graphs included in the specification\n     * @returns An object consisting of errors and warnings arrays. If any array is empty\n     * the updating process was successful.\n     */\n    async updateGraphSpecification(dataflowSpecification) {\n        const warnings = [];\n\n        if (!dataflowSpecification) return { errors: ['No specification passed'], warnings };\n\n        const { nodes, graphs, metadata } = dataflowSpecification;\n        if (nodes === undefined && graphs === undefined) return { errors: [], warnings };\n\n        let resolvedNodes = [];\n\n        // Store abstract nodes before removing them\n        nodes.forEach((node) => {\n            if (node.abstract) {\n                this.baklavaView.editor.parentNodes.set(node.name, node);\n            }\n        });\n\n        try {\n            const preprocessedNodes = EditorManager.preprocessNodes(nodes);\n            resolvedNodes = this.resolveInheritance(preprocessedNodes);\n        } catch (e) {\n            return { errors: [e.message], warnings };\n        }\n\n        resolvedNodes.forEach((node) => {\n            if (node.isCategory) {\n                this.baklavaView.editor.parentNodes.set(node.name, node);\n            }\n        });\n\n        const errors = [];\n        errors.push(...this.validateResolvedSpecification(\n            { graphs, nodes: resolvedNodes, metadata },\n        ));\n        if (errors.length) {\n            return { errors, warnings };\n        }\n\n        this.specification.currentSpecification.nodes = JSON.parse(JSON.stringify(resolvedNodes));\n        this.specification.currentSpecification.graphs = JSON.parse(JSON.stringify(graphs));\n\n        // Resolving siblings, parents and children\n\n        // Resolving children\n        resolvedNodes.forEach((node) => {\n            (node.extends ?? []).forEach((eName) => {\n                const extended = resolvedNodes.find((n) => n.name === eName);\n\n                // The extended node could be abstract, in which way it is not in resolved nodes.\n                if (extended !== undefined) {\n                    if (extended.extending === undefined) {\n                        extended.extending = [];\n                    }\n                    extended.extending.push(node.name);\n                }\n            });\n        });\n\n        // Resolving siblings\n        resolvedNodes.forEach((node) => {\n            const siblings = new Set();\n            (node.extends ?? []).forEach((eName) => {\n                const extended = resolvedNodes.find((n) => n.name === eName);\n\n                // The extended node could be abstract, in which way it is not in resolved nodes.\n                if (extended !== undefined) {\n                    extended.extending.forEach((e) => siblings.add(e));\n                }\n            });\n            siblings.delete(node.name);\n            node.siblings = Array.from(siblings);\n        });\n\n        // Removing abstract parents\n        resolvedNodes.forEach((node) => {\n            if (node.extends) {\n                node.extends = node.extends.filter(\n                    (eName) => (resolvedNodes.find((n) => n.name === eName) !== undefined),\n                );\n            }\n        });\n\n        resolvedNodes.forEach((node) => {\n            errors.push(...this.validateNodeStyle(node));\n            errors.push(...this._registerNodeType(node));\n        });\n\n        if (errors.length) {\n            return { errors, warnings };\n        }\n        this.relatedGraphsStore = [];\n        if (graphs !== undefined) {\n            // eslint-disable-next-line no-restricted-syntax\n            const subgraphs = nodes.filter(({ subgraphId }) => subgraphId !== undefined);\n            const relatedGraphIds = nodes\n                .map((node) => node.relatedGraphs?.map(({ id }) => id))\n                .filter((value) => value !== undefined)\n                .flat();\n\n            const validateGraph = async (graph, loadArgs = []) => {\n                // Validating the graph after it is registered to see if there are any errors\n                // by loading a graph (with nested subgraphs, if applicable)\n\n                const graphs_ = EditorManager\n                    .getSubgraphs(graph.id, graphs)\n                    .map((subgraph) => structuredClone(subgraph));\n\n                const {\n                    errors: loadingErrors,\n                    warnings: loadingWarnings,\n                } = await this.loadDataflow({ // eslint-disable-line no-await-in-loop\n                    graphs: graphs_,\n                    version: dataflowSpecification.version,\n                }, ...loadArgs);\n\n                this.baklavaView.editor.deepCleanEditor();\n                this.baklavaView.editor.unregisterGraphs();\n\n                warnings.push(\n                    ...loadingWarnings.map((warning) => `Graph '${graph.name}' is invalid: ${warning}`),\n                );\n\n                errors.push(\n                    ...loadingErrors.map((error) => `Graph '${graph.name}' is invalid: ${error}`));\n            };\n\n            // eslint-disable-next-line no-restricted-syntax\n            for (const node of subgraphs) {\n                const graphId = node.subgraphId;\n                const graph = graphs.find(({ id }) => id === graphId);\n                if (graph === undefined) {\n                    errors.push([`The subgraph with ID ${graphId} was not found`]);\n                    continue; // eslint-disable-line no-continue\n                }\n\n                const myGraph = GraphFactory(\n                    graph.nodes,\n                    graph.connections,\n                    graph.name,\n                    this.baklavaView.editor,\n                );\n\n                // If `myGraph` is any array then it is an array of errors\n                if (Array.isArray(myGraph) && myGraph.length) {\n                    errors.push(...myGraph);\n                    continue; // eslint-disable-line no-continue\n                }\n\n                this.baklavaView.editor.addGraphTemplate(\n                    myGraph,\n                    resolvedNodes.find((n) => n.name === node.name),\n                );\n\n                const loadArgs = [true, true, node.name];\n\n                // eslint-disable-next-line no-await-in-loop\n                await validateGraph(graph, loadArgs);\n                this.baklavaView.editor.deepCleanEditor();\n                this.baklavaView.editor.unregisterGraphs();\n            }\n\n            // eslint-disable-next-line no-restricted-syntax\n            for (const graphId of relatedGraphIds) {\n                const graph = graphs.find(({ id }) => id === graphId);\n                if (graph === undefined) {\n                    errors.push([`The related graph with ID ${graphId} was not found`]);\n                    continue; // eslint-disable-line no-continue\n                }\n\n                const loadArgs = [true, true];\n\n                // eslint-disable-next-line no-await-in-loop\n                await validateGraph(graph, loadArgs);\n\n                if (this.relatedGraphsStore.find((el) => graphId === el.id)) {\n                    continue; // eslint-disable-line no-continue\n                }\n\n                const newGraph = new Graph(this.baklavaView.editor);\n                newGraph.load(graph);\n                this.relatedGraphsStore.push(newGraph);\n            }\n            this.relatedGraphsStore.forEach((g) => this.baklavaView.editor.registerGraph(g));\n            this.editor._graph.id = uuidv4();\n        }\n\n        // Removing duplicate warnings\n        const uniqueWarnings = [...new Set(warnings)];\n\n        // Registering default categories\n        const { errors: defaultErrors, warnings: defaultWarnings } = this.registerDefaultNodes();\n        errors.push(...defaultErrors);\n        uniqueWarnings.push(...defaultWarnings);\n\n        // Load entry graph\n        const entryGraphId = dataflowSpecification.entryGraph;\n        if (!errors.length && entryGraphId !== undefined) {\n            if (graphs?.some((graph) => graph.id === entryGraphId)) {\n                const {\n                    errors: entryErrors,\n                } = await this.loadDataflow({\n                    graphs: EditorManager.getSubgraphs(entryGraphId, graphs),\n                    version: dataflowSpecification.version,\n                    entryGraph: entryGraphId,\n                });\n                if (entryErrors && entryErrors.length !== 0) {\n                    entryErrors.forEach((e) => errors.push(e));\n                    const newGraphInstance = new Graph(this.baklavaView.editor);\n                    this.baklavaView.editor.displayedGraph = newGraphInstance;\n                    this.baklavaView.editor.deepCleanEditor();\n                    this.baklavaView.editor.unregisterGraphs();\n                }\n            } else {\n                uniqueWarnings.push(`'entryGraph' points to undefined graph: '${entryGraphId}'`);\n            }\n        }\n\n        return { errors, warnings: uniqueWarnings };\n    }\n\n    /**\n     * Preprocess nodes to be later passed to `resolveInheritance` function.\n     *\n     * @param nodes coming from specification.\n     * @returns preprocessed nodes.\n     */\n    static preprocessNodes(nodes) {\n        nodes.filter((node) => node.isCategory)\n            .forEach((node) => { node.name = EditorManager.getNodeName(node); });\n        return nodes;\n    }\n\n    /**\n     * Reads and validates metadata from specification and loads it into the editor.\n     * if no metadata is passed it uses a stored specification.\n     *\n     * @param metadata metadata to load\n     * @param overriding tells whether the metadata is updated on dataflow loading\n     * @param loading resets updated metadata, should be used when loading new dataflow\n     * @returns An array of errors that occurred during the metadata loading.\n     */\n    updateMetadata(metadata = undefined, overriding = false, loading = false) {\n        if (loading) this.updatedMetadata = {};\n        let newMetadata;\n        if (metadata !== undefined) {\n            metadata = { ...this.updatedMetadata, ...metadata };\n            newMetadata = JSON.parse(JSON.stringify(metadata));\n        }\n        if (metadata === undefined && this.specification.currentSpecification) {\n            metadata = this.specification.currentSpecification.metadata ?? {};\n        }\n\n        if (!metadata) return ['No specification to load provided.'];\n\n        if (overriding) {\n            // this.specification.currentSpecification?.metadata should not\n            // be over overridden, that is why it needs to be copied before merging\n            const tempMetadata = metadata;\n            metadata = JSON.parse(JSON.stringify(\n                this.specification.currentSpecification?.metadata ?? {}));\n            EditorManager.mergeObjects(metadata, tempMetadata);\n        }\n\n        this.baklavaView.interfaceTypes.readInterfaceTypes(metadata);\n\n        if (metadata && 'urls' in metadata) {\n            Object.entries(metadata.urls).forEach(([urlName, state]) => {\n                this.baklavaView.editor.baseURLs.set(urlName, state);\n            });\n        }\n\n        if (metadata && 'icons' in metadata) {\n            Object.entries(metadata.icons).forEach(([iconName, state]) => {\n                this.baklavaView.editor.baseIconUrls.set(iconName, state);\n            });\n        }\n\n        if (metadata && 'navbarItems' in metadata) {\n            this.baklavaView.navbarItems = JSON.parse(JSON.stringify(metadata.navbarItems));\n        }\n\n        this.baklavaView.editor.readonly = metadata?.readonly ?? this.defaultMetadata.readonly;\n        this.baklavaView.editor.hideHud = metadata?.hideHud ?? this.defaultMetadata.hideHud;\n\n        this.baklavaView.editor.nodeStyles.set(NEW_NODE_STYLE, { icon: 'NewNode' });\n        this.baklavaView.editor.nodeStyles.set(EDITED_NODE_STYLE, { icon: 'EditedNode' });\n        Object.entries(metadata?.styles ?? {}).forEach(([key, value]) => {\n            this.baklavaView.editor.nodeStyles.set(key, value);\n        });\n\n        this.editor.allowLoopbacks =\n            metadata?.allowLoopbacks ?? this.defaultMetadata.allowLoopbacks;\n        this.baklavaView.twoColumn = metadata?.twoColumn ?? this.defaultMetadata.twoColumn;\n        this.baklavaView.connectionRenderer.style =\n            metadata?.connectionStyle ?? this.defaultMetadata.connectionStyle;\n\n        this.baklavaView.movementStep = metadata?.movementStep ?? this.defaultMetadata.movementStep;\n        this.baklavaView.settings.background.gridSize =\n            metadata?.backgroundSize ?? this.defaultMetadata.backgroundSize;\n        this.baklavaView.connectionRenderer.randomizedOffset =\n            metadata?.randomizedOffset ?? this.defaultMetadata.randomizedOffset;\n        this.baklavaView.settings.toggleableEditableTypes =\n            metadata?.toggleableEditableTypes ?? this.defaultMetadata.toggleableEditableTypes;\n        this.baklavaView.settings.editableNodeTypes =\n            metadata?.editableTypes ?? this.defaultMetadata.editableNodeTypes;\n        this.baklavaView.settings.hideAnchors =\n            metadata?.hideAnchors ?? this.defaultMetadata.hideAnchors;\n        this.baklavaView.settings.showIds =\n            metadata?.showIds ?? this.defaultMetadata.showIds;\n        this.baklavaView.settings.newGraphNode =\n            metadata?.newGraphNode ?? this.defaultMetadata.newGraphNode;\n\n        this.baklavaView.ignoredLayers = new Set();\n        this.baklavaView.layers = metadata?.layers ?? this.defaultMetadata.layers;\n        this.baklavaView.collapseSidebar =\n            metadata?.collapseSidebar ?? this.defaultMetadata.collapseSidebar;\n        this.baklavaView.editor.layoutManager.useAlgorithm(\n            metadata?.layout ?? this.defaultMetadata.layout,\n        );\n        this.baklavaView.logLevel = metadata?.logLevel ?? this.defaultMetadata.logLevel;\n        this.baklavaView.welcome = metadata?.welcome ?? this.defaultMetadata.welcome;\n        if (newMetadata) this.updatedMetadata = newMetadata;\n\n        return [];\n    }\n\n    /**\n     * Given nodes resolves their inheritances and returns and array of nodes that are ready\n     * to be loaded by the editor.\n     *\n     * @param nodes\n     * @returns nodes with resolved inheritances\n     */\n    /* eslint-disable class-methods-use-this,no-param-reassign */\n    resolveInheritance(nodes) {\n        const unsortedNodes = JSON.parse(JSON.stringify(nodes));\n\n        const isObject = (obj) => typeof obj === 'object' && obj !== null && !Array.isArray(obj);\n        const isArray = (obj) => Array.isArray(obj);\n\n        // Helper function that applies base node properties to the child node\n        const mergeNodes = (child, base) => {\n            const output = { ...structuredClone(base) };\n            const nonInheritableKeys = ['abstract', 'isCategory'];\n\n            nonInheritableKeys.forEach((key) => {\n                delete output[key];\n            });\n\n            if (isObject(child) && isObject(base)) {\n                Object.keys(child).forEach((key) => {\n                    if (key === 'style') {\n                        output[key] = EditorManager.mergeStyles(base[key], child[key]);\n                    } else if (isObject(child[key])) {\n                        if (!(key in output)) {\n                            output[key] = child[key];\n                        } else {\n                            output[key] = mergeNodes(child[key], base[key]);\n                        }\n                    } else if (isArray(child[key]) && isArray(base[key])) {\n                        if (key === 'extends') {\n                            output[key] = child[key];\n                        } else {\n                            const baseNames = Object.fromEntries(\n                                base[key].map((obj, i) => [obj.name, i]),\n                            );\n                            child[key].forEach((obj) => {\n                                if (obj.name && obj.name in baseNames) {\n                                    const index = baseNames[obj.name];\n                                    if (obj.override) {\n                                        output[key][index] = {\n                                            ...base[key][index],\n                                            ...obj,\n                                        };\n                                        delete output[key][index].override;\n                                    } else {\n                                        throw new Error(`'${child.name}' node cannot override '${obj.name}' property of '${base.name}' node`);\n                                    }\n                                } else {\n                                    output[key].push(obj);\n                                }\n                            });\n                        }\n                    } else {\n                        output[key] = child[key];\n                    }\n                });\n            }\n            return output;\n        };\n\n        const resolvedNodes = {};\n        const recurrentMerge = (name) => {\n            // Node resolved\n            if (name in resolvedNodes) return resolvedNodes[name];\n            let node = nodes.find((n) => n.name === name);\n            // Node does not inherite anything\n            if (!node.extends) {\n                resolvedNodes[name] = node;\n                return node;\n            }\n            // Check if extends has unique values\n            if ((new Set(node.extends)).size !== node.extends.length) {\n                throw new Error(`Repeated class in \"extends\" list of \"${node.name}\" node`);\n            }\n            // Get base nodes and merge them\n            let base;\n            node.extends.forEach((baseName) => {\n                base = recurrentMerge(baseName);\n                node = mergeNodes(node, base);\n            });\n            resolvedNodes[name] = node;\n            return node;\n        };\n        // Filter out abstract nodes and get merged ones\n        const mergedNodes = unsortedNodes.filter(\n            (node) => !node.abstract,\n        ).map((node) => recurrentMerge(node.name));\n\n        return mergedNodes;\n    }\n\n    /**\n     * Validate styles of a node.\n     *\n     * @param node node to verify.\n     * @returns errors if the node has non-existing or repeated styles.\n     */\n    validateNodeStyle(node) {\n        const errors = [];\n\n        if (node.style === undefined) return errors;\n\n        const style = Array.isArray(node.style) ? node.style : [node.style];\n        const styleSet = new Set(style);\n        if (styleSet.size !== style.length) {\n            errors.push(`Repeated styles in \"${EditorManager.getNodeName(node)}\" node`);\n        }\n\n        errors.push(...Array.from(styleSet)\n            .filter((styleName) => !this.baklavaView.editor.nodeStyles.has(styleName))\n            .map((styleName) => `Non-existing style \"${styleName}\" in '${EditorManager.getNodeName(node)}' node`));\n\n        return errors;\n    }\n\n    /**\n     * Serializes and returns current specification in Pipeline Manager format.\n     *\n     * @returns Serialized specification.\n     */\n    saveSpecification() {\n        const specification =\n            JSON.parse(JSON.stringify(this.specification.unresolvedSpecification));\n\n        EditorManager.unmarkNewNodes(specification);\n        return specification;\n    }\n\n    /**\n     * Removes NEW_NODE_STYLE node styles.\n     *\n     * @param specification specification to modify.\n     * @returns warnings about removed styles.\n     */\n    static unmarkNewNodes(specification) {\n        const warnings = [];\n\n        const warn = (node) => {\n            warnings.push(`Loaded node '${EditorManager.getNodeName(node)}' has '${NEW_NODE_STYLE}' style, removing it.`);\n        };\n\n        specification.nodes?.forEach((node) => {\n            if (node.style === NEW_NODE_STYLE) {\n                warn(node);\n                delete node.style;\n            } else if (Array.isArray(node.style) && node.style.includes(NEW_NODE_STYLE)) {\n                warn(node);\n                node.style.splice(node.style.indexOf(NEW_NODE_STYLE), 1);\n            }\n        });\n\n        return warnings;\n    }\n\n    /**\n     * Returns the top-level graph.\n     *\n     * @returns {object} baklava format graph.\n     */\n    getRootGraph() {\n        return this.editor.subgraphStack.length\n            ? this.editor.subgraphStack[0]\n            : this.editor.graph;\n    }\n\n    /**\n     * Serializes and returns current dataflow in Pipeline Manager format.\n     *\n     * @param {Boolean} readonly whether the dataflow should be saved in readonly mode\n     * @param {Boolean} hideHud whether the dataflow should be saved in hideHud mode\n     * @param {Boolean} position whether the dataflow should store panning and scaling values\n     * @param {string|null|undefined} graphName graph name which is rendered to the user\n     *\n     * @returns Serialized dataflow.\n     */\n    saveDataflow(readonly, hideHud, position, graphName) {\n        const save = this.baklavaView.editor.save();\n        save.version = this.specificationVersion;\n\n        const entryGraph = save.entryGraph\n            ? save.graphs.find((dataflowGraph) => dataflowGraph.id === save.entryGraph)\n            : save.graphs[0];\n\n        if (entryGraph && graphName !== null && graphName !== undefined) {\n            const rootGraph = this.getRootGraph();\n            entryGraph.name = graphName;\n            rootGraph.name = graphName;\n            if (rootGraph === this.editor.graph) this.baklavaView.editor.graphName = graphName;\n        }\n\n        if (!position) {\n            save.graphs.forEach((graph) => {\n                delete graph.panning;\n                delete graph.scaling;\n            });\n        }\n\n        if (save.metadata === undefined) {\n            save.metadata = {};\n        }\n\n        [\n            [readonly, 'readonly'],\n            [hideHud, 'hideHud'],\n            [this.editor.allowLoopbacks, 'allowLoopbacks'],\n            [this.baklavaView.twoColumn, 'twoColumn'],\n            [this.baklavaView.connectionRenderer.style, 'connectionStyle'],\n            [this.baklavaView.movementStep, 'movementStep'],\n            [this.baklavaView.settings.background.gridSize, 'backgroundSize'],\n            [this.baklavaView.connectionRenderer.randomizedOffset, 'randomizedOffset'],\n            [this.baklavaView.settings.editableNodeTypes, 'editableTypes'],\n            [this.baklavaView.settings.toggleableEditableTypes, 'toggleableEditableTypes'],\n            [this.baklavaView.settings.hideAnchors, 'hideAnchors'],\n            [this.baklavaView.settings.showIds, 'showIds'],\n            [this.baklavaView.settings.newGraphNode, 'newGraphNode'],\n        ].forEach(([currVal, name]) => {\n            const m = this.specification.currentSpecification?.metadata ?? {};\n            const dm = this.defaultMetadata;\n\n            if (currVal !== (m[name] ?? dm[name])) {\n                save.metadata[name] = currVal;\n            }\n        });\n\n        if (Object.keys(save.metadata).length === 0) {\n            delete save.metadata;\n        }\n\n        return save;\n    }\n\n    /**\n     * Loads the dataflow passed in `dataflow` and renders it.\n     * If the dataflow is not compatible with the currently loaded specification or is not\n     * in the dataflow format, then some of the dataflow may be not loaded and an\n     * error is returned. Dataflow should be passed in PipelineManager format (translation\n     * to Baklava format is done )\n     *\n     * @param dataflow Dataflow to load. Can be either an object or a string\n     * @param preventCentering Boolean Blocks view in the same spot.\n     * @param loadOnly determines whether to load the graph only without adjusting\n     * @param templateName {string|null} name of the template, if the graph is a template\n     * the graph rendering. Can be used when validating graphs without their browser\n     * representation.\n     * @returns An array of errors that occurred during the dataflow loading.\n     * If the array is empty, the loading was successful.\n     */\n    async loadDataflow(\n        dataflow, preventCentering = false, loadOnly = false, templateName = null,\n    ) {\n        let { notifyWhenChanged } = this;\n        // Turn off notification during dataflow loading\n        this.updateMetadata({ notifyWhenChanged: false }, true, true);\n        try {\n            const validationErrors = EditorManager.validateDataflow(dataflow);\n            if (validationErrors.length) {\n                return { errors: validationErrors, warnings: [] };\n            }\n\n            try {\n                if (typeof dataflow === 'string' || dataflow instanceof String) {\n                    dataflow = jsonlint.parse(dataflow);\n                }\n\n                const specificationVersion = dataflow.version;\n                const warnings = [];\n                const info = [];\n\n                if (specificationVersion === undefined) {\n                    warnings.push(\n                        `Loaded dataflow has no version assigned. Please update the dataflow to version ${this.specificationVersion}.`,\n                    );\n                } else if (specificationVersion !== this.specificationVersion) {\n                    info.push(\n                        `Dataflow version (${specificationVersion}) differs from the current version (${this.specificationVersion}). It may result in unexpected behaviour.`,\n                    );\n                }\n\n                if ('metadata' in dataflow && this.specification.currentSpecification !== undefined) {\n                    const errors = EditorManager.validateMetadata(dataflow.metadata);\n                    if (Array.isArray(errors) && errors.length) {\n                        return { errors, warnings };\n                    }\n                    notifyWhenChanged = dataflow.metadata.notifyWhenChanged ?? notifyWhenChanged;\n\n                    this.updateMetadata(\n                        { ...dataflow.metadata, notifyWhenChanged: false },\n                        true,\n                        true,\n                    );\n                }\n                if (this.baklavaView.displayedGraph !== undefined) {\n                    // Delete baklava internal history listeners\n                    this.baklavaView.history.unsubscribeFromGraphEvents(\n                        this.baklavaView.displayedGraph,\n                        Symbol('HistoryToken'),\n                    );\n                }\n\n                let isWebpack = true;\n                try {\n                    isWebpack = window.isWebpack;\n                } catch {\n                    isWebpack = false;\n                }\n\n                const errors = {};\n                if (!isWebpack) {\n                    Object.assign(errors, {\n                        errors: await this.baklavaView.editor.load(\n                            dataflow,\n                            preventCentering,\n                            loadOnly,\n                            templateName,\n                        ),\n                        warnings,\n                        info,\n                    });\n                    this.baklavaView.history.graphSwitch(\n                        this.baklavaView.displayedGraph,\n                        this.baklavaView.displayedGraph,\n                    );\n                } else {\n                    Object.assign(errors, {\n                        errors: [],\n                        warnings: [],\n                    });\n                }\n\n                this.verifyExposedInterfaceNamesMatchExternalNames(dataflow);\n\n                return errors;\n            } catch (err) {\n                return {\n                    errors: [\n                        'Unrecognized format. Make sure that the passed dataflow is correct.',\n                        err.toString(),\n                    ],\n                    warnings: [],\n                    info: [],\n                };\n            }\n        } finally {\n            // Restore previous state or use value from loaded dataflow\n            this.updateMetadata({ notifyWhenChanged }, true);\n        }\n    }\n\n    /**\n     * Verify whether exposed interfaces' names match their counterparts' external names.\n     *\n     * @param {object} dataflow Dataflow with external names to verify.\n     * @returns {boolean} True if all exposed interfaces' names match external names.\n     */\n    verifyExposedInterfaceNamesMatchExternalNames(dataflow) {\n        // Collect same-id interfaces to groups.\n        const sameIdInterfaces = new Map();\n        dataflow.graphs.forEach((graph) => {\n            graph.nodes.forEach((node) => {\n                node.interfaces.forEach((intf) => {\n                    if (sameIdInterfaces.has(intf.id)) {\n                        sameIdInterfaces.get(intf.id).push(intf);\n                    } else {\n                        sameIdInterfaces.set(intf.id, [intf]);\n                    }\n                });\n            });\n        });\n\n        // Process groups of two or more interfaces to find mismatches.\n        sameIdInterfaces.forEach((interfaces, sharedId) => {\n            // Single-copy interface is not exposed.\n            if (interfaces.length < 2) {\n                return;\n            }\n\n            // Main interface is the original non-exposed interface with `externalName`.\n            const mainInterface = interfaces.find(\n                (intf) => intf.externalName !== undefined,\n            );\n\n            if (mainInterface === undefined) {\n                throw new Error(\n                    `The interface with id = ${sharedId} seems to ` +\n                    `be exposed but lacks \"externalName\" property.`,\n                );\n            }\n\n            interfaces.forEach((intf) => {\n                // Skip the main_interface itself and matching interface names.\n                if (intf === mainInterface || mainInterface.externalName === intf.name) {\n                    return;\n                }\n                const errorMessage =\n                    `Mismatch between \"externalName\" of the original interface ` +\n                    `and \"name\" of the exposed version of the interface, ` +\n                    `for the interface with id = ${sharedId}\\n` +\n                    `Expected: ${mainInterface.externalName}\\n` +\n                    `Got: ${intf.name}`;\n                throw new Error(errorMessage);\n            });\n        });\n    }\n\n    /**\n     * Static function used to get the instance of the EditorManager in a singleton manner.\n     * If there is no existing instance of the EditorManager then a new one is created.\n     *\n     * @returns Instance of EditorManager.\n     */\n    static getEditorManagerInstance() {\n        if (!EditorManager.instance) {\n            EditorManager.instance = new EditorManager();\n        }\n        return EditorManager.instance;\n    }\n\n    /**\n     * Static function used to apply string replacement mapping on urls.\n     * @param specification - specification to be modified.\n     * @param overrides - mapping between old and new values.\n     */\n    static applyUrlOverrides(specification, overrides) {\n        Object.entries(overrides).forEach(([oldValue, newValue]) => {\n            // Icons\n            Object.entries(specification.metadata?.icons ?? {}).forEach(([key, value]) => {\n                specification.metadata.icons[key] = value.replaceAll(oldValue, newValue);\n            });\n\n            // urls\n            Object.values(specification.metadata?.urls ?? {}).forEach((item) => {\n                item.url = item.url.replaceAll(oldValue, newValue);\n            });\n        });\n    }\n\n    /**\n     * Adds style to all nodes in the specification.\n     *\n     * @param {object} specification specification to modify.\n     * @param {string|Array<string>} style style to be applied\n     */\n    static includeWithStyle(specification, style) {\n        specification.nodes?.forEach((node) => {\n            const mergeStyles = EditorManager.mergeStyles(node.style, style);\n            if (mergeStyles !== undefined) node.style = mergeStyles;\n        });\n    }\n\n    /**\n     * Merges two styles.\n     *\n     * @param {string|Array<string>|undefined} style1 first style.\n     * @param {string|Array<string>|undefined} style2 second style.\n     * @returns {Array<string>|undefined} merged style.\n     */\n    static mergeStyles(style1, style2) {\n        if (style1 === style2) return style1;\n        if ((style1 && style2) === undefined) return style1 ?? style2;\n\n        [style1, style2] = [style1, style2]\n            .map((style) => (Array.isArray(style) ? style : [style]))\n            .map((style) => new Set(style));\n\n        style1 = style1.difference(style2);\n\n        return Array.from(style1.union(style2));\n    }\n\n    /**\n     * Static helper function to merge two object instances into a single.\n     * The following rules are applied:\n     * - If the property is an array then it is concatenated\n     * - If the property is an object then it is merged with preference to the first object\n     * - If the property is a simple type then it is overwritten with the first object\n     * - On type mismatch (array/object), the first object is used\n     *\n     * @param primaryObject First object to merge\n     * @param secondaryObject Second object to merge\n     * @returns Primary object with merged properties from the secondary object\n     */\n    static mergeObjects(primaryObject, secondaryObject) {\n        const warnings = [];\n        const errors = [];\n\n        // Check if any of the object is undefined\n        secondaryObject = secondaryObject ?? {};\n        if (primaryObject === undefined || Object.keys(primaryObject).length === 0) {\n            return { errors, warnings };\n        }\n\n        // Merge object\n        Object.entries(secondaryObject).forEach(([key, value]) => {\n            if (Array.isArray(value) && Array.isArray(primaryObject[key])) {\n                if (key === 'graphs') {\n                    // Merge graphs by ID\n                    const objsToMerge = [value, primaryObject[key]]\n                        .map((graphs) => graphs.map((graph) => [graph.id, graph]))\n                        .map(Object.fromEntries);\n                    primaryObject[key] = Object.values(Object.assign({}, ...objsToMerge));\n                    return;\n                }\n\n                if (key !== 'nodes') {\n                    primaryObject[key].push(...value);\n                    return;\n                }\n\n                // Merge nodes by names\n                try {\n                    // Rename\n                    const renameMapping = Object.fromEntries(primaryObject[key]\n                        .filter((node) => node.includeName)\n                        .map((node) => [node.includeName, EditorManager.getNodeName(node)]));\n\n                    const usedKeys = new Set();\n                    const conditionalRename = (node) => {\n                        const name = EditorManager.getNodeName(node);\n                        const mapped = renameMapping[name];\n                        if (mapped !== undefined) { usedKeys.add(name); }\n                        return mapped ?? name;\n                    };\n\n                    const objsToMerge = [\n                        value.map((node) => [conditionalRename(node), node]),\n                        primaryObject[key].map((node) => [EditorManager.getNodeName(node), node]),\n                    ].map(Object.fromEntries);\n\n                    // Merge\n                    primaryObject[key] = Object.values(Object.assign({}, ...objsToMerge));\n\n                    // Check usage of `includeName` directive\n                    const unusedKeys = Object.keys(renameMapping)\n                        .filter((name) => !usedKeys.has(name));\n\n                    if (unusedKeys.length) {\n                        warnings.push(`Unused include names: ${unusedKeys}`);\n                    }\n                } catch (error) {\n                    errors.push(error);\n                }\n            } else if (typeof value === 'object' && typeof primaryObject[key] === 'object') {\n                // For example, metadata is an object and it has to be merged instead of overwritten\n                const {\n                    errors: mergeErrors, warnings: mergeWarnings,\n                } = EditorManager.mergeObjects(primaryObject[key], value);\n                errors.push(...mergeErrors);\n                warnings.push(...mergeWarnings);\n            } else {\n                primaryObject[key] = value;\n            }\n        });\n        return { errors, warnings };\n    }\n\n    /**\n     * Extracts name of the node.\n     *\n     * @param {Object} node to check.\n     * @returns {string} name of the node.\n     * @throws {Error} Throws if there are any naming inconsistencies.\n     */\n    static getNodeName(node) {\n        if (!node.isCategory) {\n            if (node.name === undefined) {\n                throw new Error(`Non-category node has to define field 'name'`);\n            }\n            return node.name;\n        }\n        const name = node.category.split('/').at(-1);\n        if (node.name !== undefined && node.name !== name) {\n            throw new Error(`Node '${node.name}' is a category node and has a name defined different than ${name}`);\n        }\n        return name;\n    }\n\n    /**\n     * Validates JSON data using given JSON schema. If passed `data` is a string that represents\n     * text of specification file then more information about potential errors - like the exact\n     * line of error - is returned.\n     *\n     * @param data Specification file to validate. Can be either a parsed JSON object\n     * or a textual file\n     * @param schema Schema to use\n     * @param reference Reference to part of the schema, e.g. node, interface or property.\n     * @param additionalAjvOptions Additional options to pass to the Ajv constructor\n     * @returns An array of errors. If the array is empty, the validation was successful.\n     */\n    static validateJSONWithSchema(data, schema, reference = '', additionalAjvOptions = {}) {\n        const ajv = new Ajv2019({\n            allowUnionTypes: true,\n            // Schema used in compile() may be already included in `schemas`.\n            addUsedSchema: false,\n            formats: {\n                hex: /^0x[a-fA-F0-9]+$/,\n            },\n            schemas: [\n                unresolvedSpecificationSchema,\n                specificationSchema,\n                metadataSchema,\n                dataflowSchema,\n                graphSchema,\n            ],\n            ...additionalAjvOptions,\n        });\n        ajv.addKeyword('version');\n\n        ajv.addSchema(schema, 'root');\n        const validate = ajv.getSchema(`root${reference}`);\n        if (validate === undefined) {\n            return [`Invalid value of \"reference\" parameter: ${reference}`];\n        }\n\n        const isTextFormat = typeof data === 'string' || data instanceof String;\n        let dataJSON;\n\n        try {\n            dataJSON = isTextFormat ? jsonlint.parse(data) : data;\n        } catch (exception) {\n            return [`Not a proper JSON file: ${exception.toString()}`];\n        }\n\n        const valid = validate(dataJSON);\n\n        if (valid) {\n            return [];\n        }\n\n        // Parsing errors messages to a human readable string\n        const errors = validate.errors.map((error) => {\n            // It is assumed that the id of the schema is for example `dataflow_schema`\n            // Here a prefix is obtained\n            const nameOfEntity = schema.$id.split('_').slice(0, -1).join('_');\n            const path = `${nameOfEntity}${error.instancePath}`;\n            let errorPrefix = '';\n\n            if (isTextFormat) {\n                const result = jsonMap.parse(data);\n                // 1 is added as the lines are numbered from 0\n                const lineStart = result.pointers[error.instancePath].value.line + 1;\n                const lineEnd = result.pointers[error.instancePath].valueEnd.line + 1;\n\n                if (lineStart === lineEnd) {\n                    errorPrefix = `Line ${lineStart} -`;\n                } else {\n                    errorPrefix = `Lines ${lineStart}-${lineEnd} -`;\n                }\n            }\n\n            switch (error.keyword) {\n                case 'enum':\n                    return `${errorPrefix} ${path} ${error.message} - ${stringify(\n                        error.params.allowedValues,\n                    )}`;\n                case 'additionalProperties':\n                    return `${errorPrefix} ${path} ${error.message} - ${stringify(\n                        error.params.additionalProperty,\n                    )}`;\n                case 'const':\n                    return `${errorPrefix} ${path} ${error.message} - ${stringify(\n                        error.params.allowedValue,\n                    )}`;\n                case 'unevaluatedProperties':\n                    return `${errorPrefix} ${path} ${error.message} - ${stringify(\n                        error.params.unevaluatedProperty,\n                    )}}`;\n                // Those errors are not informative at all\n                case 'not':\n                case 'oneOf':\n                    return '';\n                default:\n                    return `${errorPrefix} ${path} ${error.message}`;\n            }\n        });\n\n        return errors.filter((err) => err !== '');\n    }\n\n    validateResolvedSpecification(specification) {\n        const validationErrors = EditorManager.validateSpecification(\n            specification, specificationSchema);\n        if (validationErrors.length) return validationErrors;\n\n        // Validating category nodes\n        const { nodes } = specification;\n        const categoryNodes = nodes.filter((node) => node.isCategory);\n        const definedCategories = {};\n\n        // Finding multiple category nodes defining the same category\n        const errors = [];\n        categoryNodes.forEach((node) => {\n            if (node.name in definedCategories) {\n                errors.push(`Category '${node.category}' has multiple nodes defining it.`);\n            } else {\n                definedCategories[node.name] = node.category.split('/').slice(0, -1).join('/');\n            }\n        });\n\n        // Nodes have to extend the first category node in their category path.\n        // For example, if we have two category nodes A and C and we have a node e\n        // which has a category 'A/b/C/d/e' then it has to extend C (and C has to extend A)\n        const nodeNames = new Set();\n        nodes.forEach((node) => {\n            if (node.category === undefined) {\n                node.category = '';\n            }\n            const categories = node.category.split('/');\n\n            for (let i = categories.length - 1; i >= 0; i -= 1) {\n                const categoryNodeName = categories[i];\n                const remainingCategories = categories.slice(0, i).join('/');\n\n                if (\n                    categoryNodeName in definedCategories &&\n                    node.name !== categoryNodeName &&\n                    remainingCategories === definedCategories[categoryNodeName]\n                ) {\n                    if (\n                        node.extends === undefined ||\n                        !node.extends.includes(categoryNodeName)\n                    ) {\n                        errors.push(`Node '${node.name}' does not extend its category node '${categoryNodeName}'.`);\n                    }\n                    break;\n                }\n            }\n\n            // Nodes that extend from a category node have to be in their subtree i.e. have a common\n            // category prefix with the category node\n            for (let i = 0; i < (node.extends ?? []).length; i += 1) {\n                const extendedNode = node.extends[i];\n                if (extendedNode in definedCategories) {\n                    const commonPrefix = definedCategories[extendedNode] !== '' ?\n                        `${definedCategories[extendedNode]}/${extendedNode}` : extendedNode;\n\n                    if (!node.category.includes(commonPrefix)) {\n                        errors.push(\n                            `Node '${node.name}' extends from a category node '${extendedNode}' but is not in its category`,\n                        );\n                        break;\n                    }\n                }\n            }\n\n            // Finding multiple nodes with the same name\n            if (nodeNames.has(node.name)) {\n                errors.push(`Node '${node.name}' is defined multiple times`);\n            }\n            nodeNames.add(node.name);\n        });\n\n        return errors;\n    }\n\n    /**\n     * Validates a single node passed in `nodeSpecification` using jsonSchema.\n     *\n     * @param nodeSpecification Node to validate\n     * @returns An array of errors. If the array is empty, the validation was successful.\n     */\n    /* eslint-disable class-methods-use-this */\n    validateNode(nodeSpecification, schema = unresolvedSpecificationSchema) {\n        return EditorManager.validateJSONWithSchema(nodeSpecification, schema, '#/$defs/node');\n    }\n\n    /**\n     * Validates a single property passed in `propertySpecification` using jsonSchema.\n     *\n     * @param propertySpecification Property to validate\n     * @returns An array of errors. If the array is empty, the validation was successful.\n     */\n    validateNodeProperty(\n        propertySpecification,\n        schema = unresolvedSpecificationSchema,\n    ) {\n        return EditorManager.validateJSONWithSchema(propertySpecification, schema, '#/$defs/property');\n    }\n\n    /**\n     * Validates a single interface passed in `interfaceSpecification` using jsonSchema.\n     *\n     * @param interfaceSpecification Interface to validate\n     * @returns An array of errors. If the array is empty, the validation was successful.\n     */\n    validateNodeInterface(\n        interfaceSpecification,\n        schema = unresolvedSpecificationSchema,\n    ) {\n        return EditorManager.validateJSONWithSchema(interfaceSpecification, schema, '#/$defs/interface');\n    }\n\n    /**\n     * Validates specification passed in `specification` using jsonSchema.\n     *\n     * @param specification Specification to validate\n     * @returns An array of errors. If the array is empty, the validation was successful.\n     */\n    static validateSpecification(specification, schema = unresolvedSpecificationSchema) {\n        return EditorManager.validateJSONWithSchema(specification, schema);\n    }\n\n    /**\n     * Validates metadata in JSON format using schema from unresolvedSpecificationSchema.\n     *\n     * @param jsonmetadata metadata in JSON format to validate\n     * @return An array of errors. If the array is empty, the validation was successful.\n     */\n    static validateMetadata(jsonmetadata) {\n        return EditorManager.validateJSONWithSchema(jsonmetadata, metadataSchema);\n    }\n\n    /**\n     * Validates metadata in JSON format using schema from dataflowSchema.\n     *\n     * @param dataflow dataflow in JSON format to validate\n     * @return An array of errors. If the array is empty, the validation was successful.\n     */\n    static validateDataflow(dataflow) {\n        return EditorManager.validateJSONWithSchema(dataflow, dataflowSchema);\n    }\n\n    /**\n     * Validates message in JSON format using schema from messageSchema.\n     *\n     * @param message message in JSON format to validate\n     * @return An array of errors. If the array is empty, the validation was successful.\n     */\n    static validateMessage(message) {\n        return EditorManager.validateJSONWithSchema(message, messageSchema);\n    }\n\n    /**\n     * Checks whether currently edited pipeline is one of the subgraphs\n     *\n     * @returns True if editor is editing subgraph instance, false otherwise\n     */\n    isInsideSubgraph() {\n        return this.baklavaView.displayedGraph !== this.baklavaView.editor.graph;\n    }\n\n    /**\n     * Switches the editor state to main graph\n     */\n    returnFromSubgraph() {\n        this.baklavaView.editor.backFromSubgraph(this.baklavaView.displayedGraph);\n    }\n\n    /**\n     * Centers the editor view and resets zoom level\n     */\n    centerZoom() {\n        this.baklavaView.editor.centerZoom();\n    }\n\n    /**\n     * Updates name of currently displayed graph\n     */\n    updateSubgraphName(name) {\n        this.editor.updateCurrentSubgraphName(name);\n    }\n\n    get notifyWhenChanged() {\n        return this.updatedMetadata.notifyWhenChanged ??\n            this.specification.currentSpecification?.metadata?.notifyWhenChanged ??\n            this.defaultMetadata.notifyWhenChanged;\n    }\n}\n","/*\n * Copyright (c) 2022-2024 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n/* eslint-disable max-classes-per-file */\nimport { reactive, ref, watch, } from 'vue';\nimport { v4 as uuidv4 } from 'uuid';\nimport { configurationState } from './nodeCreation/ConfigurationState.ts';\nexport const suppressingHistory = ref(false);\nconst transactionId = ref('');\nexport class Step {\n    constructor(type, topic, tid = uuidv4()) {\n        Object.defineProperty(this, \"type\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"transactionId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // I need this to be of basically any type, as\n        // it may need to receive objects, arrays of objects, other steps\n        /* eslint-disable @typescript-eslint/no-explicit-any */\n        Object.defineProperty(this, \"topic\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.type = type;\n        this.topic = topic;\n        this.transactionId = tid;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    add(graph) {\n        throw new Error(`Method add has thrown an error for topic: ${this.topic}`);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    remove(graph) {\n        throw new Error(`Method remove has thrown an error for topic: ${this.topic}`);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    edit(graph) {\n        throw new Error(`Method edit has thrown an error for topic: ${this.topic}`);\n    }\n}\nclass NodeStep extends Step {\n    constructor(type, topic, tid = uuidv4()) {\n        if (tid === '')\n            tid = uuidv4(); // eslint-disable-line no-param-reassign\n        super(type, topic, tid);\n        Object.defineProperty(this, \"nodeTuple\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n    }\n    add(graph) {\n        if (this.nodeTuple[0] !== undefined) {\n            const n = graph.value.addNode(this.nodeTuple[0]);\n            n.load(this.nodeTuple[1]);\n        }\n    }\n    remove(graph) {\n        const node = graph.value.nodes.find((n) => n.id === this.topic);\n        if (node !== undefined) {\n            this.nodeTuple = [node, node.save()];\n            graph.value.removeNode(node);\n        }\n    }\n    edit(graph) {\n        if (this.nodeTuple[0] !== undefined) {\n            // save node connections\n            const interfaces = [\n                ...Object.values(this.nodeTuple[0].inputs),\n                ...Object.values(this.nodeTuple[0].outputs),\n            ];\n            const connections = graph.value.connections.filter((c) => interfaces.includes(c.from) || interfaces.includes(c.to));\n            // remove the current version of the node\n            graph.value.removeNode(this.nodeTuple[0]);\n            // save the current version and load the previous save\n            const n = graph.value.addNode(this.nodeTuple[0]);\n            const save = this.nodeTuple[1];\n            this.nodeTuple = [this.nodeTuple[0], this.nodeTuple[0].save()];\n            n.load(save);\n            // restore connections\n            connections.forEach((conn) => {\n                graph.value.addConnection(conn.from, conn.to);\n            });\n        }\n    }\n}\nclass ConnectionStep extends Step {\n    constructor(type, topic, tid = uuidv4()) {\n        if (tid === '')\n            tid = uuidv4(); // eslint-disable-line no-param-reassign\n        super(type, topic, tid);\n        Object.defineProperty(this, \"conn\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: undefined\n        });\n    }\n    add(graph) {\n        if (this.conn !== undefined) {\n            // The object of the interfaces itself has changed and despite\n            // having all the same fields, it will not assign the connection\n            // correctly. That's why it is necessary to extract the nodeId\n            // from what we have and find the interface in said node manually\n            const fromNode = graph.value.findNodeById(this.conn.from.nodeId);\n            const toNode = graph.value.findNodeById(this.conn.to.nodeId);\n            if (!fromNode || !toNode)\n                return;\n            const from = [\n                ...Object.values(fromNode.inputs),\n                ...Object.values(fromNode.outputs),\n            ].filter((iface) => iface.port).find((iface) => iface.id === this.conn.from.id);\n            const to = [\n                ...Object.values(toNode.inputs),\n                ...Object.values(toNode.outputs),\n            ].filter((iface) => iface.port).find((iface) => iface.id === this.conn.to.id);\n            if (!from || !to)\n                return;\n            const connAdded = graph.value.addConnection(from, to);\n            if (connAdded === undefined) {\n                return;\n            }\n            connAdded.id = this.conn.id;\n        }\n    }\n    remove(graph) {\n        const conn = graph.value.connections.find((n) => n.id === this.topic);\n        if (conn !== undefined) {\n            this.conn = conn;\n            graph.value.removeConnection(conn);\n        }\n    }\n}\nclass AnchorStep extends Step {\n    constructor(type, topic, tid = uuidv4()) {\n        if (tid === '')\n            tid = uuidv4(); // eslint-disable-line no-param-reassign\n        super(type, topic, tid);\n        Object.defineProperty(this, \"anchor\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: undefined\n        });\n    }\n    add(graph) {\n        if (this.anchor !== undefined) {\n            const conn = graph.value.connections.find((n) => n.from.id === this.anchor[0].from.id &&\n                n.to.id === this.anchor[0].to.id &&\n                n.id === this.anchor[0].id);\n            if (conn !== undefined)\n                if (conn.anchors === undefined)\n                    conn.anchors = [];\n            conn.anchors.splice(this.anchor[2], 0, this.anchor[1]);\n        }\n    }\n    remove(graph) {\n        if (this.anchor !== undefined) {\n            const conn = graph.value.connections.find((n) => n.from === this.anchor[0].from && n.to === this.anchor[0].to);\n            if (conn !== undefined)\n                conn.anchors.splice(this.anchor[2], 1);\n        }\n    }\n}\nexport function suppressHistoryLogging(value) {\n    suppressingHistory.value = value;\n}\nexport function startTransaction(id = uuidv4()) {\n    if (transactionId.value !== '')\n        return undefined;\n    transactionId.value = id;\n    return id;\n}\nexport function commitTransaction() {\n    transactionId.value = '';\n}\nexport function useHistory(graph, commandHandler) {\n    const token = Symbol('CustomHistoryToken');\n    const maxSteps = 200;\n    const history = new Map();\n    const undoneHistory = new Map();\n    let currentId = 'ThisShouldNotAppearInHistoryMaps';\n    let oldId = 'ThisShouldNotAppearInHistoryMaps';\n    const unsubscribeFromGraphEvents = (g, tok) => {\n        g.events.addNode.unsubscribe(tok);\n        g.events.removeNode.unsubscribe(tok);\n        g.events.editNode.unsubscribe(tok);\n        g.events.addConnection.unsubscribe(tok);\n        g.events.removeConnection.unsubscribe(tok);\n        g.events.addAnchor.unsubscribe(tok);\n        g.events.removeAnchor.unsubscribe(tok);\n    };\n    // Switch all the events to any new graph that's displayed\n    const graphSwitch = (newGraph, oldGraph, copyStateStack = false) => {\n        if (oldGraph) {\n            unsubscribeFromGraphEvents(oldGraph, token);\n        }\n        if (newGraph) {\n            oldId = currentId;\n            currentId = newGraph.id;\n            if (history.get(currentId) === undefined)\n                history.set(currentId, []);\n            if (undoneHistory.get(currentId) === undefined)\n                undoneHistory.set(currentId, []);\n            if (copyStateStack) {\n                const undoneItem = undoneHistory.get(oldId);\n                if (undoneItem)\n                    undoneHistory.set(currentId, undoneItem);\n                const historyItem = history.get(oldId);\n                if (historyItem)\n                    history.set(currentId, historyItem);\n            }\n            newGraph.events.addNode.subscribe(token, (node) => {\n                var _a;\n                // Suppressing node that are being created as its hard\n                // to keep the history trace consistent\n                if (((_a = configurationState.nodeData) === null || _a === void 0 ? void 0 : _a.name) === node.type)\n                    return;\n                if (!suppressingHistory.value) {\n                    const historyItem = history.get(newGraph.id);\n                    if (!historyItem)\n                        return;\n                    historyItem.push(new NodeStep('add', node.id.toString(), transactionId.value));\n                    undoneHistory.set(newGraph.id, []);\n                }\n            });\n            newGraph.events.removeNode.subscribe(token, (node) => {\n                var _a;\n                if (!suppressingHistory.value) {\n                    // Suppressing node that are being created as its hard\n                    // to keep the history trace consistent\n                    if (((_a = configurationState.nodeData) === null || _a === void 0 ? void 0 : _a.name) === node.type)\n                        return;\n                    const historyItem = history.get(newGraph.id);\n                    if (!historyItem)\n                        return;\n                    const step = new NodeStep('rem', node.id.toString(), transactionId.value);\n                    historyItem.push(step);\n                    step.nodeTuple = [node, node.save()];\n                    undoneHistory.set(newGraph.id, []);\n                }\n            });\n            newGraph.events.editNode.subscribe(token, (node) => {\n                if (!suppressingHistory.value) {\n                    const historyItem = history.get(newGraph.id);\n                    if (!historyItem)\n                        return;\n                    const step = new NodeStep('edit', node.id.toString(), transactionId.value);\n                    historyItem.push(step);\n                    step.nodeTuple = [node, node.save()];\n                    undoneHistory.set(newGraph.id, []);\n                }\n            });\n            newGraph.events.addConnection.subscribe(token, (conn) => {\n                if (!suppressingHistory.value) {\n                    const historyItem = history.get(newGraph.id);\n                    if (!historyItem)\n                        return;\n                    historyItem.push(new ConnectionStep('add', conn.id.toString(), transactionId.value));\n                    undoneHistory.set(newGraph.id, []);\n                }\n            });\n            newGraph.events.removeConnection.subscribe(token, (conn) => {\n                var _a;\n                if (!suppressingHistory.value) {\n                    const inTransaction = transactionId.value !== '';\n                    if (!inTransaction)\n                        startTransaction();\n                    const historyItem = history.get(newGraph.id);\n                    if (!historyItem)\n                        return;\n                    ((_a = conn.anchors) !== null && _a !== void 0 ? _a : []).slice().reverse().forEach((anchor) => {\n                        newGraph.events.removeAnchor.emit([conn, conn.anchors.indexOf(anchor)]);\n                    });\n                    const step = new ConnectionStep('rem', conn.id.toString(), transactionId.value);\n                    historyItem.push(step);\n                    step.conn = conn;\n                    undoneHistory.set(newGraph.id, []);\n                    if (!inTransaction)\n                        commitTransaction();\n                }\n            });\n            newGraph.events.addAnchor.subscribe(token, (tuple) => {\n                if (!suppressingHistory.value) {\n                    const historyItem = history.get(newGraph.id);\n                    if (!historyItem)\n                        return;\n                    const idx = Math.trunc((tuple[1] - 1) / 3);\n                    const conn = tuple[0];\n                    const step = new AnchorStep('add', conn.anchors[idx].id.toString(), transactionId.value);\n                    historyItem.push(step);\n                    step.anchor = [conn, conn.anchors[idx], idx];\n                    undoneHistory.set(newGraph.id, []);\n                }\n            });\n            newGraph.events.removeAnchor.subscribe(token, (tuple) => {\n                if (!suppressingHistory.value) {\n                    const historyItem = history.get(newGraph.id);\n                    if (!historyItem)\n                        return;\n                    const idx = tuple[1];\n                    const conn = tuple[0];\n                    const step = new AnchorStep('rem', conn.anchors[idx].id.toString(), transactionId.value);\n                    historyItem.push(step);\n                    step.anchor = [conn, conn.anchors[idx], idx];\n                    undoneHistory.set(newGraph.id, []);\n                }\n            });\n        }\n    };\n    watch(graph, (newGraph, oldGraph) => graphSwitch(newGraph, oldGraph), { flush: 'post', immediate: true });\n    const singleStepTransaction = (mainHistory, auxiliaryHistory) => {\n        const step = mainHistory.pop();\n        if (step === undefined)\n            return;\n        suppressingHistory.value = true;\n        if (step.type === 'add') {\n            step.type = 'rem';\n            step.remove(graph);\n        }\n        else if (step.type === 'rem') {\n            step.type = 'add';\n            step.add(graph);\n        }\n        else if (step.type === 'edit') {\n            step.type = 'edit';\n            step.edit(graph);\n        }\n        auxiliaryHistory.push(step);\n        if (mainHistory.length > 0 &&\n            mainHistory[mainHistory.length - 1].transactionId === step.transactionId)\n            singleStepTransaction(mainHistory, auxiliaryHistory);\n        suppressingHistory.value = false;\n        graph.value.selectedNodes.splice(0, graph.value.selectedNodes.length);\n    };\n    commandHandler.registerCommand('undo', {\n        canExecute: () => true,\n        execute: () => {\n            const historyItem = history.get(currentId);\n            if (historyItem && historyItem.length !== 0) {\n                const undoneItem = undoneHistory.get(currentId);\n                if (historyItem && undoneItem)\n                    singleStepTransaction(historyItem, undoneItem);\n            }\n        },\n    });\n    commandHandler.registerCommand('redo', {\n        canExecute: () => true,\n        execute: () => {\n            const historyItem = history.get(currentId);\n            const undoneItem = undoneHistory.get(currentId);\n            if (historyItem && undoneItem && undoneItem.length !== 0) {\n                singleStepTransaction(undoneItem, historyItem);\n            }\n        },\n    });\n    commandHandler.registerCommand('START_TRANSACTION', {\n        canExecute: () => transactionId.value === '',\n        execute: () => startTransaction,\n    });\n    commandHandler.registerCommand('COMMIT_TRANSACTION', {\n        canExecute: () => transactionId.value !== '',\n        execute: () => commitTransaction,\n    });\n    commandHandler.registerHotkey(['Control', 'z'], 'undo');\n    commandHandler.registerHotkey(['Control', 'y'], 'redo');\n    return reactive({\n        max_steps: maxSteps,\n        graphSwitch,\n        unsubscribeFromGraphEvents,\n    });\n}\n","/*\n * Copyright (c) 2022-2024 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Module handles the autolayout calculations.\n * Defines intermediate graph representation, containing:\n * - nodes - list of nodes with properties:\n *   - id - unique id\n *   - width, height - node dimensions\n *   - position - position set after the calculations with the layout engine is done.\n * - connections - list of connections in a graph, each defines property:\n *   - id - unique id\n *   - from - id of the starting node\n *   - to - id of node at the end point\n *\n * Layout Manager contains list of registered layout engines. Layout engines are\n * requested by user in a specification. If no layout engine is set, the default option\n * (setting position to (0, 0)) is used\n */\n\nimport CytoscapeLayoutEngine from './layoutEngines/cytoscapeEngine.js';\nimport NoLayoutAlgorithm from './layoutEngines/noLayoutEngine.js';\n\n/* eslint-disable no-param-reassign */\nfunction dataflowToGraph(dataflow) {\n    const interfaceToNodeId = new Map();\n    dataflow.nodes.forEach((node) => {\n        node.interfaces.forEach((intf) => interfaceToNodeId.set(intf.id, node.id));\n    });\n\n    const nodes = dataflow.nodes\n        .filter((node) => node.position === undefined)\n        .map((node) => ({\n            id: node.id,\n        }));\n    const connections = dataflow.connections\n        .filter(\n            (connection) =>\n                nodes.filter((nodeState) => nodeState.id === interfaceToNodeId.get(connection.from))\n                    .length > 0 &&\n                nodes.filter((nodeState) => nodeState.id === interfaceToNodeId.get(connection.to))\n                    .length > 0,\n        )\n        .map((connection) => ({\n            id: connection.id,\n            from: interfaceToNodeId.get(connection.from),\n            to: interfaceToNodeId.get(connection.to),\n        }));\n    return { nodes, connections };\n}\n\nfunction graphToDataflow(graph, dataflow) {\n    const idToPosition = new Map();\n    graph.nodes.forEach((node) => idToPosition.set(node.id, node.position));\n    dataflow.nodes = dataflow.nodes.map((node) => ({\n        ...node,\n        position: idToPosition.has(node.id) ? idToPosition.get(node.id) : node.position,\n    }));\n    return dataflow;\n}\n\nexport default class LayoutManager {\n    layoutEngine = undefined;\n\n    usedAlgorithm = undefined;\n\n    graph = undefined;\n\n    // Default option when no layout algorithm is specified\n    // Currently it is possible to register it, when more layout algorithms\n    // are added it should be 1) automatically registered 2) not possible to\n    // choose in available algorithms\n    availableEngines = {\n        NoLayout: new NoLayoutAlgorithm(),\n        CytoscapeEngine: new CytoscapeLayoutEngine(),\n    };\n\n    constructor() {\n        this.useAlgorithm('NoLayout');\n    }\n\n    useAlgorithm(algorithm) {\n        const [engineName, algorithmName] = algorithm.split(' - ');\n        const layoutEngine = this.availableEngines[engineName];\n        if (layoutEngine === undefined) {\n            throw new Error(`Could not parse the ${algorithm} autolayout algorithm`);\n        }\n        this.layoutEngine = layoutEngine;\n        if (algorithmName !== undefined) {\n            this.layoutEngine.chooseAlgorithm(algorithmName);\n        }\n        this.usedAlgorithm = algorithm;\n    }\n\n    getAvailableAlgorithms() {\n        return Object.entries(this.availableEngines)\n            .map(([engineName, engine]) => {\n                if (engine.availableAlgorithms.length !== 1) {\n                    return engine.availableAlgorithms.map(\n                        (algorithm) => `${engineName} - ${algorithm}`,\n                    );\n                }\n                return engineName;\n            })\n            .flat();\n    }\n\n    registerGraph(dataflow) {\n        this.graph = dataflowToGraph(dataflow);\n    }\n\n    async computeLayout(dataflow) {\n        this.updateDimensions();\n        const layout = await this.runEngine(this.graph);\n        return graphToDataflow(layout, dataflow);\n    }\n\n    async runEngine(graph) {\n        return this.layoutEngine.calculate(graph);\n    }\n\n    updateDimensions() {\n        this.graph.nodes = this.graph.nodes.map((node) => {\n            const HTMLelement = document.getElementById(node.id);\n            return {\n                ...node,\n                width: HTMLelement.offsetWidth,\n                height: HTMLelement.offsetHeight,\n            };\n        });\n    }\n}\n"],"names":["COPY_COMMAND","DELETE_COMMAND","UNHIGHLIGHT_COMMAND","PASTE_COMMAND","BaklavaInterfaceTypes","types","Map","defaultStyle","interfaceConnectionPattern","interfaceConnectionColor","interfaceColor","constructor","viewPlugin","hooks","renderInterface","subscribe","this","intf","el","type","firstType","normalizeType","find","t","undefined","color","arrow","querySelector","style","backgroundColor","greyArrow","getComputedStyle","getPropertyValue","String","getConnectionStyle","from","to","fromTypes","toTypes","commonTypes","filter","includes","Array","isArray","length","readInterfaceTypes","metadata","interfaces","Object","entries","forEach","io","name","nodeTopPoint","interfaceRef","scaling","panning","nodeHtml","document","getElementById","nodeId","offsetTop","y","nodeBottomPoint","offsetHeight","calculateEllipseR","x","cx","cy","slope","Math","sqrt","abs","NormalizedConnection","x1","y1","x2","y2","connection","direction","ConnectionRenderer","viewModel","randomizedOffset","shiftDistance","getShift","ncFrom","ncTo","graph","shiftIndex","sidePosition","fromInterfaceNeighbours","getInterfaceNeighbors","toInterfaceNeighbours","toRandomIndex","id","reduce","accumulator","char","charCodeAt","fromRandomIndex","randomIndex","randomShiftIndex","getMaxShift","maxFrom","maxTo","node","findNodeById","values","inputs","outputs","c","side","port","someAboveOrBelow","nodeFromTop","nodeToTop","nodeFromBottom","nodeToBottom","curvedRender","nc","dx","rightmost","max","leftmost","min","curvedRenderLoopback","displayedGraph","sideMargin","shift","leftRx","leftRy","renderingSide","leftx","rightx","lefty","righty","bottomY","rightCx","rightCy","rightRx","rightRy","bottomCx","bottomCy","bottomRx","bottomRy","leftCx","leftCy","orthogonalAnchorsPath","anchors","calculatedAnchors","map","anchor","a","path","push","offset","orthogonalRender","minMargin","middlePoint","mid","firstTurn","lastTurn","orthogonalRenderLoopback","xShift","alternativeOrthogonalRender","maxShift","turnDistance","minTurnDistance","minTurnDistanceViolated","maxTurnDistance","interpolatedShift","differentLevels","nodeOverlap","alternativeOrthogonalRenderLoopback","straightRender","concat","straightRenderLoopback","render","loopback","isLoopback","supportsAnchors","Metadata","state","default","DEFAULT_CUSTOM_NODE_NAME","DEFAULT_CUSTOM_NODE_TYPE","DEFAULT_GRAPH_NODE_NAME","DEFAULT_GRAPH_NODE_TYPE","NEW_NODE_STYLE","EDITED_NODE_STYLE","async","loadJsonFromRemoteLocation","customLocation","location","loc","startsWith","relativeurl","href","split","slice","join","jsonsubs","VUE_APP_JSON_URL_SUBSTITUTES","subs","JSON","parse","parts","key","substring","specifiedUrl","keys","replace","parseLocation","fetchedContent","fetch","mode","error","message","json","EditorManager","static","defaultMetadata","editor","baklavaView","specificationLoaded","specification","Specification","getInstance","updatedMetadata","relatedGraphsStore","externalApplicationManager","editorManager","unregisterNodes","connectionRenderer","connectionStyle","layoutManager","useAlgorithm","layout","interfaceTypes","layers","collapseSidebar","movementStep","allowLoopbacks","navbarItems","cache","logLevel","settings","editableNodeTypes","hideAnchors","showIds","newGraphNode","specificationVersion","commandHandler","history","clipboard","token","Symbol","nodeBuffer","connectionBuffer","consecutivePasteNumber","isEmpty","value","findInterface","nodes","i","iface","registerCommand","canExecute","selectedNodes","execute","readonly","registerHotkey","interfacesOfSelectedNodes","flatMap","n","connections","conn","stringify","save","_a","idmap","parsedNodeBuffer","parsedConnectionBuffer","newNodes","newConnections","executeCommand","nodeType","nodeTypes","get","copiedNode","beforeLoad","nodeState","ns","position","graphState","unsubscribe","addNode","mapNewId","obj","newId","set","assignNewIds","subNode","externalName","resolveNewExposedName","Error","load","assign","graphNode","updateExposedInterfaces","fromId","toId","fromIntf","toIntf","newConnection","addConnection","useClipboard","modifiedNodeSpecificationRegistry","updateEditorSpecification","dataflowSpecification","lazyLoad","unmarkNewNodes","urloverrides","jsonlint","errors","warnings","stateNodeId","isSpecificationLoaded","saveDataflow","sidebar","clearEditorManagerState","info","version","currentSpecification","unresolvedSpecification","globalVisitedSpecs","Set","toInclude","fromEntries","include","_","includedSpecification","includeErrors","includeWarnings","downloadNestedImports","graphs","includeGraphsErrors","includeGraphs","mergeErrors","mergeWarnings","mergeObjects","updateMetadata","newErrors","newWarnings","updateGraphSpecification","setSpecificationLoaded","entryGraph","loadDataflow","visible","g","registerGraph","spec","notifyAboutChange","unregisterGraphs","deepCleanEditor","nodeStyles","clear","trace","specificationAndTrace","currentImports","Promise","all","specificationUrl","url","has","add","status","val","specTrace","newSpecification","includeWithStyle","applyUrlOverrides","size","dataflows","dataflow","dataflowMetadata","targetGraph","registerDefaultNodes","customNodeType","category","_registerNodeType","defaultGraphNode","myGraph","subgraphId","addGraphTemplate","updateExtendingNodes","nodeSpecification","nodeToUpdate","unresolvedChildNodes","extends","resolvedChildNodes","parent","getNodeName","resolvedNode","nodeName","_unregisterNodeType","flat","structuredClone","updateParentNode","parentType","parentSpec","parentNodes","extending","splice","indexOf","delete","addNodeToEditorSpecification","removeUnused","properties","validationErrors","validateNode","unresolvedNodeSpecification","resolvedNodeSpecification","includeName","extendingNodes","isCategory","subgraph","then","addSubgraphToNode","newGraph","replaceNode","myNode","layer","interfaceGroups","defaultInterfaceGroups","twoColumn","description","siblings","width","registerNodeType","title","pill","relatedGraphs","icon","getMetadataIcon","nodeIcons","urls","urlName","nodeURLs","baseName","suffix","baseUrl","baseIconUrls","endsWith","unregisterNodeType","getSubgraphs","entryGraphId","includeEntry","graphMapping","usedGraphs","dfs","subgraphs","resolvedNodes","abstract","preprocessedNodes","preprocessNodes","resolveInheritance","e","validateResolvedSpecification","eName","extended","validateNodeStyle","relatedGraphIds","validateGraph","loadArgs","graphs_","loadingErrors","loadingWarnings","warning","graphId","_graph","uniqueWarnings","defaultErrors","defaultWarnings","some","entryErrors","newGraphInstance","overriding","loading","newMetadata","tempMetadata","baseURLs","icons","iconName","hideHud","styles","background","gridSize","backgroundSize","toggleableEditableTypes","editableTypes","ignoredLayers","welcome","unsortedNodes","isObject","mergeNodes","child","base","output","mergeStyles","baseNames","index","override","recurrentMerge","styleSet","styleName","saveSpecification","warn","getRootGraph","subgraphStack","graphName","dataflowGraph","rootGraph","currVal","m","dm","preventCentering","loadOnly","templateName","notifyWhenChanged","validateDataflow","validateMetadata","unsubscribeFromGraphEvents","isWebpack","window","graphSwitch","verifyExposedInterfaceNamesMatchExternalNames","err","toString","sameIdInterfaces","sharedId","mainInterface","errorMessage","getEditorManagerInstance","instance","overrides","oldValue","newValue","replaceAll","item","style1","style2","difference","union","primaryObject","secondaryObject","objsToMerge","renameMapping","usedKeys","conditionalRename","mapped","unusedKeys","at","validateJSONWithSchema","data","schema","reference","additionalAjvOptions","ajv","allowUnionTypes","addUsedSchema","formats","hex","schemas","addKeyword","addSchema","validate","getSchema","isTextFormat","dataJSON","exception","$id","instancePath","errorPrefix","result","lineStart","pointers","line","lineEnd","valueEnd","keyword","params","allowedValues","additionalProperty","allowedValue","unevaluatedProperty","validateSpecification","categoryNodes","definedCategories","nodeNames","categories","categoryNodeName","remainingCategories","extendedNode","commonPrefix","validateNodeProperty","propertySpecification","validateNodeInterface","interfaceSpecification","jsonmetadata","validateMessage","isInsideSubgraph","returnFromSubgraph","backFromSubgraph","centerZoom","updateSubgraphName","updateCurrentSubgraphName","suppressingHistory","transactionId","Step","topic","tid","defineProperty","enumerable","configurable","writable","remove","edit","NodeStep","super","nodeTuple","removeNode","ConnectionStep","fromNode","toNode","connAdded","removeConnection","AnchorStep","suppressHistoryLogging","startTransaction","commitTransaction","useHistory","undoneHistory","currentId","oldId","tok","events","editNode","addAnchor","removeAnchor","oldGraph","copyStateStack","undoneItem","historyItem","nodeData","step","inTransaction","reverse","emit","tuple","idx","trunc","flush","immediate","singleStepTransaction","mainHistory","auxiliaryHistory","pop","max_steps","LayoutManager","layoutEngine","usedAlgorithm","availableEngines","NoLayout","CytoscapeEngine","algorithm","engineName","algorithmName","chooseAlgorithm","getAvailableAlgorithms","engine","availableAlgorithms","interfaceToNodeId","dataflowToGraph","computeLayout","updateDimensions","idToPosition","graphToDataflow","runEngine","calculate","HTMLelement","offsetWidth","height"],"sourceRoot":""}