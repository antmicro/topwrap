{"version":3,"file":"js/index-2d0f0968.bc98a765.js","mappings":"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","sources":["webpack://pipeline-manager/./src/core/communication/externalApp/backend.ts","webpack://pipeline-manager/./src/core/communication/connectionManager.ts","webpack://pipeline-manager/./src/core/communication/externalApp/frontend.ts","webpack://pipeline-manager/./src/core/communication/ExternalApplicationManager.js","webpack://pipeline-manager/./src/core/communication/runInformation.ts","webpack://pipeline-manager/./src/core/events.js","webpack://pipeline-manager/./src/core/NodeFactory.js","webpack://pipeline-manager/./src/core/nodeCreation/ConfigurationState.ts","webpack://pipeline-manager/./src/core/layoutEngines/cytoscapeEngine.js","webpack://pipeline-manager/./src/core/interfaceParser.js","webpack://pipeline-manager/./src/core/Specification.js","webpack://pipeline-manager/./src/core/validate-json.js","webpack://pipeline-manager/./src/core/layoutEngines/noLayoutEngine.js","webpack://pipeline-manager/./src/core/utils.ts","webpack://pipeline-manager/./src/core/stores.js","webpack://pipeline-manager/./src/core/nodeCreation/Configuration.ts","webpack://pipeline-manager/./src/core/layoutEngines/baseEngine.js","webpack://pipeline-manager/./src/core/doubleClick.js","webpack://pipeline-manager/./src/core/snappers.ts","webpack://pipeline-manager/./src/core/communication/utils.ts","webpack://pipeline-manager/./src/core/communication/remoteProcedures.ts","webpack://pipeline-manager/./src/core/communication/rpcCommunication.ts","webpack://pipeline-manager/./src/core/interfaceRegistry.ts","webpack://pipeline-manager/./src/core/notifications.js"],"sourcesContent":["import { __awaiter } from \"tslib\";\nimport { io } from 'socket.io-client';\nimport { JSONRPCCustomErrorCode } from '../../utils';\nimport NotificationHandler from '../../notifications';\nclass ExternalBackendApp {\n    // eslint-disable-next-line no-useless-constructor\n    constructor(url, jsonRPC, maxMessageLength = 256 * 1024) {\n        Object.defineProperty(this, \"url\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: url\n        });\n        Object.defineProperty(this, \"jsonRPC\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: jsonRPC\n        });\n        Object.defineProperty(this, \"maxMessageLength\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: maxMessageLength\n        });\n        Object.defineProperty(this, \"socket\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.socket = io(url, { extraHeaders: ExternalBackendApp.commonHeaders });\n        this.socket.on('connect', () => NotificationHandler.terminalLog('info', 'Initialized connection with communication server', null));\n        this.socket.on('disconnect', () => {\n            NotificationHandler.terminalLog('warning', 'Connection with communication server disrupted', null);\n            this.jsonRPC.rejectAllPendingRequests('WebSocket disconnected');\n        });\n        this.socket.on('api', (data) => __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.jsonRPC.server.receive(data);\n            if (response) {\n                try {\n                    const ack = yield this.socket.emitWithAck('external-api', response);\n                    if (ack !== undefined && !ack) {\n                        NotificationHandler.terminalLog('error', 'Response to external app was not send', null);\n                    }\n                }\n                catch (error) {\n                    NotificationHandler.terminalLog('error', `Response to ${data.method} request cannot be send`, error);\n                }\n            }\n        }));\n        this.socket.on('api-response', (response) => { this.jsonRPC.client.receive(response); });\n    }\n    isConnected() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const { status: { connected } } = yield this.jsonRPC.request('status_get', undefined, { externalApp: this });\n                return connected;\n            }\n            catch (_a) {\n                return false;\n            }\n        });\n    }\n    onConnect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a;\n            try {\n                yield this.jsonRPC.request('external_app_connect', undefined, { externalApp: this });\n                return true;\n            }\n            catch (unknownError) {\n                const error = unknownError;\n                const errorCode = (_a = error.code) !== null && _a !== void 0 ? _a : JSONRPCCustomErrorCode.EXCEPTION_RAISED;\n                const messageType = (errorCode !== JSONRPCCustomErrorCode.NEWER_SESSION_AVAILABLE) ? 'warning' : 'info';\n                NotificationHandler.terminalLog(messageType, error.message, undefined);\n                return false;\n            }\n        });\n    }\n    request(data, endpoint) {\n        var _a;\n        if (this.socket.disconnected)\n            throw new Error('WebSocket is disconnected. Make sure the communication server is available.');\n        const stringify = JSON.stringify(data);\n        // Emit request in chunks\n        if (stringify.length > this.maxMessageLength) {\n            const messageID = (_a = data.id) !== null && _a !== void 0 ? _a : crypto.randomUUID();\n            for (let i = 0; i < stringify.length; i += this.maxMessageLength) {\n                this.socket.emit(endpoint, {\n                    id: messageID,\n                    chunk: stringify.substring(i, Math.min(i + this.maxMessageLength, stringify.length)),\n                    end: i + this.maxMessageLength >= stringify.length,\n                });\n            }\n            // Emit whole request\n        }\n        else {\n            this.socket.emit(endpoint, data);\n        }\n    }\n}\nObject.defineProperty(ExternalBackendApp, \"commonHeaders\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: {\n        'Access-Control-Allow-Origin': 'http://localhost',\n        'Access-Control-Allow-Headers': 'Origin, X-Requested-With, Content-Type, Accept',\n    }\n});\nexport default ExternalBackendApp;\n","import { __awaiter } from \"tslib\";\nimport NotificationHandler from '../notifications.js';\nexport default class ConnectionManager {\n    // eslint-disable-next-line no-useless-constructor\n    constructor(connectionHook, disconnectionHook) {\n        Object.defineProperty(this, \"connectionHook\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: connectionHook\n        });\n        Object.defineProperty(this, \"disconnectionHook\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: disconnectionHook\n        });\n        Object.defineProperty(this, \"isRunning\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"connected\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n    }\n    add(externalApp) { this.connected.set(externalApp, false); }\n    remove(externalApp) { return this.connected.delete(externalApp); }\n    poll() {\n        return __awaiter(this, arguments, void 0, function* (interval = 1500) {\n            this.isRunning = true;\n            const updating = new Set();\n            while (this.isRunning) {\n                Array.from(this.connected.keys())\n                    .filter((externalApp) => !updating.has(externalApp))\n                    .forEach((externalApp) => {\n                    updating.add(externalApp);\n                    this.updateConnection(externalApp).then(() => updating.delete(externalApp));\n                });\n                // eslint-disable-next-line no-await-in-loop\n                yield new Promise((resolve) => { setTimeout(resolve, interval); });\n            }\n        });\n    }\n    updateConnection(externalApp) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const wasConnected = this.connected.get(externalApp);\n                let isConnected = yield externalApp.isConnected();\n                // If the application was connected and the connection was lost, a warning is displayed.\n                if (!isConnected && wasConnected) {\n                    NotificationHandler.terminalLog('warning', 'External application was disconnected', undefined);\n                    this.disconnectionHook(externalApp);\n                }\n                if (isConnected && !wasConnected) {\n                    if (yield externalApp.onConnect()) {\n                        this.connectionHook(externalApp);\n                    }\n                    else {\n                        isConnected = false;\n                    }\n                }\n                this.connected.set(externalApp, isConnected);\n            }\n            catch (error) {\n                this.connected.set(externalApp, false);\n            }\n        });\n    }\n    pollStop() { this.isRunning = false; }\n}\n","import { __awaiter } from \"tslib\";\nexport default class ExternalFrontendApp {\n    // eslint-disable-next-line no-useless-constructor\n    constructor(source) {\n        Object.defineProperty(this, \"source\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: source\n        });\n    }\n    // eslint-disable-next-line class-methods-use-this\n    isConnected() {\n        return __awaiter(this, void 0, void 0, function* () { return true; });\n    }\n    // eslint-disable-next-line class-methods-use-this\n    onConnect() {\n        return __awaiter(this, void 0, void 0, function* () { return true; });\n    }\n    request(data, endpoint) {\n        if (endpoint === 'backend-api')\n            throw new Error('Frontend external app does not support backend endpoints');\n        this.source.postMessage(data, '*');\n    }\n}\n","/*\n * Copyright (c) 2022-2024 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { createJSONRPCErrorResponse, createJSONRPCSuccessResponse, JSONRPCErrorCode } from 'json-rpc-2.0';\nimport { charset } from 'mime-types';\nimport { ref } from 'vue';\nimport {\n    backendApiUrl, PMMessageType, JSONRPCCustomErrorCode, loadingScreen,\n} from '../utils';\n\n// eslint-disable-next-line import/no-cycle\nimport jsonRPC from './rpcCommunication';\nimport runInfo from './runInformation';\nimport NotificationHandler from '../notifications';\nimport EditorManager, { loadJsonFromRemoteLocation } from '../EditorManager';\nimport ExternalBackendApp from './externalApp/backend.ts';\nimport ConnectionManager from './connectionManager.ts';\nimport ExternalFrontendApp from './externalApp/frontend.ts';\n\n// Default external application capabilities\nconst defaultAppCapabilities = [];\n\n/**\n * Creates notifications based on response received from external application.\n */\nfunction handleExternalAppResponse(response) {\n    // Status is HTTPCodes.OK so a message from the application is received.\n    if (response.type === PMMessageType.OK) {\n        NotificationHandler.terminalLog('info', response.content);\n    } else if (response.type === PMMessageType.ERROR) {\n        NotificationHandler.terminalLog('error', `Error occurred: ${response.content}`, response.content);\n    } else if (response.type === PMMessageType.WARNING) {\n        NotificationHandler.terminalLog('warning', `Warning: ${response.content}`, response.content);\n    }\n}\n\n/**\n * Creates notifications based on specification.\n * Returns `true` if error appeared.\n */\nfunction handleSpecificationResult({ errors, warnings, info }, errorTitle, warningTitle, infTitle) {\n    if (Array.isArray(warnings) && warnings.length) {\n        NotificationHandler.terminalLog('warning', warningTitle, warnings);\n    }\n    if (Array.isArray(errors) && errors.length) {\n        NotificationHandler.terminalLog('error', errorTitle, errors);\n        return true;\n    }\n    if (Array.isArray(info) && info.length) {\n        NotificationHandler.terminalLog('info', infTitle, info);\n    }\n    return false;\n}\n\n/**\n * Creates notification about mismatched specification versions\n */\nfunction showVersionError(currentVersion, specification) {\n    let usedVersion;\n    try {\n        usedVersion = JSON.parse(specification).version;\n    } catch { return; }\n    if (currentVersion === usedVersion) return;\n    NotificationHandler.terminalLog(\n        'error',\n        'Mismatched specification version',\n        `Specification version (${usedVersion}) differs from the current version (${currentVersion}). It may result in unexpected behaviour.` +\n        'Please refer to https://antmicro.github.io/kenning-pipeline-manager/changelogs.html to see if that is the case.',\n    );\n}\n\n/**\n * Formats received error and logs it.\n *\n * @param {string} type - Notification type.\n * @param {Error|import('./rpcCommunication').RPCError} error - Captured error.\n * @param {string} [message] - Custom error description.\n */\nfunction RPCTerminalLog(type, error, message) {\n    const args = message !== undefined\n        ? [message, [error.message, ...(error.data ?? [])]]\n        : [error.message, error.data];\n\n    NotificationHandler.terminalLog(type, ...args);\n}\n\nclass ExternalApplicationManager {\n    editorManager = EditorManager.getEditorManagerInstance();\n\n    appCapabilities = ref([]);\n\n    externalApp = null;\n\n    connectionHook = null;\n\n    backend = false;\n\n    constructor() {\n        /**\n         * Assigning the ExternalApplicationManager instance to the EditorManager properties.\n         * This assignment bypasses the cycle problem if the ExternalApplicationManager was normally\n         * imported in the EditorManager.\n         */\n        this.editorManager.externalApplicationManager = this;\n\n        // eslint-disable-next-line no-param-reassign\n        const resetProgress = () => runInfo.forEach((itemInfo) => { itemInfo.inProgress = false; });\n        this.connectionManager = new ConnectionManager(\n            (externalApp) => this.initializeConnection(externalApp),\n            resetProgress,\n        );\n        this.connectionManager.poll();\n    }\n\n    isExternalAppAvailable() {\n        return this.externalApp !== null;\n    }\n\n    isConnected() {\n        return Array.from(this.connectionManager.connected.values()).some(Boolean);\n    }\n\n    usesBackend() {\n        return this.backend;\n    }\n\n    /**\n     * Wrap the RPC request with the current application.\n     *\n     * @param {string} method - API endpoint.\n     * @param {any} params - Parameters for the given API endpoint.\n     * @returns RPC response.\n     */\n    async request(method, params) {\n        const { externalApp } = this;\n        return jsonRPC.request(method, params, { externalApp });\n    }\n\n    /**\n     * Event handler that asks the backend to send a dataflow specification.\n     * If the backend did not manage to send it the user is alerted with a feedback message.\n     * Otherwise the specification is passed to the editor that renders a new environment.\n     */\n    async requestSpecification() {\n        let message = 'Unknown error';\n        try {\n            const data = await this.request('specification_get');\n\n            if (data.type === PMMessageType.OK) {\n                const specification = data.content;\n\n                await this.updateSpecification(specification);\n\n                NotificationHandler.terminalLog('info', 'Specification loaded successfully');\n            } else if (data.type === PMMessageType.WARNING) {\n                message = data.content;\n                NotificationHandler.terminalLog('warning', message);\n            } else if (data.type === PMMessageType.ERROR) {\n                message = data.content;\n                NotificationHandler.terminalLog('error', message);\n            }\n        } catch (error) {\n            RPCTerminalLog('error', error);\n        }\n    }\n\n    async conditionalLoadingScreen(load, callback) {\n        const { setLoad } = this.editorManager.baklavaView.editor.events;\n        return loadingScreen(callback, setLoad, { show: load });\n    }\n\n    async validateSpecification(specification) {\n        if (typeof specification === 'string' || specification instanceof String) {\n            const [success, specificationOrError] = await loadJsonFromRemoteLocation(specification);\n            if (!success) {\n                NotificationHandler.terminalLog('error', 'Specification is invalid', specificationOrError);\n                return Promise.resolve();\n            }\n\n            // eslint-disable-next-line no-param-reassign\n            specification = specificationOrError;\n        }\n\n        if (handleSpecificationResult(\n            EditorManager.validateSpecification(specification),\n            'Specification is invalid',\n            'Warnings when validating specification',\n            'Validated specification',\n        )) {\n            showVersionError(\n                this.editorManager.specificationVersion,\n                specification,\n            );\n            return Promise.resolve();\n        }\n\n        return specification;\n    }\n\n    async preprocessSpecification(specification, { urloverrides, tryMinify } = {}) {\n        // eslint-disable-next-line no-param-reassign\n        specification = await this.validateSpecification(specification);\n        if (!specification) return Promise.resolve();\n\n        if (typeof tryMinify === 'string' || tryMinify instanceof String) {\n            const [success, dataflowOrError] = await loadJsonFromRemoteLocation(tryMinify);\n            if (!success) {\n                NotificationHandler.terminalLog('error', 'Dataflow is invalid', dataflowOrError);\n                return Promise.resolve();\n            }\n\n            // eslint-disable-next-line no-param-reassign\n            tryMinify = dataflowOrError;\n        }\n\n        const result = await this.editorManager.preprocessSpecification(specification, {\n            urloverrides, tryMinify,\n        });\n        const error = handleSpecificationResult(\n            result,\n            'Errors when preprocessing specification',\n            'Warnings when preprocessing specification',\n            'Specification preprocessed',\n        );\n        if (error) return Promise.resolve();\n        return result.specification;\n    }\n\n    async updateSpecification(specification, { urloverrides, tryMinify } = {}) {\n        // eslint-disable-next-line no-param-reassign\n        specification = await this.validateSpecification(specification);\n        if (!specification) return Promise.resolve();\n\n        if (typeof tryMinify === 'string' || tryMinify instanceof String) {\n            const [success, dataflowOrError] = await loadJsonFromRemoteLocation(tryMinify);\n            if (!success) {\n                NotificationHandler.terminalLog('error', 'Dataflow is invalid', dataflowOrError);\n                return Promise.resolve();\n            }\n\n            // eslint-disable-next-line no-param-reassign\n            tryMinify = dataflowOrError;\n        }\n\n        const error = handleSpecificationResult(\n            await this.editorManager.updateEditorSpecification(\n                specification, false, true, urloverrides, tryMinify,\n            ),\n            'Errors when loading specification',\n            'Warnings when loading specification',\n            'Loaded specification',\n        );\n        if (error) {\n            showVersionError(\n                this.editorManager.specificationVersion,\n                specification,\n            );\n        }\n        return error;\n    }\n\n    async updateDataflow(dataflow) {\n        if (typeof dataflow === 'string' || dataflow instanceof String) {\n            const [success, dataflowOrError] = await loadJsonFromRemoteLocation(dataflow);\n            if (!success) {\n                NotificationHandler.terminalLog('error', 'Dataflow is invalid', dataflowOrError);\n                return;\n            }\n\n            // eslint-disable-next-line no-param-reassign\n            dataflow = dataflowOrError;\n        }\n        const { errors, warnings, info } = await this.editorManager.loadDataflow(dataflow);\n        if (Array.isArray(errors) && errors.length) {\n            NotificationHandler.terminalLog('error', 'Dataflow is invalid', errors);\n            if (Array.isArray(info) && info.length) {\n                NotificationHandler.terminalLog(\n                    'error',\n                    'Mismatched specification version',\n                    `${info} Please refer to https://antmicro.github.io/kenning-pipeline-manager/changelogs.html to see if that is the case.`,\n                );\n            }\n        } else if (Array.isArray(warnings) && warnings.length) {\n            NotificationHandler.terminalLog('warning', 'Dataflow loaded with warning', warnings);\n        } else if (Array.isArray(info) && info.length) {\n            NotificationHandler.terminalLog('info', 'Dataflow loaded', info);\n        }\n    }\n\n    /**\n    * Provides capabilities of the third-party app connected via server\n    * to Pipeline Manager's frontend.\n    */\n    async requestAppCapabilities() {\n        try {\n            const appCapabilities = await this.request('app_capabilities_get');\n            this.appCapabilities.value = appCapabilities;\n        } catch (error) {\n            this.appCapabilities.value = defaultAppCapabilities;\n            RPCTerminalLog('warning', error, 'Application capabilities cannot be retrieved, using defaults');\n        }\n    }\n\n    /**\n    * Handles dataflow export.\n    */\n    async requestDataflowExport() {\n        const dataflow = this.editorManager.saveDataflow();\n        if (!dataflow) return false;\n\n        let data;\n        try {\n            data = await this.request('dataflow_export', { dataflow });\n        } catch (error) {\n            // The connection was closed.\n            RPCTerminalLog('error', error);\n            return false;\n        }\n\n        // Status is HTTPCodes.OK so a message from the application is received.\n        if (data.type === PMMessageType.OK) {\n            return data;\n        }\n\n        if (data.type === PMMessageType.ERROR) {\n            NotificationHandler.terminalLog('error', `Error occurred: ${data.content}`, data.content);\n        } else if (data.type === PMMessageType.WARNING) {\n            NotificationHandler.terminalLog('warning', `Warning: ${data.content}`, data.content);\n        }\n        return false;\n    }\n\n    /**\n     * Event handler that loads a current dataflow from the editor and sends a request\n     * to the backend based on the action argument.\n     * The user is alerted with a feedback message.\n     *\n     * @param procedureName Name of the requested procedure.\n     * @param requireResponse Whether response from external application should be awaited.\n     */\n    async requestDataflowAction(procedureName, requireResponse) {\n        const dataflow = this.editorManager.saveDataflow();\n        const runProcedureInfo = runInfo.get(procedureName);\n        if (!dataflow) return;\n        const validatedProcedureName = (jsonRPC.customMethodRegex.test(procedureName)) ?\n            jsonRPC.customMethodReplace : procedureName;\n\n        if (validatedProcedureName === 'dataflow_run') {\n            if (runProcedureInfo.inProgress) {\n                NotificationHandler.showToast('error', 'Previous run has not finished, cannot process this request');\n                return;\n            }\n            NotificationHandler.showToast('info', 'Running dataflow');\n        }\n        if (requireResponse) {\n            runProcedureInfo.inProgress = true;\n\n            let data;\n            try {\n                if (validatedProcedureName.startsWith('dataflow_')) {\n                    data = await this.request(procedureName, { dataflow });\n                } else {\n                    data = await this.request(validatedProcedureName);\n                }\n            } catch (error) {\n                // The connection was closed\n                RPCTerminalLog('error', error, 'Cannot create a request');\n                runProcedureInfo.inProgress = false;\n                return;\n            }\n\n            handleExternalAppResponse(data);\n            runProcedureInfo.inProgress = false;\n        } else if (validatedProcedureName.startsWith('dataflow_')) {\n            this.request(procedureName, { dataflow });\n        } else {\n            this.request(validatedProcedureName);\n        }\n    }\n\n    /**\n     * Event handler that check if remote procedure is running and send stop request.\n     * The user is alerted with a feedback message.\n     *\n     * @param procedureName Name of the requested procedure.\n     */\n    // eslint-disable-next-line class-methods-use-this\n    async requestDataflowStop(procedureName) {\n        if (!runInfo.get(procedureName).inProgress) {\n            NotificationHandler.showToast('error', 'Nothing to stop, no ongoing jobs running');\n            return;\n        }\n\n        try {\n            const response = await this.request('dataflow_stop', { method: procedureName });\n            handleExternalAppResponse(response);\n        } catch (error) {\n            RPCTerminalLog('error', error);\n        }\n    }\n\n    /**\n     * Event handler that loads a file and asks the backend to delegate this operation\n     * to the external application to parse it into the Pipeline Manager format\n     * so that it can be loaded into the editor.\n     * It the validation is successful it is loaded as the current dataflow.\n     * Otherwise the user is alerted with a feedback message.\n     *\n     * @param dataflow Dataflow to be impported\n     */\n    async importDataflow() {\n        const file = document.getElementById('request-dataflow-button').files[0];\n        if (!file) return;\n\n        const reader = new FileReader();\n        const encoding = charset(file.type);\n        const readerPromise = new Promise((resolve) => {\n            reader.onloadend = () => {\n                resolve(\n                    (encoding) ? reader.result : reader.result.replace(/data:.*;base64,/, ''),\n                );\n            };\n        });\n        // Read file as text if possible, otherwise return base64 string\n        if (encoding) {\n            reader.readAsText(file, encoding);\n        } else {\n            reader.readAsDataURL(file);\n        }\n        const dataflow = await readerPromise;\n        if (!dataflow) {\n            NotificationHandler.showToast('error', 'File cannot be loaded');\n            return;\n        }\n\n        try {\n            const data = await this.request('dataflow_import', { external_application_dataflow: dataflow, mime: file.type, base64: !encoding });\n            if (data.type === PMMessageType.OK) {\n                const { errors, warnings } = await this.editorManager.loadDataflow(data.content);\n                if (Array.isArray(errors) && errors.length) {\n                    NotificationHandler.terminalLog('error', 'Dataflow is invalid', errors);\n                } else if (Array.isArray(warnings) && warnings.length) {\n                    NotificationHandler.terminalLog('warning', 'Dataflow imported with warning', warnings);\n                } else {\n                    NotificationHandler.showToast('info', 'Imported dataflow');\n                }\n            } else if (data.type === PMMessageType.ERROR) {\n                const message = data.content;\n                NotificationHandler.terminalLog('error', `Error occurred: ${data.content}`, message);\n            } else if (data.type === PMMessageType.WARNING) {\n                NotificationHandler.terminalLog('warning', `Warning: ${data.content}`, 'Imported dataflow');\n            }\n        } catch (error) {\n            RPCTerminalLog('error', error);\n        }\n    }\n\n    /**\n     * Send information to external application about changed values (like nodes, connections,\n     * positions, properties).\n     *\n     * @param method Name of the JSON-RPC method.\n     * @param changedProperties Params of the send request, should contain changed values.\n     */\n    async notifyAboutChange(method, changedProperties) {\n        if (!this.isConnected() || !this.editorManager.notifyWhenChanged) return;\n        try {\n            await this.request(method, changedProperties);\n        } catch (error) {\n            RPCTerminalLog('warning', error, `Notifying about change failed (${method})`);\n        }\n    }\n\n    /**\n     * Send information to external application about input received by writable terminal.\n     *\n     * @param terminal Name Name of the terminal\n     * @param message Input provided for the terminal\n     */\n    async requestTerminalRead(terminalName, message) {\n        if (!this.isConnected()) return;\n        try {\n            await this.request('terminal_read', { name: terminalName, message });\n        } catch (error) {\n            RPCTerminalLog('warning', error, 'Sending terminal input failed');\n        }\n    }\n\n    /**\n     * Function used to initialize connection with the external application and request\n     * specification. Should be called after DOM is created.\n     *\n     * It checks whether a connection is established.\n     * If it is then it just requests a specification.\n     * If it is not then it opens a TCP port, wait for the application to connect and then\n     * requests specification.\n     *\n     * @param {import('./externalApp/base.ts').ExternalApp} externalApp\n     */\n    async initializeConnection(_externalApp) {\n        if (this.backend) {\n            NotificationHandler.terminalLog(\n                'info',\n                `External application connected successfully`,\n                undefined,\n            );\n        }\n\n        await Promise.all([\n            this.requestSpecification(),\n            this.requestAppCapabilities(),\n        ]);\n\n        try {\n            await this.request('frontend_on_connect');\n        } catch (error) {\n            if (error.code !== JSONRPCErrorCode.MethodNotFound &&\n                error.code !== JSONRPCCustomErrorCode.EXTERNAL_APPLICATION_NOT_CONNECTED) {\n                RPCTerminalLog('error', error);\n            }\n        }\n\n        if (this.connectionHook !== null) this.connectionHook();\n    }\n\n    registerConnectionHook(connectionHook) {\n        this.connectionHook = connectionHook;\n    }\n\n    /**\n     * Registers external application and calls connection hook, if exists.\n     *\n     * @param {import('./externalApp/base.ts').ExternalApp} externalApp - External application.\n     */\n    registerApplication(externalApp) {\n        this.externalApp = externalApp;\n        this.connectionManager.add(externalApp);\n\n        if (this.connectionHook !== null) this.connectionHook();\n    }\n\n    /**\n     * Registers external backend application.\n     *\n     * @param {string} url - Backend URL.\n     */\n    registerBackendApplication(url) {\n        this.registerApplication(new ExternalBackendApp(url, jsonRPC));\n        this.backend = true;\n    }\n\n    /**\n     * Registers external frontend.\n     *\n     * @param {Window} sourceWindow - Wrapping window.\n     * @param {import('json-rpc-2.0').JSONRPCRequest} request - Wrapping window.\n     * @returns {import('json-rpc-2.0').JSONRPCResponse} Response with success or error message.\n     */\n    registerFrontendApplication(sourceWindow, request) {\n        const logAndRespond = (msgType, msg) => {\n            const [logType, response] = {\n                [PMMessageType.ERROR]: ['error', createJSONRPCErrorResponse(request.id, msgType, msg)],\n                [PMMessageType.WARNING]: ['warning', createJSONRPCSuccessResponse(request.id, msg)],\n                [PMMessageType.OK]: ['info', createJSONRPCSuccessResponse(request.id, msg)],\n            }[msgType];\n            if (msgType !== PMMessageType.OK) {\n                NotificationHandler.terminalLog(logType, msg);\n            }\n            return response;\n        };\n\n        if (sourceWindow === window) return logAndRespond(PMMessageType.ERROR, 'External frontend cannot be a Pipeline Manager itself');\n        if (this.externalApp !== null) {\n            this.connectionManager.remove(this.externalApp);\n            logAndRespond(PMMessageType.WARNING, 'Replacing current external application.');\n        }\n\n        this.registerApplication(new ExternalFrontendApp(sourceWindow));\n        this.backend = false;\n        return logAndRespond(PMMessageType.OK, 'Registered external frontend successfully');\n    }\n}\n\nlet externalApplicationManager;\n\n/**\n * Function managing External Application Manager singleton.\n *\n * @returns {ExternalApplicationManager} Instance of External Application Manager.\n */\nexport default function getExternalApplicationManager() {\n    if (!externalApplicationManager) {\n        externalApplicationManager = new ExternalApplicationManager();\n        if (backendApiUrl) externalApplicationManager.registerBackendApplication(backendApiUrl);\n    }\n    return externalApplicationManager;\n}\n","/*\n * Copyright (c) 2022-2024 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n/* eslint-disable max-classes-per-file */\n/**\n * Class with information about ran procedure.\n */\nclass RunInfo {\n    /**\n     * @param procedureName Name of the procedure\n     */\n    constructor(procedureName) {\n        Object.defineProperty(this, \"procedureName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"hook\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: undefined\n        });\n        /** @private */\n        Object.defineProperty(this, \"pr_inProgress\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        this.procedureName = procedureName;\n    }\n    /**\n     * Finds progress bar affiliated with run.\n     * If cannot be found, throws Error.\n     */\n    get progressBar() {\n        const progressBar = document.querySelector(`#navbar-button-${this.procedureName} > .progress-bar`);\n        return progressBar;\n    }\n    /**\n     * Specifies if run is in progress.\n     */\n    get inProgress() {\n        return this.pr_inProgress;\n    }\n    set inProgress(value) {\n        const { progressBar } = this;\n        if (progressBar) {\n            if (!value)\n                progressBar.classList.remove('animate');\n            progressBar.style.width = '0%';\n        }\n        this.pr_inProgress = value;\n        if (this.hook !== undefined) {\n            this.hook();\n        }\n    }\n}\n/**\n * @template K key type\n * @template V value type\n * @extends {Map<K,V>}\n *\n * Map automatically creating values if key is not found.\n */\nclass DefaultMap extends Map {\n    constructor(defaultFactory) {\n        super();\n        Object.defineProperty(this, \"defaultFactory\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.defaultFactory = defaultFactory;\n    }\n    get(key) {\n        if (!super.has(key)) {\n            super.set(key, this.defaultFactory(key));\n        }\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return super.get(key);\n    }\n}\n/**\n * @extends {DefaultMap<string, RunInfo>}\n *\n * DefaultMap with custom hook run when RunInfo inProgress changes value.\n */\nclass RunInfoMap extends DefaultMap {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"hook\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: undefined\n        });\n    }\n    get(key) {\n        if (!super.has(key)) {\n            const newValue = this.defaultFactory(key);\n            newValue.hook = this.hook;\n            super.set(key, newValue);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return super.get(key);\n    }\n    setHook(hook) {\n        this.hook = hook;\n        // eslint-disable-next-line no-param-reassign\n        this.forEach((v) => { v.hook = hook; });\n    }\n}\nexport default new RunInfoMap((key) => new RunInfo(key));\n","/*\n * Copyright (c) 2022-2024 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/* eslint-disable import/prefer-default-export */\n\n// Mouse position\nlet y = 0;\nlet h = 0;\n\n// Height setting callback\nlet setTerminalHeight;\n\nconst mouseMoveHandler = (e) => {\n    const { clientY } = e;\n    const navBarHeight = 61;\n\n    // Calculate mouse move\n    const dy = y - clientY;\n\n    // Prevent terminal overflow under nav bar\n    if (clientY > navBarHeight) {\n        setTerminalHeight(h + dy);\n    }\n};\n\nconst mouseUpHandler = () => {\n    const terminalWrapper = document.querySelector('.terminal-wrapper');\n\n    document.removeEventListener('mousemove', mouseMoveHandler);\n    document.removeEventListener('mouseup', mouseUpHandler);\n    terminalWrapper.style['pointer-events'] = '';\n};\n\nexport const mouseDownHandler = (setHeight) => (e) => {\n    const terminalWrapper = document.querySelector('.terminal-wrapper');\n    setTerminalHeight = setHeight;\n\n    y = e.clientY;\n\n    // Calculate height of terminal panel\n    const styles = window.getComputedStyle(terminalWrapper);\n    h = parseInt(styles.height, 10);\n\n    document.addEventListener('mousemove', mouseMoveHandler);\n    document.addEventListener('mouseup', mouseUpHandler);\n    terminalWrapper.style['pointer-events'] = 'none';\n};\n","/*\n * Copyright (c) 2022-2024 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/* eslint-disable max-classes-per-file */\n\nimport { NodeInterface, Node } from '@baklavajs/core';\n\nimport { updateInterfacePosition } from '../custom/CustomNode.js';\nimport {\n    applySidePositions,\n    parseInterfaces,\n    validateInterfaceGroups,\n    generateProperties,\n    DYNAMIC_INTERFACE_SUFFIX,\n} from './interfaceParser.js';\n\nimport CheckboxInterface from '../interfaces/CheckboxInterface.js';\nimport HexInterface from '../interfaces/HexInterface.js';\nimport InputInterface from '../interfaces/InputInterface.js';\nimport IntegerInterface from '../interfaces/IntegerInterface.js';\nimport ListInterface from '../interfaces/ListInterface.js';\nimport NumberInterface from '../interfaces/NumberInterface.js';\nimport SelectInterface from '../interfaces/SelectInterface.js';\nimport SliderInterface from '../interfaces/SliderInterface.js';\nimport TextAreaInterface from '../interfaces/TextAreaInterface.js';\nimport TextInterface from '../interfaces/TextInterface.js';\nimport ButtonInterface from '../interfaces/ButtonInterface.js';\nimport GraphTemplate from '../custom/CustomGraphTemplate.js';\n\nimport { ir } from './interfaceRegistry.ts';\n\n/**\n * @param properties coming from the specification\n * @returns object that can be used to create properties or an array of errors\n * if any occurred.\n */\nexport function parseProperties(properties) {\n    const parsedProperties = {};\n    const usedNames = new Set();\n    const errors = [];\n\n    properties.forEach((prop) => {\n        if (prop.group !== undefined && Array.isArray(prop.group)) {\n            const parsedGroup = parseProperties(prop.group);\n            if (Array.isArray(parsedGroup) && parsedGroup.length) {\n                errors.push(...parsedGroup);\n            }\n\n            Object.entries(parsedGroup).forEach(([pgroupname]) => {\n                if (usedNames.has(pgroupname)) {\n                    const realname = pgroupname.slice(pgroupname.indexOf('_') + 1);\n                    errors.push(\n                        `Property named '${realname}' in a group property '${prop.name}' is a duplicate.`,\n                    );\n                }\n                usedNames.add(pgroupname);\n            });\n\n            prop.group = parsedGroup; // eslint-disable-line no-param-reassign\n        }\n\n        if (usedNames.has(`property_${prop.name}`)) {\n            errors.push(\n                `Property named '${prop.name}' is a duplicate.`,\n            );\n        }\n\n        parsedProperties[`property_${prop.name}`] = { ...prop };\n        usedNames.add(`property_${prop.name}`);\n    });\n\n    if (errors.length) {\n        return errors;\n    }\n\n    return parsedProperties;\n}\n\n/**\n * Creates a property based on its specification.\n *\n * @param p property specification with name and type\n * @param hidden whether the property should be hidden\n *\n * @returns property object of a given type\n * */\nexport function newProperty(p, hidden = false) {\n    const propName = p.name;\n    const propType = p.type;\n    let propDef = p.default;\n    let intf;\n\n    switch (propType) {\n        case 'constant':\n            intf = new TextInterface(propName, propDef);\n            break;\n        case 'text':\n            intf = new InputInterface(propName, propDef, p.readonly);\n            break;\n        case 'multiline':\n            intf = new TextAreaInterface(propName, propDef, p.readonly);\n            break;\n        case 'number':\n            intf = new NumberInterface(propName, propDef, p.min, p.max, p.readonly);\n            break;\n        case 'integer':\n            intf = new IntegerInterface(propName, propDef, p.min, p.max, p.readonly);\n            break;\n        case 'hex':\n            intf = new HexInterface(\n                propName,\n                propDef.toLowerCase(),\n                p.min ? BigInt(p.min) : NaN,\n                p.max ? BigInt(p.max) : NaN,\n                p.readonly,\n            );\n            break;\n        case 'select': {\n            const it = p.values.map((element) => element.toString());\n            intf = new SelectInterface(propName, propDef, it, p.readonly);\n        } break;\n        case 'bool':\n            intf = new CheckboxInterface(propName, propDef, p.readonly);\n            break;\n        case 'slider':\n            if (propDef === undefined) {\n                propDef = p.min;\n            }\n            intf = new SliderInterface(propName, propDef, p.min, p.max, p.step, p.readonly);\n            break;\n        case 'list':\n            if (propDef === null) {\n                propDef = [];\n            }\n            intf = new ListInterface(propName, propDef, p.dtype, p.readonly);\n            break;\n        case 'button-url':\n            intf = new ButtonInterface(propName, () => window.open(intf.value, '_blank'), propDef, 'button-url');\n            break;\n        case 'button-api':\n            intf = new ButtonInterface(\n                propName,\n                () => intf.events.updated.emit(['button_click', { id: intf.id, value: intf.value }]),\n                propDef,\n                'button-api');\n            break;\n        case 'button-graph':\n            intf = new ButtonInterface(\n                propName,\n                () => intf.events.updated.emit(intf.value),\n                propDef,\n                'button-graph');\n            break;\n        default:\n            /* eslint-disable no-console */\n            console.error(propType, ' input type is not recognized.');\n    }\n    if (intf !== undefined) {\n        intf.hidden = hidden;\n        intf.type = propType;\n        intf.default = propDef;\n        intf.hideOnDefault = p.hideOnDefault;\n\n        if (p.interfaceMaxConnectionsCount !== undefined) {\n            intf.interfaceMaxConnectionsCount = p.interfaceMaxConnectionsCount;\n        }\n\n        if (p.interfaceType !== undefined) {\n            intf.interfaceType = p.interfaceType;\n        }\n    }\n\n    return intf;\n}\n\n/**\n * @param properties that are validated and parsed. The format\n * should be the same as the one returned by parseProperties.\n * @returns created properties\n */\nexport function createProperties(properties) {\n    const tempProperties = {};\n\n    Object.entries(properties).forEach(([pname, p]) => {\n        if (p.group !== undefined) {\n            tempProperties[pname] = (() => {\n                const groupedProperty = newProperty(p);\n                groupedProperty.group = Object.keys(p.group);\n                return groupedProperty;\n            });\n            Object.entries(p.group).forEach(([pgroupname, pgroup]) => {\n                tempProperties[pgroupname] = () => newProperty(pgroup);\n            });\n        } else {\n            tempProperties[pname] = () => newProperty(p);\n        }\n    });\n    return tempProperties;\n}\n\n/**\n * Function performs sanity checking on parsed state before loading it\n * into the editor. It should throw explicit errors if any discrepancy is detected.\n *\n * @param parsedState that is passed to node to load\n * @param inputs inputs of the node\n * @param outputs outputs of the node\n * @returns list of errors.\n */\nfunction detectDiscrepancies(parsedState, inputs, outputs) {\n    let errors = [];\n\n    const checkType = (propType, value) => {\n        switch (propType) {\n            case 'constant':\n            case 'select':\n                return true;\n            case 'text':\n            case 'multiline':\n            case 'button-url':\n            case 'button-graph':\n            case 'hex':\n                return typeof value === 'string';\n            case 'number':\n            case 'integer':\n            case 'slider':\n                return typeof value === 'number';\n            case 'bool':\n                return typeof value === 'boolean';\n            case 'list':\n                return Array.isArray(value);\n            case 'button-api':\n                return typeof value === 'object';\n            default:\n                return false;\n        }\n    };\n\n    // Checking for existence of interfaces defined\n    Object.keys({\n        ...parsedState.inputs,\n        ...parsedState.outputs,\n    }).forEach((ioName) => {\n        const name = ioName.slice(ioName.indexOf('_') + 1);\n        const direction = ioName.slice(0, ioName.indexOf('_'));\n        if (\n            !Object.prototype.hasOwnProperty.call(inputs, ioName) &&\n            !Object.prototype.hasOwnProperty.call(outputs, ioName)\n        ) {\n            if (direction === 'property') {\n                errors.push(`Property named '${name}' not found in specification!`);\n            } else {\n                errors.push(`Interface named '${name}' of direction '${direction}' not found in specification!`);\n            }\n        } else if (direction === 'property') {\n            // Verifying property type defined in the node and the value passed\n            const parsedValue = parsedState.inputs[ioName].value;\n            const propertyType = inputs[ioName].type;\n            if (!checkType(propertyType, parsedValue)) {\n                errors.push(`Property '${name}' type mismatch. ${propertyType} expected, ${typeof parsedValue} found.`);\n            } else if (propertyType === 'select') {\n                const { items } = inputs[ioName];\n                if (Array.isArray(items)) {\n                    if (!items.map(String).includes(String(parsedValue))) {\n                        errors.push(\n                            `Property '${name}' value mismatch. ${parsedValue} (type: ${typeof parsedValue}) not found in ${JSON.stringify(items)}`,\n                        );\n                    }\n                } else if (String(parsedValue) !== String(items)) {\n                    errors.push(\n                        `Property '${name}' value mismatch. Expected '${items}' (type: ${typeof items}), found '${parsedValue}' (type: ${typeof parsedValue}).`,\n                    );\n                }\n            } else if (propertyType === 'list') {\n                const { dtype } = inputs[ioName];\n\n                const mismatchedElements = parsedValue.filter((val) => {\n                    // Accept both 'integer' and 'number' for dtype 'integer'.\n                    if (dtype === 'integer') {\n                        return typeof val !== 'number' || !Number.isInteger(val);\n                    }\n                    return typeof val !== dtype;// eslint-disable-line valid-typeof\n                });\n                if (mismatchedElements.length > 0) {\n                    errors.push(\n                        `Property '${name}' value mismatch. ` +\n                        `Items: '${mismatchedElements.join(' ')}' are not of '${dtype}' dtype.` +\n                        `Items are of type: ${mismatchedElements.map((val) => typeof val).join(', ')}`,\n                    );\n                }\n            }\n        }\n    });\n\n    // Checking for existence of interface groups\n    Object.keys(parsedState.enabledInterfaceGroups).forEach((groupName) => {\n        if (\n            !Object.prototype.hasOwnProperty.call(inputs, groupName) &&\n            !Object.prototype.hasOwnProperty.call(outputs, groupName)\n        ) {\n            const direction = groupName.slice(0, groupName.indexOf('_'));\n            const name = groupName.slice(groupName.indexOf('_') + 1);\n\n            errors.push(`Interface group named '${name}' of direction '${direction}' not found in specification!`);\n        }\n    });\n\n    if (errors && errors.length) {\n        return errors;\n    }\n\n    errors = validateInterfaceGroups(\n        Object.keys(parsedState.enabledInterfaceGroups),\n        inputs,\n        outputs,\n    );\n\n    return errors;\n}\n\n/**\n * @param state state to be loaded. Should be a valid dataflow\n * @returns state that can be given to baklavajs, or an array of errors if any occurred\n */\nfunction parseNodeState(state) {\n    const newState = JSON.parse(JSON.stringify(state));\n\n    if (newState.interfaces !== undefined) {\n        const out = parseInterfaces(newState.interfaces, [], []);\n        if (Array.isArray(out) && out.length) {\n            return out;\n        }\n\n        const { inputs, outputs } = out;\n        newState.inputs = inputs;\n        newState.outputs = outputs;\n\n        delete newState.interfaces;\n    }\n\n    if (newState.properties !== undefined) {\n        const out = parseProperties(newState.properties);\n        if (Array.isArray(out) && out.length) {\n            return out;\n        }\n\n        newState.inputs = { ...newState.inputs, ...out };\n        delete newState.properties;\n    }\n\n    if (newState.enabledInterfaceGroups !== undefined) {\n        const interfaceGroups = {};\n        newState.enabledInterfaceGroups.forEach((intf) => {\n            interfaceGroups[`${intf.direction}_${intf.name}`] = { ...intf };\n        });\n        newState.enabledInterfaceGroups = interfaceGroups;\n    } else {\n        newState.enabledInterfaceGroups = {};\n    }\n\n    newState.title = newState.instanceName ?? '';\n    delete newState.instanceName;\n\n    newState.parsed = true;\n    return newState;\n}\n\nexport class CustomNode extends Node {\n    inputs = {};\n\n    outputs = {};\n\n    type = undefined;\n\n    constructor(\n        name,\n        layer,\n        inputs,\n        outputs,\n        twoColumn,\n        description = '',\n        nodeExtends = [],\n        nodeExtending = [],\n        nodeSiblings = [],\n        width = 300,\n        relatedGraphs = undefined,\n    ) {\n        super();\n\n        this.description = description;\n        this.extends = nodeExtends;\n        this.extending = nodeExtending;\n        this.siblings = nodeSiblings;\n        this.layer = layer;\n        this.title = name;\n        this.twoColumn = twoColumn;\n        this.type = name;\n        this.width = width;\n        this.relatedGraphs = relatedGraphs;\n\n        Object.keys(inputs).forEach((k) => {\n            const intf = inputs[k]();\n            this.addInput(k, intf);\n        });\n\n        Object.keys(outputs).forEach((k) => {\n            const intf = outputs[k]();\n            this.addOutput(k, intf);\n        });\n    }\n\n    /**\n     * Function for updating dynamic interfaces of the node based on the property passed.\n     *\n     * @param {*} prop property that is responsible for creating dynamic interfaces.\n     * It must have name and value properties.\n     */\n    updateDynamicInterfaces(prop) {\n        const interfaces = [];\n        const { value } = prop;\n\n        // Ensure prop.name is defined and is a string.\n        if (typeof prop.name !== 'string') {\n            throw new Error('Property \\'name\\' is undefined or not a string in updateDynamicInterfaces.');\n        }\n\n        // The interface metadata has to be obtained from the specification of the property\n        const propertyInput = this.inputs[`property_${prop.name}`];\n        const interfaceType = propertyInput?.interfaceType;\n        const interfaceMaxConnectionsCount = propertyInput?.interfaceMaxConnectionsCount;\n\n        // Direction is obtained from property name\n        const propName = prop.name.split(' ');\n        // Ensure propName has enough elements\n        if (propName.length < 2) {\n            throw new Error(\n                'Property name is too short to extract direction in updateDynamicInterfaces.' +\n                `Property name: ${prop.name}`,\n            );\n        }\n        const direction = propName[propName.length - 2];\n        // The DYNAMIC_INTERFACE_SUFFIX and direction are omitted\n        const interfaceName = prop.name\n            .slice(0, -1 * (DYNAMIC_INTERFACE_SUFFIX.length + 2 + direction.length));\n\n        const occupied = { left: [], right: [] };\n\n        const stateIOs = { ...this.inputs, ...this.outputs };\n\n        // Assigning sides and sides Positions to interfaces\n        Object.entries(stateIOs).forEach(([ioName, ioState]) => {\n            if (ioName.startsWith('property_')) return;\n            occupied[ioState.side].push(ioState.sidePosition);\n        });\n\n        for (let i = 0; i < value; i += 1) {\n            const ioName = `${interfaceName}[${i}]`;\n            const directionIoName = `${direction}_${ioName}`;\n\n            const intf = {\n                name: ioName,\n                direction,\n            };\n\n            const container = direction === 'output' ? this.outputs : this.inputs;\n\n            if (directionIoName in container) {\n                intf.externalName = container[directionIoName].externalName;\n                intf.side = container[directionIoName].side;\n                intf.sidePosition = container[directionIoName].sidePosition;\n            }\n\n            if (\n                !Object.prototype.hasOwnProperty.call(intf, 'sidePosition') &&\n                !Object.prototype.hasOwnProperty.call(intf, 'side')\n            ) {\n                const side = direction === 'output' ? 'right' : 'left';\n                let firstUnoccupied = occupied[side].sort((a, b) => a - b).findIndex(\n                    (sidePosition, index) => sidePosition !== index,\n                );\n\n                if (firstUnoccupied === -1) {\n                    if (occupied[side].length === 0) {\n                        firstUnoccupied = 0;\n                    } else {\n                        firstUnoccupied = Math.max(...occupied[side]) + 1;\n                    }\n                }\n\n                intf.sidePosition = firstUnoccupied;\n                intf.side = side;\n                intf.type = interfaceType;\n                intf.maxConnectionCount = interfaceMaxConnectionsCount;\n\n                occupied[intf.side].push(firstUnoccupied);\n            }\n\n            interfaces.push(intf);\n        }\n\n        // Remove extra interfaces if value of the property gets decreased.\n        const container = direction === 'output' ? this.outputs : this.inputs;\n        Object.keys(container).forEach((key) => {\n            if (!key.startsWith(`${direction}_${interfaceName}[`)) {\n                return;\n            }\n\n            const match = key.match(/\\[(\\d+)\\]$/);\n            if (!match) {\n                return;\n            }\n\n            const idx = parseInt(match[1], 10);\n            if (idx < value) {\n                return;\n            }\n\n            if (direction === 'output') {\n                this.removeOutput(key);\n            } else {\n                this.removeInput(key);\n            }\n        });\n\n        const out = parseInterfaces(interfaces, [], []);\n        if (Array.isArray(out) && out.length) {\n            throw new Error(`Internal error, node ${this.type} invalid. Reason: ${out.join(' ')}`);\n        }\n        const { inputs: newInputs, outputs: newOutputs } = out;\n\n        // Add new interfaces if they do not exist.\n        Object.entries(direction === 'output' ? newOutputs : newInputs).forEach(([key, intf]) => {\n            if ((key in container)) {\n                return;\n            }\n\n            const baklavaIntf = new NodeInterface(key);\n            Object.assign(baklavaIntf, intf);\n            if (direction === 'output') {\n                this.addOutput(key, baklavaIntf);\n            } else {\n                this.addInput(key, baklavaIntf);\n            }\n        });\n\n        // Finding a reactive reference of `this` and using it to bind\n        // the function to the node instance, so that the changes are\n        // reflected in the editor\n        const node = this.graph.nodes.find((n) => n.id === this.id);\n        const reactiveUpdate = this.updateInterfaces.bind(node);\n        reactiveUpdate(newInputs, newOutputs, false, [`${direction}_${interfaceName}`]);\n    }\n\n    toggleInterfaceGroup(intf, visible) {\n        // If the interface is visible and is being disabled\n\n        if (!intf.hidden && !visible) {\n            const connections = this.graphInstance.connections.filter(\n                (c) => c.from === intf || c.to === intf,\n            );\n            connections.forEach((c) => {\n                this.graphInstance.removeConnection(c);\n            });\n        }\n\n        // checking if there is an interface with the same side position\n        if (visible) {\n            updateInterfacePosition(this, intf, intf.side);\n        }\n        // It may also need a new sidePosition\n        intf.hidden = !visible; // eslint-disable-line no-param-reassign\n    }\n\n    save() {\n        const savedState = super.save();\n        const newProperties = [];\n        const newInterfaces = [];\n        const enabledInterfaceGroups = [];\n\n        Object.entries({ ...this.inputs, ...this.outputs }).forEach((io) => {\n            const [ioName, ioState] = io;\n\n            if (ioState.port) {\n                if (!ioState.hidden) {\n                    if (ioState.interfaces) {\n                        // Enabled interface groups\n                        enabledInterfaceGroups.push({\n                            name: ioName.slice(ioState.direction.length + 1),\n                            direction: ioState.direction,\n                        });\n                    }\n\n                    newInterfaces.push({\n                        name: ioName.slice(ioState.direction.length + 1),\n                        externalName: ioState.externalName,\n                        id: ioState.id,\n                        direction: ioState.direction,\n                        side: ioState.side,\n                        sidePosition: ioState.sidePosition,\n                    });\n                }\n            } else {\n                newProperties.push({\n                    name: ioName.slice('property'.length + 1),\n                    externalName: ioState.externalName,\n                    id: ioState.id,\n                    value: ioState.value === undefined ? null : ioState.value,\n                });\n            }\n        });\n\n        delete savedState.inputs;\n        delete savedState.outputs;\n        savedState.interfaces = newInterfaces;\n        savedState.properties = newProperties;\n        savedState.enabledInterfaceGroups = enabledInterfaceGroups;\n        savedState.relatedGraphs = this.relatedGraphs;\n\n        savedState.name = savedState.type;\n        delete savedState.type;\n\n        savedState.instanceName = savedState.title === '' ? undefined : savedState.title;\n        delete savedState.title;\n\n        return savedState;\n    }\n\n    /**\n     * Function used to update interfaces of a node when loading a dataflow\n     * in a development mode.\n     *\n     * @param {object} stateInputs newInputs of the node\n     * @param {object} stateOutputs newOutputs of the node\n     * @param {boolean} updateInterfaces determines what to do if an interface in either\n     * @param {string[]} include prefixes of names of interfaces that are to be removed. Other\n     * interfaces are left untouched. If set to undefined then all interfaces are updated.\n     * `stateInputs` or `stateOutputs` already exists in the node. If set to `true`, the\n     * interface will be updated with the new values, otherwise it will be left untouched.\n     */\n    updateInterfaces(stateInputs, stateOutputs, updateInterfaces = true, include = undefined) {\n        const errors = [];\n        // Updating interfaces of a graph node\n        Object.entries(this.inputs).forEach(([k, intf]) => {\n            // Process only interfaces, not properties\n            if (intf.direction === undefined) return;\n            if (\n                !Object.keys(stateInputs).includes(k) &&\n                (include === undefined || include.some((prefix) => k.startsWith(prefix)))\n            ) {\n                errors.push(\n                    `Interface '${intf.name}' of direction '${intf.direction}' ` +\n                    `removed as it was not found in the dataflow.`,\n                );\n\n                // The interface might have to be privatzed\n                this.graph.editor.privatizeInterface(this.graph.id, intf);\n\n                this.removeInput(k);\n            }\n        });\n        Object.entries(stateInputs).forEach(([idA, intfA]) => {\n            if (intfA.direction === undefined) return;\n            const foundIntf = Object.entries(this.inputs).find(\n                ([idB, intfB]) => idB === idA && intfB.direction === intfA.direction,\n            );\n            if (foundIntf === undefined) {\n                const baklavaIntf = new NodeInterface(idA);\n                errors.push(\n                    `Interface '${intfA.name}' of direction '${intfA.direction}' ` +\n                    `created as it was not found in the specification.`,\n                );\n                Object.assign(baklavaIntf, intfA);\n                this.addInterface(baklavaIntf.direction, idA, baklavaIntf);\n            } else if (updateInterfaces) {\n                Object.assign(foundIntf[1], intfA);\n            }\n        });\n\n        Object.entries(this.outputs).forEach(([k, intf]) => {\n            // Process only interfaces, not properties\n            if (intf.direction === undefined) return;\n            if (!Object.keys(stateOutputs).includes(k) &&\n                (include === undefined || include.some((prefix) => k.startsWith(prefix)))\n            ) {\n                errors.push(\n                    `Interface '${intf.name}' of direction '${intf.direction}' ` +\n                    `removed as it was not found in the dataflow.`,\n                );\n\n                // The interface might have to be privatzed\n                this.graph.editor.privatizeInterface(this.graph.id, intf);\n\n                this.removeOutput(k);\n            }\n        });\n        Object.entries(stateOutputs).forEach(([idA, intfA]) => {\n            const foundIntf = Object.entries(this.outputs).find(\n                ([idB, intfB]) => idB === idA && intfB.direction === intfA.direction,\n            );\n            if (foundIntf === undefined) {\n                const baklavaIntf = new NodeInterface(idA);\n                errors.push(\n                    `Interface '${intfA.name}' of direction '${intfA.direction}' ` +\n                    `created as it was not found in the specification.`,\n                );\n                Object.assign(baklavaIntf, intfA);\n                this.addInterface(baklavaIntf.direction, idA, baklavaIntf);\n            } else if (updateInterfaces) {\n                Object.assign(foundIntf[1], intfA);\n            }\n        });\n        return errors;\n    }\n\n    updateProperties(stateProperties) {\n        const errors = [];\n        // Updating properties of a graph node\n        Object.entries(this.inputs).forEach(([k, prop]) => {\n            // Process only properties, not interfaces\n            if (prop.direction !== undefined) return;\n            if (!Object.keys(stateProperties).includes(k)) {\n                errors.push(\n                    `Property '${prop.name}' ` +\n                    `removed as it was not found in the dataflow.`,\n                );\n                this.removeInput(k);\n            }\n        });\n        Object.entries(stateProperties).forEach(([idA, propA]) => {\n            if (propA.direction !== undefined) return;\n            const foundProp = Object.entries(this.inputs).find(\n                ([idB]) => idB === idA,\n            );\n            if (foundProp === undefined) {\n                const baklavaProp = new InputInterface(\n                    propA.name,\n                    propA.value,\n                );\n                errors.push(\n                    `Property '${propA.name}' ` +\n                    `created as it was not found in the specification.`,\n                );\n                Object.assign(baklavaProp, propA);\n                this.addInput(idA, baklavaProp);\n            }\n        });\n        return errors;\n    }\n\n    load(state) {\n        let parsedState;\n\n        // `parsed` determines whether the state was already parsed before loading\n        // This is caused by the fact that `load` can be used both to load a state\n        // from a dataflow and from an instance of a node\n        if (Object.prototype.hasOwnProperty.call(state, 'parsed') && state.parsed) {\n            parsedState = state;\n        } else {\n            parsedState = parseNodeState(state);\n\n            if (Array.isArray(parsedState) && parsedState.length) {\n                return parsedState;\n            }\n        }\n\n        let isWebpack = true;\n        try {\n            isWebpack = window.isWebpack;\n        } catch {\n            isWebpack = false;\n        }\n\n        let errors = [];\n        if (!isWebpack && process.env.VUE_APP_GRAPH_DEVELOPMENT_MODE === 'true') {\n            errors = this.updateInterfaces(parsedState.inputs, parsedState.outputs);\n            errors = [...errors, ...this.updateProperties(parsedState.inputs)];\n        } else {\n            Object.entries(parsedState.inputs).forEach(([name, intf]) => {\n                if (!name.startsWith('property_')) return;\n\n                if (name.startsWith('property_') && name.endsWith(`${DYNAMIC_INTERFACE_SUFFIX}`)) {\n                    this.updateDynamicInterfaces(intf);\n                }\n            });\n\n            errors = detectDiscrepancies(parsedState, this.inputs, this.outputs);\n            if (Array.isArray(errors) && errors.length) {\n                return errors;\n            }\n        }\n\n        super.load(parsedState);\n\n        // Disabling default interface groups if the node has its own state\n        if (Object.keys(parsedState.enabledInterfaceGroups).length) {\n            Object.entries({ ...this.inputs, ...this.outputs }).forEach(([, intf]) => {\n                // If this is an interfaces group\n                if (intf.interfaces !== undefined) {\n                    intf.hidden = true; // eslint-disable-line no-param-reassign\n                }\n            });\n        }\n\n        // Enabling interface groups\n        Object.entries(parsedState.enabledInterfaceGroups).forEach(\n            ([groupName, groupState]) => {\n                if (groupState.direction === 'input' || groupState.direction === 'inout') {\n                    this.inputs[groupName].hidden = false;\n                } else if (groupState.direction === 'output') {\n                    this.outputs[groupName].hidden = false;\n                }\n            },\n        );\n\n        const occupied = { left: [], right: [] };\n\n        const stateios = { ...parsedState.inputs, ...parsedState.outputs };\n\n        // Assigning sides and sides Positions to interfaces\n        Object.entries(stateios).forEach(([ioName, ioState]) => {\n            if (ioState.direction === 'input' || ioState.direction === 'inout') {\n                if (!(ioName in this.inputs)) {\n                    const baklavaIntf = new NodeInterface(ioName);\n                    Object.assign(baklavaIntf, ioState);\n                    this.addInput(ioName, baklavaIntf);\n                }\n                this.inputs[ioName].side = ioState.side;\n                this.inputs[ioName].sidePosition = ioState.sidePosition;\n                this.inputs[ioName].externalName = ioState.externalName;\n                this.inputs[ioName].direction = ioState.direction;\n                occupied[ioState.side].push(ioState.sidePosition);\n            } else if (ioState.direction === 'output') {\n                if (!(ioName in this.outputs)) {\n                    const baklavaIntf = new NodeInterface(ioName);\n                    Object.assign(baklavaIntf, ioState);\n                    this.addOutput(ioName, baklavaIntf);\n                }\n                this.outputs[ioName].side = ioState.side;\n                this.outputs[ioName].sidePosition = ioState.sidePosition;\n                this.outputs[ioName].externalName = ioState.externalName;\n                this.outputs[ioName].direction = ioState.direction;\n                occupied[ioState.side].push(ioState.sidePosition);\n            } else {\n                if (!(ioName in this.inputs)) {\n                    const baklavaIntf = new InputInterface(ioName);\n                    Object.assign(baklavaIntf, ioState);\n                    this.addInput(ioName, baklavaIntf);\n                }\n                this.inputs[ioName].externalName = ioState.externalName;\n            }\n        });\n\n        const refreshSidePositions = (entries) => {\n            // When state provided in the graph is incomplete, e.g. it misses\n            // an interface, we allow it.\n            // This, however, requires from us that we make sure that newly added\n            // interfaces (not present in parsedState) are not on conflicting positions\n            Object.entries(entries).forEach(([ioName, ioState]) => {\n                if (ioName.startsWith('property_')) return;\n                // if interface was explicitly defined in the graph file, skip it\n                if (ioName in stateios) return;\n                // otherwise, if the interface was implicitly created but it does not\n                // cover existing interface, skip it\n                if (!occupied[ioState.side].includes(ioState.sidePosition)) return;\n                // if the positions are clashing, pick first available max position on\n                // given side\n                const maxposition = Math.max(...occupied[ioState.side]);\n                ioState.sidePosition = maxposition + 1; // eslint-disable-line no-param-reassign\n                occupied[ioState.side].push(maxposition + 1);\n            });\n        };\n\n        refreshSidePositions(this.inputs);\n        refreshSidePositions(this.outputs);\n\n        // Default position should be undefined instead of (0, 0) so that it can be set\n        // by autolayout\n        if (state.position === undefined) {\n            this.position = undefined;\n        }\n\n        this.relatedGraphs = state.relatedGraphs;\n        return errors;\n    }\n\n    onPlaced() {\n        super.onPlaced();\n        const externalRequest = ([method, params]) => this.graphInstance\n            ?.editor\n            ?.editorManager\n            ?.externalApplicationManager\n            ?.request(method, params);\n        const goToGraph = (graphid) => this.graphInstance\n            ?.editor.switchToRelatedGraph(graphid);\n        Object.entries(this.inputs)\n            .filter(([name, _]) => name.startsWith('property_'))\n            .filter(([_, intf]) => intf.componentName === 'ButtonInterface')\n            .forEach(([_, intf]) => (intf.type === 'button-graph' ? intf.events.updated.subscribe(this, goToGraph) : intf.events.updated.subscribe(this, externalRequest)),\n            );\n    }\n\n    onDestroy() {\n        [...Object.values(this.inputs), ...Object.values(this.outputs)].forEach((io) => {\n            Object.values(io.events).forEach((event) => {\n                // We need to unsubscribe from all events to avoid memory leaks\n                // On token mismatch, the event will not be unsubscribed\n                event.unsubscribe(this);\n                event.unsubscribe(io);\n            });\n        });\n    }\n}\n\n/**\n * @param parsedInterfaces that are validated and parsed. The format\n * should be the same as the one returned by parseInterfaces.\n * @returns created interfaces\n */\nexport const createBaklavaInterfaces = (parsedInterfaces) => {\n    function createBaklavaInterface(intf) {\n        return () => {\n            const baklavaIntf = new NodeInterface(intf.name);\n            Object.assign(baklavaIntf, intf);\n            return baklavaIntf;\n        };\n    }\n\n    // Creating interfaces for baklavajs\n    const inputs = Object.fromEntries(\n        Object.entries(parsedInterfaces.inputs).map(\n            ([n, intf]) => [n, createBaklavaInterface(intf)],\n        ),\n    );\n\n    const outputs = Object.fromEntries(\n        Object.entries(parsedInterfaces.outputs).map(\n            ([n, intf]) => [n, createBaklavaInterface(intf)],\n        ),\n    );\n\n    return [inputs, outputs];\n};\n\n/**\n * Class factory that creates a class for a custom Node that is described by the arguments.\n * It can be later registered so that the user can use it and save the editor.\n * `inputs`, `properties` and `outputs` formats are described in the documentation.\n *\n * @param {string} name Name of the block that is stored when saving\n * @param {string} layer Layer of the node\n * @param {*} interfaces List of interfaces in the block (input, output and inout)\n * @param {*} properties List of properties of the block\n * @param {*} interfaceGroups Object describing groups of interfaces\n * @param {*} defaultInterfaceGroups Object describing groups of interfaces that\n * are enabled by default\n * @param {boolean} twoColumn type of layout of the nodes\n * @returns Node based class is successful, otherwise an array of errors is returned.\n */\nexport function CustomNodeFactory(\n    name,\n    layer,\n    interfaces,\n    properties,\n    interfaceGroups,\n    defaultInterfaceGroups,\n    twoColumn,\n    description = '',\n    nodeExtends = [],\n    nodeExtending = [],\n    nodeSiblings = [],\n    width = 300,\n) {\n    const generatedProperties = generateProperties(interfaces);\n    if (!generatedProperties.success) {\n        return generatedProperties.value.map((error) => `Node ${name} invalid. ${error}`);\n    }\n\n    const parsedInterfaces = parseInterfaces(interfaces, interfaceGroups, defaultInterfaceGroups);\n    // If parsedInterfaces returns an array, it is an array of errors\n    if (Array.isArray(parsedInterfaces) && parsedInterfaces.length) {\n        return parsedInterfaces.map((error) => `Node ${name} invalid. ${error}`);\n    }\n    const [inputs, newOutputs] = createBaklavaInterfaces(parsedInterfaces);\n\n    const parsedProperties = parseProperties([...properties, ...generatedProperties.value]);\n    // If parsedProperties returns an array, it is an array of errors\n    if (Array.isArray(parsedProperties) && parsedProperties.length) {\n        return parsedProperties.map((error) => `Node ${name} invalid. ${error}`);\n    }\n    const createdProperties = createProperties(parsedProperties);\n\n    const newInputs = {\n        ...inputs,\n        ...createdProperties,\n    };\n\n    return class extends CustomNode {\n        constructor() {\n            super(\n                name,\n                layer,\n                newInputs,\n                newOutputs,\n                twoColumn,\n                description,\n                nodeExtends,\n                nodeExtending,\n                nodeSiblings,\n                width,\n            );\n        }\n    };\n}\n\n/**\n * Function checks for duplicate interface names in the subgraph.\n *\n * An error message is returned for each duplicate name.\n *\n * @param interfaces External interfaces in the subgraph\n *\n * @returns List of new interfaces and errors\n */\nfunction checkInterfaceNames(interfaces) {\n    const countedIntfNames = Object.create(null);\n    const externalInterfaces = [];\n    interfaces?.forEach(\n        ([, intf]) => {\n            countedIntfNames[intf.externalName] = (countedIntfNames[intf.externalName] ?? 0) + 1;\n            if (countedIntfNames[intf.externalName] === 1) {\n                externalInterfaces.push(intf);\n            } else {\n                externalInterfaces.push(`Interface '${intf.externalName}' is repeated ${countedIntfNames[intf.externalName]} times.`);\n            }\n        },\n    );\n    return externalInterfaces;\n}\n\nfunction updateInterfaceRegistry(intf, graphId) {\n    // It may happen that the registered interface has the same id, but is a reference,\n    // for example when dealing with history or clipboard.\n    if (\n        ir.isRegistered(intf.id) &&\n        ir.getRegisteredInterface(intf.id).sharedInterface !== intf &&\n        ir.getRegisteredInterface(intf.id).sharedInterface.id === intf.id &&\n        ir.getRegisteredInterface(intf.id).sharedInterfaceGraphId === graphId\n    ) {\n        ir.deleteRegisteredInterface(intf.id);\n    }\n\n    if (!ir.isRegistered(intf.id)) {\n        ir.registerInterface(intf, graphId);\n    }\n}\n\n/**\n * Function looks for graph node interfaces based on the nodes inside of it.\n *\n * It finds all interfaces that have `externalName` property set and registers\n * them in the InterfaceRegistry, if they are not already registered, so that\n * they their state can be easily shared and synchronized.\n *\n * If there are any errors, they are returned as an array of strings.\n * If the operation was successful, the new inputs and outputs are returned.\n *\n * @param nodes Nodes of the subgraph\n * @param inputs List of inputs of the subgraph\n * @param outputs List of outputs of the subgraph\n *\n * @returns List of errors or new inputs and outputs\n */\nexport function updateSubgraphInterfaces(nodes, inputs = [], outputs = []) {\n    // Interfaces that are not connected to any other interface\n    const INTERFACE_PREFIXES = ['input_', 'inout_', 'output_'];\n\n    const exposedIntf = [\n        ...nodes.map((node) => Object.entries({ ...node.inputs, ...node.outputs })).flat(),\n    ].filter(([key]) => INTERFACE_PREFIXES.some((prefix) => key.startsWith(prefix)))\n        .filter(\n            ([, intf]) => intf.externalName,\n        );\n\n    // Filter out repeated external names\n    const externalInterfaces = checkInterfaceNames(exposedIntf);\n    const errorMessages = externalInterfaces.filter((n) => typeof n === 'string');\n    if (errorMessages.length) {\n        return errorMessages;\n    }\n\n    // Create new inputs and outputs\n    const newInterfaces = [];\n    externalInterfaces.forEach((intf) => {\n        const graphId = nodes[0].graph.id;\n        updateInterfaceRegistry(intf, graphId);\n\n        const container = intf.direction === 'output' ? outputs : inputs;\n        const idx = container.findIndex((x) => x.id === intf.id);\n        if (idx === -1) {\n            // Graph node interface should not inherit some properties that\n            // are node-specific, they will be accessed using InterfaceRegistry\n            newInterfaces.push({\n                name: intf.externalName,\n                id: intf.id,\n                externalName: undefined,\n                side: intf.side,\n                direction: intf.direction,\n                sidePosition: undefined,\n            });\n        } else {\n            container[idx].name = intf.externalName;\n            newInterfaces.push(container[idx]);\n        }\n    });\n\n    const newInterfacesPositionsOrErrors = applySidePositions(newInterfaces, {});\n    if (Array.isArray(newInterfacesPositionsOrErrors) && newInterfacesPositionsOrErrors.length) {\n        return newInterfacesPositionsOrErrors;\n    }\n\n    return {\n        inputs: Object.values(newInterfacesPositionsOrErrors.inputs),\n        outputs: Object.values(newInterfacesPositionsOrErrors.outputs),\n    };\n}\n\n/**\n * Function looks for graph node properties based on the nodes inside of it.\n *\n * If there are any errors, they are returned as an array of strings.\n * If the operation was successful, the new properties are returned.\n *\n * @param nodes Nodes of the subgraph\n *\n * @returns List of errors or new properties\n */\nexport function updateSubgraphProperties(nodes) {\n    const exposedProperties = nodes.map((node) => Object.entries(node.inputs)).flat()\n        .filter(([key]) => key.startsWith('property_'))\n        .filter(([, prop]) => prop.externalName);\n\n    // Filter out repeated external names\n    const externalProperties = checkInterfaceNames(exposedProperties);\n    const errorMessages = externalProperties?.filter((n) => typeof n === 'string');\n    if (errorMessages.length) {\n        return errorMessages;\n    }\n\n    const newProperties = [];\n    externalProperties.forEach((property) => {\n        const graphId = nodes[0].graph.id;\n        updateInterfaceRegistry(property, graphId);\n\n        newProperties.push({\n            name: property.externalName,\n            id: property.id,\n            externalName: undefined,\n            type: property.type,\n            value: property.value,\n            description: property.description,\n            default: property.default,\n            min: property.min,\n            max: property.max,\n            step: property.step,\n            values: property.items,\n            dtype: property.dtype,\n            override: property.override,\n            readonly: property.readonly,\n        });\n    });\n    return newProperties;\n}\n\n/**\n * Function creating a graph template as defined in specification\n *\n * @param nodes Nodes of the subgraph\n * @param connections Connections inside the subgraph\n * @param name Default name that will be displayed in editor\n * @param editor PipelineManagerEditor instance\n * @returns Graph template that will be used to define the subgraph node\n */\nexport function GraphFactory(nodes, connections, name, editor) {\n    const parsedState = nodes.map((node) => parseNodeState(node));\n    const errorMessages = parsedState.filter((n) => typeof n === 'string');\n    if (errorMessages.length) {\n        return errorMessages;\n    }\n\n    const state = {\n        name,\n        nodes: parsedState,\n        connections,\n        inputs: [],\n        outputs: [],\n    };\n\n    return new GraphTemplate(state, editor);\n}\n","/*\n * Copyright (c) 2025 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { reactive } from 'vue';\n/**\n * Configuration state for the configuration menu.\n * This state is reactive and can be accessed and modified from any component.\n * It is used to control the visibility of the configuration menu and its options.\n */\nexport const menuState = reactive({\n    configurationMenu: {\n        visible: false,\n        addNode: false,\n        placeNode: false,\n    },\n    propertyMenu: false,\n    interfaceMenu: false,\n    propertyListMenu: false,\n    interfaceListMenu: false,\n    layerMenu: false,\n});\n/**\n * Configuration state for the node data.\n * It is used to store the node data that is being configured.\n */\nexport const configurationState = reactive({\n    nodeData: {\n        name: 'Custom Node',\n        category: 'Default category',\n        layer: '',\n        description: '',\n        color: '',\n    },\n    properties: [],\n    interfaces: [],\n    success: false,\n});\n","/*\n * Copyright (c) 2022-2023 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n *\n */\n\nimport cytoscape from 'cytoscape';\nimport cola from 'cytoscape-cola';\nimport dagre from 'cytoscape-dagre';\n\nimport BaseLayoutEngine from './baseEngine.js';\n\ncytoscape.use(dagre);\ncytoscape.use(cola);\n\nexport default class CytoscapeLayoutEngine extends BaseLayoutEngine {\n    // The only cytoscape algorithm not defined here are 'null' (every node to\n    // (0, 0)) and 'preset' (every node to user defined position)\n    availableAlgorithms = [\n        'cola',\n        'dagre-network-simplex',\n        'dagre-tight-tree',\n        'dagre-longest-path',\n        'random',\n        'grid',\n        'circle',\n        'concentric',\n        'breadthfirst',\n        'cose',\n    ];\n\n    async calculate(graph) {\n        const cytoscapeGraph = cytoscape({\n            elements: {\n                nodes: graph.nodes.map((node) => ({\n                    data: { id: node.id, width: node.width, height: node.height },\n                })),\n                edges: graph.connections.map((connection) => ({\n                    data: { id: connection.id, source: connection.from, target: connection.to },\n                })),\n            },\n            style: [\n                {\n                    selector: 'node',\n                    style: {\n                        shape: 'rectangle',\n                        width: 'data(width)',\n                        height: 'data(height)',\n                    },\n                },\n            ],\n            styleEnabled: true,\n        });\n\n        const options = { name: this.activeAlgorithm };\n        /* eslint-disable no-unused-vars */\n        switch (this.activeAlgorithm) {\n            case 'random':\n                options.boundingBox = {\n                    x1: 0,\n                    y1: 0,\n                    w: 2000,\n                    h: 2000,\n                };\n                break;\n            case 'grid':\n                options.avoidOverlapPadding = 150;\n                break;\n            case 'cose':\n                options.nodeOverlap = 1000;\n                options.idealEdgeLength = (edge) => 300;\n                break;\n            case 'cola':\n                options.nodeSpacing = (node) => 150;\n                break;\n            case 'dagre-network-simplex':\n            case 'dagre-tight-tree':\n            case 'dagre-longest-path': {\n                const [name, ...ranker] = this.activeAlgorithm.split('-');\n                options.nodeSep = 50;\n                options.rankSep = 100;\n                options.ranker = ranker.join('-');\n                options.name = name;\n                break;\n            }\n            default:\n                break;\n        }\n        /* eslint-enable no-unused-vars */\n\n        const layout = cytoscapeGraph.layout(options);\n        layout.run();\n        if (['cose', 'cola'].includes(this.activeAlgorithm)) {\n            // wait until asynchronous algorithm finish calculations\n            await layout.promiseOn('layoutstop');\n        }\n        return {\n            ...graph,\n            nodes: cytoscapeGraph.nodes().map((node) => ({\n                id: node.id(),\n                // node.position defines the center of node but graph representation\n                // required coordinates of top left corner\n                position: {\n                    x: node.position().x - node.width() / 2,\n                    y: node.position().y - node.height() / 2,\n                },\n            })),\n        };\n    }\n}\n","/*\n * Copyright (c) 2022-2024 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\nconst defaultDirection = 'inout';\n\n/**\n * Dynamic interfaces that are controlled with a dedicated property\n * are suffixed with `DYNAMIC_INTERFACE_SUFFIX`.\n*/\nexport const DYNAMIC_INTERFACE_SUFFIX = 'count';\n\n/**\n * Returns a prepared interface that is passed to baklava constructor\n *\n * @param io configuration of the interface\n * @param hidden whether th interface should be hidden. For example groups of interfaces\n * are hidden by default\n * @param {*} name custom name for the interface that should be used instead of the one coming\n * from `io`\n * @returns baklava interface constructor\n */\nfunction createInterface(io, hidden, name = undefined) {\n    const intf = {};\n    Object.assign(intf, io);\n\n    intf.name = name ?? io.name;\n    if (intf.type !== undefined) {\n        intf.type = typeof io.type === 'string' || io.type instanceof String ? [io.type] : io.type;\n    }\n    intf.componentName = 'NodeInterface';\n    intf.hidden = hidden;\n\n    // Readonly values used for detecting whether there were any changes to the interface\n    intf.originalSide = intf.side;\n    intf.originalSidePosition = intf.sidePosition;\n    return intf;\n}\n\n/**\n * Parses and validates interfaces passed in specification\n *\n * @param interfaces list of interfaces from specification that is going to be parsed\n * @param interfaceGroup determines whether `interfaces` are interface groups. If true the\n * additionally field `.interfaces` is parsed.\n * @returns parsed interfaces that can be passed to baklavajs if the interfaces were valid.\n * Otherwise an array of errors is returned.\n */\nfunction parseSingleInterfaces(interfaces, interfaceGroup = false) {\n    const errors = [];\n    const tempParsed = {\n        input: {},\n        inout: {},\n        output: {},\n    };\n\n    interfaces.forEach((io) => {\n        // Omitting interfaces that are marked as dynamic, as they are generated\n        // using 'updateDynamicInterfaces function\n        if (Object.prototype.hasOwnProperty.call(io, 'dynamic')) return;\n\n        // Copy the interface to avoid modifying the original object\n        const tempIO = JSON.parse(JSON.stringify(io));\n\n        const direction = io.direction ?? defaultDirection;\n        tempIO.direction = direction;\n\n        if (io.array !== undefined) {\n            const [left, right] = io.array;\n\n            for (let j = left; j < right; j += 1) {\n                const name = `${io.name}[${j}]`;\n\n                if (tempParsed[direction][name] !== undefined) {\n                    errors.push(\n                        `Interface named '${name}' of direction '${direction}' is a duplicate.`,\n                    );\n                }\n                tempIO.externalName = io.externalName ? `${io.externalName}[${j}]` : undefined;\n\n                // Copy the interface to avoid modifying the assigned object\n                tempParsed[direction][name] = JSON.parse(JSON.stringify(tempIO));\n            }\n        } else {\n            if (tempParsed[direction][io.name] !== undefined) {\n                errors.push(\n                    `Interface named '${io.name}' of direction '${direction}' is a duplicate.`,\n                );\n            }\n\n            tempParsed[direction][io.name] = tempIO;\n        }\n\n        if (interfaceGroup) {\n            const newInterfaces = [];\n\n            tempIO.interfaces.forEach((buildingIO) => {\n                const bdirection = buildingIO.direction ?? defaultDirection;\n                if (buildingIO.array !== undefined) {\n                    const [left, right] = buildingIO.array;\n\n                    for (let j = left; j < right; j += 1) {\n                        const name = `${bdirection}_${buildingIO.name}[${j}]`;\n                        newInterfaces.push(name);\n                    }\n                } else {\n                    const name = `${bdirection}_${buildingIO.name}`;\n                    newInterfaces.push(name);\n                }\n            });\n            tempIO.interfaces = newInterfaces; // eslint-disable-line no-param-reassign\n        }\n    });\n\n    // Removing inout with duplicate names\n    const filteredTempInouts = Object.fromEntries(\n        Object.entries(tempParsed.inout).filter(([name, state]) => {\n            const direction = state.direction ?? defaultDirection;\n            const duplicate =\n                Object.keys(tempParsed.output).includes(name) ||\n                Object.keys(tempParsed.input).includes(name);\n            if (duplicate) {\n                errors.push(\n                    `Interface named '${name}' of direction '${direction}' ` +\n                        `is a duplicate. There already exists an input or output of this name.`,\n                );\n            }\n            return !duplicate;\n        }),\n    );\n\n    tempParsed.inout = filteredTempInouts;\n    tempParsed.input = { ...tempParsed.input, ...tempParsed.inout };\n    delete tempParsed.inout;\n\n    tempParsed.input = Object.fromEntries(\n        Object.entries(tempParsed.input).map(([name, state]) => [\n            `${state.direction}_${name}`,\n            state,\n        ]),\n    );\n    tempParsed.output = Object.fromEntries(\n        Object.entries(tempParsed.output).map(([name, state]) => [\n            `${state.direction}_${name}`,\n            state,\n        ]),\n    );\n\n    if (errors.length) {\n        return errors;\n    }\n\n    return tempParsed;\n}\n\n/**\n * Checks whether interface groups that are in enabledInterfaceGroup\n * can be enabled at the same time\n * @param {array} enabledInterfaceGroups array of names of enabled interface groups\n * @param {*} inputs inputs of the node\n * @param {*} outputs outputs of the node\n * @returns list tuples that have information about conflicting interfaces.\n */\nexport function validateInterfaceGroupsNames(enabledInterfaceGroups, inputs, outputs) {\n    const errors = [];\n    // Checking for integrity of interface groups\n    const usedInterfaces = new Set();\n\n    enabledInterfaceGroups.forEach((name) => {\n        const interfaces = inputs[name]?.interfaces ?? outputs[name]?.interfaces;\n        const groupDirection = name.slice(0, name.indexOf('_'));\n        const groupName = name.slice(name.indexOf('_') + 1);\n\n        interfaces.forEach((intfName) => {\n            if (usedInterfaces.has(intfName)) {\n                const intfDirection = intfName.slice(0, intfName.indexOf('_'));\n                const parsedIntfName = intfName.slice(intfName.indexOf('_') + 1);\n\n                errors.push([parsedIntfName, intfDirection, groupName, groupDirection]);\n            } else {\n                usedInterfaces.add(intfName);\n            }\n        });\n    });\n    return errors;\n}\n\n/**\n * Checks whether interface groups that are in enabledInterfaceGroup\n * can be enabled at the same time\n * @param {array} enabledInterfaceGroups array of names of enabled interface groups\n * @param {*} inputs inputs of the node\n * @param {*} outputs outputs of the node\n * @returns list of explicit errors.\n */\nexport function validateInterfaceGroups(enabledInterfaceGroups, inputs, outputs) {\n    const errors = validateInterfaceGroupsNames(enabledInterfaceGroups, inputs, outputs);\n    const errorMessages = [];\n\n    errors.forEach(([parsedIntfName, intfDirection, groupName, groupDirection]) => {\n        errorMessages.push(\n            `Interface of name '${parsedIntfName}' and direction '${intfDirection}' has been reused ` +\n                `by interface group named '${groupName}' of direction '${groupDirection}'. ` +\n                `Make sure your interface groups are disjoint.`,\n        );\n    });\n\n    return errorMessages;\n}\n\n/**\n *\n * @param {*} inputs inputs of the node\n * @param {*} outputs outputs of the node\n * @returns inputs and outputs of the nodes with `sidePositions` assigned if\n * there were no errors found. Otherwise a list of errors is returned.\n */\nexport function applySidePositions(inputs, outputs) {\n    const tempParsedSides = {\n        left: {},\n        right: {},\n    };\n\n    const errors = [];\n\n    // Dividing interfaces into left and right sides\n    Object.entries({ ...inputs, ...outputs }).forEach(([name, intf]) => {\n        if (intf.side === 'right' || (intf.side === undefined && intf.direction === 'output')) {\n            tempParsedSides.right[name] = { ...intf };\n            tempParsedSides.right[name].side = 'right';\n        } else if (intf.side === 'left' || (intf.side === undefined && intf.direction !== 'output')) {\n            tempParsedSides.left[name] = { ...intf };\n            tempParsedSides.left[name].side = 'left';\n        }\n    });\n\n    const stripName = (name) => name.slice(name.indexOf('_') + 1);\n\n    // validating and setting sidePositions\n    const occupiedInputSidePositions = new Set();\n    const occupiedOutputSidePositions = new Set();\n\n    Object.entries(tempParsedSides.left).forEach(([name, intf]) => {\n        if (intf.sidePosition !== undefined) {\n            if (occupiedInputSidePositions.has(intf.sidePosition)) {\n                errors.push(\n                    `Interface named '${stripName(name)}' of direction '${intf.direction}' has ` +\n                        `invalid sidePosition value '${intf.sidePosition}'. ` +\n                        `There already exists an input or output with this sidePosition.`,\n                );\n            }\n            occupiedInputSidePositions.add(intf.sidePosition);\n        }\n    });\n\n    Object.entries(tempParsedSides.right).forEach(([name, intf]) => {\n        if (intf.sidePosition !== undefined) {\n            if (occupiedOutputSidePositions.has(intf.sidePosition)) {\n                errors.push(\n                    `Interface named '${stripName(name)}' of direction '${intf.direction}' has ` +\n                        `invalid sidePosition value '${intf.sidePosition}'. ` +\n                        `There already exists an input or output with this sidePosition.`,\n                );\n            }\n            occupiedOutputSidePositions.add(intf.sidePosition);\n        }\n    });\n\n    if (errors.length) {\n        return errors;\n    }\n\n    let leftSidePositionIndex = 0;\n    let rightSidePositionIndex = 0;\n\n    const getLeftSidePos = (intf) => {\n        if (intf.sidePosition === undefined) {\n            while (occupiedInputSidePositions.has(leftSidePositionIndex)) {\n                leftSidePositionIndex += 1;\n            }\n            occupiedInputSidePositions.add(leftSidePositionIndex);\n            return leftSidePositionIndex;\n        }\n        return intf.sidePosition;\n    };\n\n    const getRightSidePos = (intf) => {\n        if (intf.sidePosition === undefined) {\n            while (occupiedOutputSidePositions.has(rightSidePositionIndex)) {\n                rightSidePositionIndex += 1;\n            }\n            occupiedOutputSidePositions.add(rightSidePositionIndex);\n            return rightSidePositionIndex;\n        }\n        return intf.sidePosition;\n    };\n\n    Object.entries(tempParsedSides.left).forEach(([, intf]) => {\n        intf.sidePosition = getLeftSidePos(intf); // eslint-disable-line no-param-reassign,max-len\n    });\n\n    Object.entries(tempParsedSides.right).forEach(([, intf]) => {\n        intf.sidePosition = getRightSidePos(intf); // eslint-disable-line no-param-reassign,max-len\n    });\n\n    return {\n        inputs: Object.fromEntries(\n            Object.entries({ ...tempParsedSides.left, ...tempParsedSides.right })\n                .filter(([, intf]) => intf.direction !== 'output'),\n        ),\n        outputs: Object.fromEntries(\n            Object.entries({ ...tempParsedSides.left, ...tempParsedSides.right })\n                .filter(([, intf]) => intf.direction === 'output'),\n        ),\n    };\n}\n\n/**\n * The function reads provided `parsedInterfaces` and looks for interfaces with `dynamic` attribute.\n * For such interfaces, a dedicated property is created that controls the number interface\n * instances. The properties are returned and should be included in node creation.\n *\n * @param {Object} interfaces List of interfaces.\n * @return Object with two properties, success and value. If success is true, value contains\n * an array of properties that should be included in the node. Otherwise, value contains an array\n * of errors.\n */\nexport function generateProperties(interfaces) {\n    const errors = [];\n    const properties = [];\n    interfaces.forEach(\n        (intf) => {\n            if (Object.prototype.hasOwnProperty.call(intf, 'dynamic')) {\n                if (\n                    Array.isArray(intf.dynamic) &&\n                    intf.dynamic.length === 2 &&\n                    Number.isInteger(intf.dynamic[0]) &&\n                    Number.isInteger(intf.dynamic[1])\n                ) {\n                    // Property should have limits specified by 'intf.dynamic' value\n                    properties.push({\n                        name: `${intf.name} ${intf.direction} ${DYNAMIC_INTERFACE_SUFFIX}`,\n                        type: 'integer',\n                        min: intf.dynamic[0],\n                        max: intf.dynamic[1],\n                        default: intf.dynamic[0],\n                        // The type of dynamic interfaces is stored as `interfaceType`\n                        interfaceType: intf.type,\n                        interfaceMaxConnectionCount: intf.maxConnectionCount,\n                    });\n                } else if (intf.dynamic === true) {\n                    // Property should not have limits\n                    properties.push({\n                        name: `${intf.name} ${intf.direction} ${DYNAMIC_INTERFACE_SUFFIX}`,\n                        type: 'integer',\n                        min: 0,\n                        default: 0,\n                        // The type of dynamic interfaces is stored as `interfaceType`\n                        interfaceType: intf.type,\n                        interfaceMaxConnectionCount: intf.maxConnectionCount,\n                    });\n                } else {\n                    errors.push(\n                        `Interface '${intf.name}' has invalid 'dynamic' attribute. ` +\n                        'It should be either a boolean or an array with two integer elements.',\n                    );\n                }\n            }\n        },\n    );\n\n    if (errors.length) {\n        return { success: false, value: errors };\n    }\n    return { success: true, value: properties };\n}\n\n/**\n * @param {*} interfaces List of interfaces in the block (input, output and inout)\n * @param {*} interfaceGroups Object describing groups of interfaces'\n * @param {*} defaultInterfaceGroups Object describing groups of interfaces that are enabled\n * @returns object that has inputs and outputs key if parsing was successful,\n * a list of errors otherwise.\n */\nexport function parseInterfaces(\n    interfaces,\n    interfaceGroups,\n    defaultInterfaceGroups,\n) {\n    let errors = [];\n\n    // Parsing single interfaces first\n    const tempParsed = parseSingleInterfaces(interfaces);\n\n    // If parseSingleInterfaces returns an array, it is an array of errors\n    if (Array.isArray(tempParsed) && tempParsed.length) {\n        return tempParsed;\n    }\n\n    // Checking for integrity of interface groups\n    interfaceGroups.forEach((intfG) => {\n        const directionG = intfG.direction ?? defaultDirection;\n        intfG.interfaces.forEach((intf) => {\n            const direction = intf.direction ?? defaultDirection;\n            if (intf.array !== undefined) {\n                const [left, right] = intf.array;\n\n                for (let j = left; j < right; j += 1) {\n                    const name = `${direction}_${intf.name}[${j}]`;\n                    if (\n                        !Object.keys({ ...tempParsed.input, ...tempParsed.output }).includes(name)\n                    ) {\n                        errors.push(\n                            `Interface named '${intf.name}[${j}]' of direction '${direction}' ` +\n                                `used for interface group '${intfG.name}' of direction ` +\n                                `'${directionG}' does not exist.`,\n                        );\n                    }\n                }\n            } else {\n                const name = `${direction}_${intf.name}`;\n                if (!Object.keys({ ...tempParsed.input, ...tempParsed.output }).includes(name)) {\n                    errors.push(\n                        `Interface named '${intf.name}' of direction '${direction}' ` +\n                            `used for interface group '${intfG.name}' of direction ` +\n                            `'${directionG}' does not exist.`,\n                    );\n                }\n            }\n        });\n    });\n\n    if (errors.length) {\n        return errors;\n    }\n\n    const tempParsedGroups = parseSingleInterfaces(interfaceGroups, true);\n    // If parseSingleInterfaces returns an array, it is an array of errors\n    if (Array.isArray(tempParsedGroups) && tempParsedGroups.length) {\n        return tempParsedGroups;\n    }\n\n    // All interfaces that create some interfaces groups\n    const interfacesCreatingGroups = new Set();\n    Object.values({\n        ...tempParsedGroups.input,\n        ...tempParsedGroups.output,\n    }).forEach((state) => {\n        state.interfaces.forEach((intf) => interfacesCreatingGroups.add(intf));\n    });\n\n    // Detecting integrity of enabled interface groups\n    const enabledInterfaceGroupsNames = defaultInterfaceGroups.map(\n        (group) => `${group.direction ?? defaultDirection}_${group.name}`,\n    );\n\n    errors = validateInterfaceGroups(\n        enabledInterfaceGroupsNames,\n        { ...tempParsedGroups.input, ...tempParsed.input },\n        { ...tempParsedGroups.output, ...tempParsed.output },\n    );\n\n    if (errors.length) {\n        return errors;\n    }\n\n    // Interfaces that belong to groups are removed as they should not have side\n    // positions applied as they are never rendered\n    tempParsed.input = Object.fromEntries(Object.entries(tempParsed.input).filter(\n        ([name]) => !interfacesCreatingGroups.has(name),\n    ));\n\n    tempParsed.output = Object.fromEntries(Object.entries(tempParsed.output).filter(\n        ([name]) => !interfacesCreatingGroups.has(name),\n    ));\n\n    const parsedSides = applySidePositions(\n        { ...tempParsed.input, ...tempParsedGroups.input },\n        { ...tempParsed.output, ...tempParsedGroups.output },\n    );\n    if (Array.isArray(parsedSides) && parsedSides.length) {\n        return parsedSides;\n    }\n\n    const stripName = (name) => name.slice(name.indexOf('_') + 1);\n\n    const createdInterfaces = {\n        inputs: {},\n        outputs: {},\n    };\n\n    // Filtering single interfaces that are part of interface groups\n    // Those interfaces are removed as they are never rendered\n    // This is only used when parsing a specification format\n    Object.entries(parsedSides.inputs).forEach(([name, intf]) => {\n        // It is an interface group\n        if (intf.interfaces !== undefined) {\n            // Adding interfaces groups, hidden by default\n            createdInterfaces.inputs[name] = createInterface(\n                intf,\n                !enabledInterfaceGroupsNames.includes(name),\n                stripName(name),\n            );\n        } else {\n            createdInterfaces.inputs[name] = createInterface(\n                intf,\n                false,\n                stripName(name),\n            );\n        }\n    });\n\n    Object.entries(parsedSides.outputs).forEach(([name, intf]) => {\n        // It is an interface group\n        if (intf.interfaces !== undefined) {\n            // Adding interfaces groups, hidden by default\n            createdInterfaces.outputs[name] = createInterface(\n                intf,\n                !enabledInterfaceGroupsNames.includes(name),\n                stripName(name),\n            );\n        } else {\n            createdInterfaces.outputs[name] = createInterface(\n                intf,\n                false,\n                stripName(name),\n            );\n        }\n    });\n\n    return createdInterfaces;\n}\n","/*\n * Copyright (c) 2024 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Class used to store the current specification and unresolved specification\n * of the current session.\n *\n * This class should be used as a singleton and should be accessed using the\n * getInstance() function.\n */\nexport default class Specification {\n    static instance = undefined;\n\n    /**\n     * Current resolved specification.\n     * @type {any}\n     */\n    currentSpecification = undefined;\n\n    /**\n     * Specification build from `include` and `includeGraph` directives.\n     * @type {any}\n     */\n    includedSpecification = undefined;\n\n    /**\n     * Current unresolved specification.\n     * @type {any}\n     */\n    unresolvedSpecification = undefined;\n\n    constructor() {\n        if (Specification.instance !== undefined) {\n            throw new Error('Error - use Specification.getInstance()');\n        }\n    }\n\n    /**\n     * Static function used to get the instance of the Specification in a singleton manner.\n     * If there is no existing instance of the Specification then a new one is created.\n     *\n     * @returns {Specification} Instance of Specification.\n     */\n    static getInstance() {\n        if (!Specification.instance) {\n            Specification.instance = new Specification();\n        }\n        return Specification.instance;\n    }\n\n    /**\n     * Searches the current specification for a node with the given name.\n     *\n     * @param nodeName name of the node that is to be found in the specification\n     * @returns the specification of the node if it exists, otherwise undefined\n     */\n    getNodeSpecification(nodeName) {\n        if (this.currentSpecification === undefined) return undefined;\n\n        return this.currentSpecification.nodes.find(\n            (n) => n.name === nodeName,\n        );\n    }\n}\n","/*\n * Copyright (c) 2022-2025 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { stringify } from 'ajv';\nimport jsonMap from 'json-source-map';\nimport jsonlint from 'jsonlint';\n\n/**\n * Validates JSON according to a given schema.\n *\n * @param {import('ajv/dist/2019').Ajv2019} ajv - JSON validator.\n * @param {Object} schema - Validation schema.\n * @param {Object|string} data - Data to validate.\n * @param {string} reference - Schema entity.\n * @returns {string[]} Validation errors.\n */\nexport default function validateJSON(ajv, schema, data, reference = '') {\n    ajv.removeSchema('root').removeSchema(schema.$id).addSchema(schema, 'root');\n    const validate = ajv.getSchema(`root${reference}`);\n    if (validate === undefined) {\n        return [`Invalid value of \"reference\" parameter: ${reference}`];\n    }\n\n    const isTextFormat = typeof data === 'string';\n    let dataJSON;\n\n    try {\n        dataJSON = isTextFormat ? jsonlint.parse(data) : data;\n    } catch (exception) {\n        return [`Not a proper JSON file: ${exception.toString()}`];\n    }\n\n    const valid = validate(dataJSON);\n\n    if (valid) {\n        return [];\n    }\n\n    // Parsing errors messages to a human readable string\n    const errors = validate.errors?.map((error) => {\n        // It is assumed that the id of the schema is for example `dataflow_schema`\n        // Here a prefix is obtained\n        const nameOfEntity = schema.$id.replace(/((_params)|(_returns))?(_schema)?(.json)?$/, '');\n        const path = `${nameOfEntity}${error.instancePath}`;\n        let errorPrefix = '';\n\n        if (isTextFormat) {\n            const result = jsonMap.parse(data);\n            // 1 is added as the lines are numbered from 0\n            const lineStart = result.pointers[error.instancePath].value.line + 1;\n            const lineEnd = result.pointers[error.instancePath].valueEnd.line + 1;\n\n            if (lineStart === lineEnd) {\n                errorPrefix = `Line ${lineStart} -`;\n            } else {\n                errorPrefix = `Lines ${lineStart}-${lineEnd} -`;\n            }\n        }\n\n        switch (error.keyword) {\n            case 'enum':\n                return `${errorPrefix} ${path} ${error.message} - ${stringify(\n                    error.params.allowedValues,\n                )}`;\n            case 'additionalProperties':\n                return `${errorPrefix} ${path} ${error.message} - ${stringify(\n                    error.params.additionalProperty,\n                )}`;\n            case 'const':\n                return `${errorPrefix} ${path} ${error.message} - ${stringify(\n                    error.params.allowedValue,\n                )}`;\n            case 'unevaluatedProperties':\n                return `${errorPrefix} ${path} ${error.message} - ${stringify(\n                    error.params.unevaluatedProperty,\n                )}`;\n            // Those errors are not informative at all\n            case 'not':\n            case 'oneOf':\n                return '';\n            default:\n                return `${errorPrefix} ${path} ${error.message}`;\n        }\n    }) ?? [];\n\n    return errors.filter((err) => err !== '');\n}\n","/*\n * Copyright (c) 2022-2023 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { BaseLayoutAlgorithm } from './baseEngine.js';\n\n/**\n * Default layout algorithm that puts all nodes into (0, 0) position\n */\nexport default class NoLayoutAlgorithm extends BaseLayoutAlgorithm {\n    /* eslint-disable class-methods-use-this */\n    availableAlgorithms = [\n        'NoLayout',\n    ];\n\n    activeAlgorithm = 'NoLayout';\n\n    calculate(graph) {\n        const nodes = graph.nodes.map((node) => ({\n            ...node,\n            position: { x: 0, y: 0 },\n        }));\n        return { ...graph, nodes };\n    }\n}\n","/*\n * Copyright (c) 2022-2024 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __awaiter } from \"tslib\";\nimport { nextTick } from 'vue';\nimport NotificationHandler from './notifications';\n/* eslint-disable import/prefer-default-export */\nconst getBackendApiUrl = () => {\n    // Override backend URL if requested\n    const urlParams = new URLSearchParams(window.location.search);\n    const url = urlParams.get('backend');\n    if (url !== null)\n        return url;\n    if (window.location.protocol === 'file:' ||\n        (process.env.VUE_APP_STATIC !== undefined && process.env.VUE_APP_STATIC === 'true'))\n        return null;\n    if (process.env.VUE_APP_COMMUNICATION_SERVER_HOST !== undefined &&\n        process.env.VUE_APP_COMMUNICATION_SERVER_PORT !== undefined)\n        return `http://${process.env.VUE_APP_COMMUNICATION_SERVER_HOST}:${process.env.VUE_APP_COMMUNICATION_SERVER_PORT}`;\n    // npm run serve\n    if (process.env.NODE_ENV === 'development')\n        return null;\n    return `${window.location.protocol}//${window.location.host}`;\n};\nexport const backendApiUrl = getBackendApiUrl();\nexport const HTTPCodes = {\n    OK: 200,\n    BadRequest: 400,\n    ServiceUnavailable: 503,\n};\nexport const PMMessageType = {\n    OK: 0,\n    ERROR: 1,\n    PROGRESS: 2,\n    WARNING: 3,\n};\nexport const JSONRPCCustomErrorCode = {\n    EXCEPTION_RAISED: -1,\n    EXTERNAL_APPLICATION_NOT_CONNECTED: -2,\n    NEWER_SESSION_AVAILABLE: -3,\n};\nexport const loadingScreen = (callback_1, loadEvent_1, ...args_1) => __awaiter(void 0, [callback_1, loadEvent_1, ...args_1], void 0, function* (\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ncallback, loadEvent, { show, log } = { show: true, log: true }) {\n    if (show) {\n        loadEvent.emit(true);\n        yield nextTick();\n    }\n    try {\n        yield callback();\n    }\n    catch (error) {\n        if (log) {\n            NotificationHandler.terminalLog('error', 'Unexpected error', error.message);\n        }\n    }\n    finally {\n        loadEvent.emit(false);\n        yield nextTick();\n    }\n});\n","/*\n * Copyright (c) 2022-2024 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { reactive } from 'vue';\n\nconst storageAvailable = (() => {\n    try {\n        const randomKey = Math.random().toString(36);\n        const randomValue = Math.random().toString(36);\n        localStorage.setItem(randomKey, randomValue);\n        localStorage.removeItem(randomKey);\n        return true;\n    } catch {\n        return false;\n    }\n})();\n\nconst pmStorage = new Map();\nconst get = (key) => {\n    if (storageAvailable) return localStorage.getItem(key);\n    return pmStorage.get(key) ?? null;\n};\n\nconst set = (key, value) => {\n    if (storageAvailable) localStorage.setItem(key, value);\n    else pmStorage.set(key, value);\n};\n\nconst remove = (key) => {\n    if (storageAvailable) localStorage.removeItem(key);\n    else pmStorage.delete(key);\n};\n\n/* eslint-disable import/prefer-default-export */\nexport const notificationStore = reactive({\n    notifications: JSON.parse(get('notifications')) || [],\n    add(notification) {\n        this.notifications.push(notification);\n\n        set('notifications', JSON.stringify(this.notifications));\n    },\n\n    remove() {\n        remove('notifications');\n        this.notifications = [];\n    },\n\n    removeOne(index) {\n        const newNotifications = this.notifications.filter((_, idx) => index !== idx);\n\n        set('notifications', JSON.stringify(newNotifications));\n        this.notifications = newNotifications;\n    },\n});\n\nexport const MAIN_TERMINAL = 'Terminal';\n\nexport const terminalStore = reactive({\n    // Object\n    logs: {\n        Terminal: JSON.parse(get(`logs`)) || [],\n    },\n    readOnly: {\n        Terminal: true,\n    },\n    add(log, instance = MAIN_TERMINAL) {\n        this.logs[instance].push(log);\n\n        // Update localStorage only for the main terminal\n        if (instance === MAIN_TERMINAL) {\n            set(`logs`, JSON.stringify(this.logs[instance]));\n        }\n    },\n    isReadOnly(instance = MAIN_TERMINAL) {\n        return this.readOnly[instance];\n    },\n\n    /**\n     * Adds a parsed notification. If there are messages, then it returns a following message:\n     *\n     * Title:\n     *     message_first_line\n     *     message_second_line\n     *     ...\n     *     message_last_line\n     *\n     * Otherwise, if messages are empty, then it returns a following message:\n     *\n     * Title.\n     *\n     * @param {string} title title of the message\n     * @param {Array[string] | string | undefined} messages messages of the message\n     */\n    addParsed(title, messages, instance = MAIN_TERMINAL) {\n        let parsedMessage = title;\n        if (messages) {\n            if (typeof messages === 'string' || messages instanceof String) {\n                messages = [messages]; // eslint-disable-line no-param-reassign\n            }\n            parsedMessage += ':';\n\n            messages.forEach((message) => {\n                parsedMessage += '\\n';\n                parsedMessage += '    ';\n                parsedMessage += message;\n            });\n        } else {\n            parsedMessage += '.';\n        }\n        this.add(parsedMessage, instance);\n    },\n\n    clear(instance = MAIN_TERMINAL) {\n        if (instance === MAIN_TERMINAL) {\n            remove(`logs`);\n        }\n        this.logs[instance] = [];\n    },\n\n    remove(instance = MAIN_TERMINAL) {\n        this.clear(instance);\n        delete this.logs[instance];\n        delete this.readOnly[instance];\n    },\n\n    exists(name = MAIN_TERMINAL) {\n        return name in this.logs;\n    },\n\n    getInstances() {\n        return Object.keys(this.logs);\n    },\n\n    /**\n     * Creates a new terminal instance.\n     * If such terminal already exisists, then false is returned.\n     *\n     * @param {string} Unique name of the terminal instance to be created.\n     * @param {boolean} If true, then the terminal instance will be only for read.\n     * @returns returns true if terminal was created, false otherwise.\n     */\n    createTerminalInstance(name, readOnly = true) {\n        if (Object.keys(this.logs).includes(name)) return false;\n\n        this.logs[name] = [];\n        this.readOnly[name] = readOnly;\n        return true;\n    },\n\n    show: false,\n\n    /**\n    * @type {import('./communication/utils').TerminalManager|null}\n    */\n    manager: null,\n});\n","/*\n * Copyright (c) 2025 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n *\n * Methods responsible for handling the configuration of custom nodes.\n * It allows to create, modify and to add properties and interfaces to the custom node.\n *\n * The current metadata of the custom node can be accessed in ConfigurationState.ts\n * and the current configuration can be accessed in the configurationState reactive object.\n*/\nimport { useViewModel } from '@baklavajs/renderer-vue';\nimport EditorManager, { NEW_NODE_STYLE, EDITED_NODE_STYLE } from '../EditorManager.js';\nimport { parseInterfaces } from '../interfaceParser.js';\nimport { configurationState, } from './ConfigurationState.ts';\nimport { createProperties, parseProperties, createBaklavaInterfaces, } from '../NodeFactory.js';\nimport NotificationHandler from '../notifications.js';\nimport { suppressHistoryLogging } from '../History.ts';\n/**\n  * Updates editor specification for the edited node type.\n*/\nfunction commitTypeToSpecification() {\n    suppressHistoryLogging(true);\n    const editorManager = EditorManager.getEditorManagerInstance();\n    const newNodeData = configurationState.nodeData;\n    const currentType = configurationState.editedType;\n    let style = NEW_NODE_STYLE;\n    if (currentType !== undefined) {\n        // eslint-disable-next-line no-underscore-dangle\n        const errors = editorManager._unregisterNodeType(currentType);\n        if (errors.length) {\n            NotificationHandler.terminalLog('error', 'Error when registering the node', errors);\n            return;\n        }\n        style = EDITED_NODE_STYLE;\n    }\n    const ret = editorManager.addNodeToEditorSpecification({\n        name: newNodeData.name,\n        layer: newNodeData.layer,\n        category: newNodeData.category,\n        color: newNodeData.color,\n        description: newNodeData.description,\n        interfaces: configurationState.interfaces,\n        properties: configurationState.properties,\n        style,\n    }, currentType, false);\n    if (ret.errors !== undefined && ret.errors.length) {\n        NotificationHandler.terminalLog('error', 'Error when registering the node', ret.errors);\n        return;\n    }\n    suppressHistoryLogging(false);\n}\n/**\n  * Finds all nodes of a given type in all editor graphs.\n  * @param nodeType - type of the node to find\n  * @param extending - find extending nodes\n  * @returns any[] - an array of nodes\n*/\nexport function findNodes(nodeType, extending = false) {\n    const { viewModel } = useViewModel();\n    const { editor } = viewModel.value;\n    const allNodes = Array.from(editor.graphs).map((graph) => graph.nodes).flat();\n    if (extending)\n        return allNodes.filter((n) => { var _a; return (_a = n.extends) === null || _a === void 0 ? void 0 : _a.includes(nodeType); });\n    return allNodes.filter((n) => n.type === nodeType);\n}\n/**\n  * Creates a new node based on the current configuration.\n  * It first validates the configuration and if it is correct, it adjusts the existing nodes\n  * to the new configuration and creates a new node if `configurationMenu.addNode`\n  * is set to true. If the configuration is incorrect, it logs an error.\n  * @returns string[] - an array of errors that occurred during node creation\n*/\nexport function createNode() {\n    const editorManager = EditorManager.getEditorManagerInstance();\n    const newNodeData = configurationState.nodeData;\n    const currentType = configurationState.editedType;\n    // Checking if there is there already exists newNodeData.name type and is different\n    // than the current node that is being created\n    if (editorManager.baklavaView.editor.nodeTypes.has(newNodeData.name) && (currentType === undefined ||\n        currentType !== newNodeData.name)) {\n        const errors = [`Node of type ${newNodeData.name} already exists. Please pick another type`];\n        NotificationHandler.terminalLog('error', 'Error when creating a node', errors);\n        return errors;\n    }\n    commitTypeToSpecification();\n    return [];\n}\n/**\n  * Modifies the configuration of the custom node.\n  * It first validates the configuration and if it is correct, it adjusts the existing nodes\n  * to the new configuration. If the configuration is incorrect, it logs an error.\n  * @returns string[] - an array of errors that occurred during the modification\n*/\nexport function modifyConfiguration() {\n    suppressHistoryLogging(true);\n    const newNodeData = configurationState.nodeData;\n    const currentType = configurationState.editedType;\n    const nodes = findNodes(currentType);\n    /* eslint-disable no-param-reassign */\n    nodes.forEach((node) => {\n        if (node.type === node.title) {\n            node.title = newNodeData.name;\n        }\n        else {\n            node.highlightedType = newNodeData.name;\n        }\n        node.type = newNodeData.name;\n        node.layer = newNodeData.layer;\n        node.category = newNodeData.category;\n        node.color = newNodeData.color;\n        node.description = newNodeData.description;\n    });\n    /* eslint-enable no-param-reassign */\n    commitTypeToSpecification();\n    suppressHistoryLogging(false);\n    return [];\n}\n/**\n  * Adds or removes node properties.\n  * @param nodes - list of nodes\n  * @param properties - list of properties\n  * @param remove - whether properties should be removed\n  * @returns void\n*/\nexport function alterProperties(nodes, properties, remove = false) {\n    if (properties === undefined)\n        return [];\n    let errors = [];\n    const parsedProperties = parseProperties(properties);\n    // If parsedProperties returns an array, it is an array of errors\n    if (Array.isArray(parsedProperties) && parsedProperties.length) {\n        return parsedProperties;\n    }\n    const createdProperties = createProperties(parsedProperties);\n    nodes.forEach((node) => {\n        const state = node.save();\n        Object.keys(createdProperties).forEach((k) => {\n            const input = createdProperties[k]();\n            if (remove) {\n                node.removeInput(k, input);\n            }\n            else {\n                node.addInput(k, input);\n            }\n            // Because `this` is not reactive in node functions, we need\n            // to notice the reactive `node` reference inputs were updated\n            node.inputs = node.inputs; // eslint-disable-line no-self-assign, no-param-reassign\n        });\n        const loadErrors = node.load(state);\n        errors = [...errors, ...loadErrors];\n    });\n    return errors;\n}\n/**\n  * Adds or removes node interfaces.\n  * @param nodes - list of nodes\n  * @param interfaces - list of interfaces\n  * @param remove - whether interfaces should be removed\n  * @returns void\n*/\nexport function alterInterfaces(nodes, interfaces, remove = false) {\n    if (interfaces === undefined)\n        return [];\n    let errors = [];\n    const parsedInterfaces = parseInterfaces(interfaces, [], []);\n    // If parsedInterfaces returns an array, it is an array of errors\n    if (Array.isArray(parsedInterfaces) && parsedInterfaces.length) {\n        return parsedInterfaces;\n    }\n    const [inputs, outputs] = createBaklavaInterfaces(parsedInterfaces);\n    nodes.forEach((node) => {\n        const state = node.save();\n        Object.keys(inputs).forEach((k) => {\n            const input = inputs[k]();\n            if (remove) {\n                node.removeInput(k, input);\n            }\n            else {\n                node.addInput(k, input);\n            }\n            node.inputs = node.inputs; // eslint-disable-line no-self-assign, no-param-reassign\n        });\n        Object.keys(outputs).forEach((k) => {\n            const output = outputs[k]();\n            if (remove) {\n                node.removeOutput(k, output);\n            }\n            else {\n                node.addOutput(k, output);\n            }\n            node.outputs = node.outputs; // eslint-disable-line no-self-assign, no-param-reassign, max-len\n        });\n        const loadErrors = node.load(state);\n        errors = [...errors, ...loadErrors];\n    });\n    return errors;\n}\n/**\n  * Adds property to the custom node. If the property is invalid, it logs an error.\n  * @param property - the property to be added\n  * @returns void\n*/\nexport function addProperty(property) {\n    var _a;\n    const currentType = configurationState.editedType;\n    const editorManager = EditorManager.getEditorManagerInstance();\n    let error = editorManager.validateNodeProperty(property);\n    if (error.length) {\n        NotificationHandler.terminalLog('error', 'Invalid property', error);\n        return;\n    }\n    const nodes = findNodes(currentType);\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    if (nodes === undefined) {\n        NotificationHandler.terminalLog('error', 'Node not found', `Node of type ${currentType} not found`);\n        return;\n    }\n    configurationState.properties.push(property);\n    error = alterProperties(nodes, configurationState.properties);\n    if (error.length) {\n        NotificationHandler.terminalLog('error', 'Invalid property', error);\n        return;\n    }\n    const resolvedChildNodes = (_a = editorManager.specification.currentSpecification.nodes\n        .filter((n) => { var _a; return (_a = n.extends) === null || _a === void 0 ? void 0 : _a.includes(currentType); })) !== null && _a !== void 0 ? _a : [];\n    resolvedChildNodes.forEach((n) => {\n        var _a;\n        // eslint-disable-next-line no-param-reassign\n        n.properties = [...((_a = n.properties) !== null && _a !== void 0 ? _a : []), ...[property]];\n        const childNodes = findNodes(n.name);\n        alterProperties(childNodes, [property]);\n    });\n    commitTypeToSpecification();\n}\n/**\n  * Removes properties from the custom node.\n  * @param properties - the properties to be removed\n  * @returns void\n*/\nexport function removeProperties(properties) {\n    var _a, _b, _c, _d, _e;\n    const currentType = configurationState.editedType;\n    const editorManager = EditorManager.getEditorManagerInstance();\n    const nodes = findNodes(currentType);\n    if (nodes === undefined) {\n        NotificationHandler.terminalLog('error', 'Node not found', `Node of type ${currentType} not found`);\n        return;\n    }\n    configurationState.properties = configurationState.properties.filter((item) => !properties.includes(item));\n    alterProperties(nodes, properties, true);\n    const resolvedChildNodes = (_a = editorManager.specification.currentSpecification.nodes\n        .filter((n) => { var _a; return (_a = n.extends) === null || _a === void 0 ? void 0 : _a.includes(currentType); })) !== null && _a !== void 0 ? _a : [];\n    resolvedChildNodes.forEach((n) => {\n        var _a, _b;\n        // eslint-disable-next-line no-param-reassign\n        n.properties = (_b = (_a = n.properties) === null || _a === void 0 ? void 0 : _a.filter((prop) => !properties.some((p) => p.name === prop.name))) !== null && _b !== void 0 ? _b : [];\n        const childNodes = findNodes(n.name);\n        alterProperties(childNodes, properties, true);\n    });\n    function removeFromSubgraph(graph, nodesToUpdate, names) {\n        const externalNames = [];\n        nodesToUpdate.forEach((node) => {\n            const propertiesToRemove = node.properties\n                .filter((prop) => names.includes(prop.name));\n            // eslint-disable-next-line no-param-reassign\n            node.properties = node.properties\n                .filter((prop) => !propertiesToRemove.includes(prop));\n            externalNames.push(...propertiesToRemove\n                .map((prop) => prop.externalName)\n                .filter((name) => name));\n        });\n        return externalNames;\n    }\n    const names = properties.map((prop) => prop.name);\n    [\n        ...(_b = editorManager.specification.unresolvedSpecification.graphs) !== null && _b !== void 0 ? _b : [],\n        ...(_c = editorManager.specification.currentSpecification.graphs) !== null && _c !== void 0 ? _c : [],\n    ].forEach((graph) => {\n        const nodesToUpdate = graph.nodes.filter((n) => n.name === currentType);\n        let externalNames = removeFromSubgraph(graph, nodesToUpdate, names);\n        while (externalNames.length > 0) {\n            const newExternalNames = removeFromSubgraph(graph, graph.nodes, externalNames);\n            externalNames = newExternalNames;\n        }\n    });\n    [\n        ...(_d = editorManager.specification.unresolvedSpecification.nodes) !== null && _d !== void 0 ? _d : [],\n        ...(_e = editorManager.specification.currentSpecification.nodes) !== null && _e !== void 0 ? _e : [],\n    ].forEach((node) => {\n        editorManager.refreshSubgraph(node);\n    });\n    commitTypeToSpecification();\n}\n/**\n  * Adds interface to the custom node. If the interface is invalid, it logs an error.\n  * @param intf - the interface to be added\n  * @returns void\n*/\nexport function addInterface(intf) {\n    var _a;\n    const currentType = configurationState.editedType;\n    const editorManager = EditorManager.getEditorManagerInstance();\n    let error = editorManager.validateNodeInterface(intf);\n    if (error.length) {\n        NotificationHandler.terminalLog('error', 'Invalid interface', error);\n        return;\n    }\n    const nodes = findNodes(currentType);\n    if (nodes === undefined) {\n        NotificationHandler.terminalLog('error', 'Node not found', `Node of type ${currentType} not found`);\n        return;\n    }\n    configurationState.interfaces.push(intf);\n    error = alterInterfaces(nodes, configurationState.interfaces);\n    if (error.length) {\n        NotificationHandler.terminalLog('error', 'Invalid interface', error);\n        return;\n    }\n    const resolvedChildNodes = (_a = editorManager.specification.currentSpecification.nodes\n        .filter((n) => { var _a; return (_a = n.extends) === null || _a === void 0 ? void 0 : _a.includes(currentType); })) !== null && _a !== void 0 ? _a : [];\n    resolvedChildNodes.forEach((n) => {\n        var _a;\n        // eslint-disable-next-line no-param-reassign\n        n.interfaces = [...((_a = n.interfaces) !== null && _a !== void 0 ? _a : []), ...[intf]];\n        const childNodes = findNodes(n.name);\n        alterInterfaces(childNodes, [intf]);\n    });\n    commitTypeToSpecification();\n}\n/**\n  * Removes interfaces from the custom node.\n  * @param interfaces - the interfaces to be removed\n  * @returns void\n*/\nexport function removeInterfaces(interfaces) {\n    var _a, _b, _c, _d, _e;\n    const currentType = configurationState.editedType;\n    const editorManager = EditorManager.getEditorManagerInstance();\n    const nodes = findNodes(currentType);\n    if (nodes === undefined) {\n        NotificationHandler.terminalLog('error', 'Node not found', `Node of type ${currentType} not found`);\n        return;\n    }\n    // Remove interfaces from graphs in the editor\n    configurationState.interfaces = configurationState.interfaces.filter((item) => !interfaces.includes(item));\n    alterInterfaces(nodes, interfaces, true);\n    const resolvedChildNodes = (_a = editorManager.specification.currentSpecification.nodes\n        .filter((n) => { var _a; return (_a = n.extends) === null || _a === void 0 ? void 0 : _a.includes(currentType); })) !== null && _a !== void 0 ? _a : [];\n    resolvedChildNodes.forEach((n) => {\n        var _a, _b;\n        // eslint-disable-next-line no-param-reassign\n        n.interfaces = (_b = (_a = n.interfaces) === null || _a === void 0 ? void 0 : _a.filter((intf) => !interfaces.some((i) => i.name === intf.name))) !== null && _b !== void 0 ? _b : [];\n        const childNodes = findNodes(n.name);\n        alterInterfaces(childNodes, interfaces, true);\n    });\n    // Remove interfaces from uninitialized graphs\n    function removeFromSubgraph(graph, nodesToUpdate, names) {\n        const externalNames = [];\n        nodesToUpdate.forEach((node) => {\n            const interfacesToRemove = node.interfaces\n                .filter((intf) => names.includes(intf.name));\n            const ids = interfacesToRemove.map((intf) => intf.id);\n            // eslint-disable-next-line no-param-reassign\n            graph.connections = graph.connections\n                .filter((conn) => !ids.includes(conn.from) && !ids.includes(conn.to));\n            // eslint-disable-next-line no-param-reassign\n            node.interfaces = node.interfaces.filter((intf) => !ids.includes(intf.id));\n            externalNames.push(...interfacesToRemove\n                .map((intf) => intf.externalName)\n                .filter((name) => name));\n        });\n        return externalNames;\n    }\n    const names = interfaces.map((intf) => intf.name);\n    [\n        ...(_b = editorManager.specification.unresolvedSpecification.graphs) !== null && _b !== void 0 ? _b : [],\n        ...(_c = editorManager.specification.currentSpecification.graphs) !== null && _c !== void 0 ? _c : [],\n    ].forEach((graph) => {\n        const nodesToUpdate = graph.nodes.filter((n) => n.name === currentType);\n        let externalNames = removeFromSubgraph(graph, nodesToUpdate, names);\n        while (externalNames.length > 0) {\n            const newExternalNames = removeFromSubgraph(graph, graph.nodes, externalNames);\n            externalNames = newExternalNames;\n        }\n    });\n    [\n        ...(_d = editorManager.specification.unresolvedSpecification.nodes) !== null && _d !== void 0 ? _d : [],\n        ...(_e = editorManager.specification.currentSpecification.nodes) !== null && _e !== void 0 ? _e : [],\n    ].forEach((node) => {\n        editorManager.refreshSubgraph(node);\n    });\n    commitTypeToSpecification();\n}\n","/*\n * Copyright (c) 2022-2023 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/* eslint-disable max-classes-per-file */\n/**\n * Base class allowing to define autolayout algorithms. Each engine\n * can specify multiple algorithms, names in `availableAlgorithms` array.\n * Currently chosen algorithm is named in `activeAlgorithm`\n */\nexport default class BaseLayoutEngine {\n    availableAlgorithms = [];\n\n    // Base layout is an abstract class\n    constructor() {\n        if (this.constructor === BaseLayoutEngine) {\n            throw new Error(\"Can't initialize base class instance\"); // eslint-disable-line quotes\n        }\n    }\n\n    chooseAlgorithm(algorithm) {\n        if (!this.availableAlgorithms.includes(algorithm)) {\n            throw new Error(\n                `Could not find ${algorithm} in ${this.constructor.name} engine.\n                Available algorithms: ${this.availableAlgorithms}`,\n            );\n        }\n        this.activeAlgorithm = algorithm;\n    }\n\n    /* eslint-disable class-methods-use-this */\n    /* eslint-disable no-unused-vars */\n    async calculate(graph) {\n        throw new Error('Method calculate() must be implemented by layout engine');\n    }\n}\n\n/**\n * Instance of engine with only single algorithm\n */\nexport class BaseLayoutAlgorithm extends BaseLayoutEngine {\n    constructor() {\n        super();\n        this.availableAlgorithms = [this.constructor.name];\n        this.activeAlgorithm = this.constructor.name;\n        this.chooseAlgorithm = undefined; // turn of choosing algorithm\n        if (this.constructor === BaseLayoutAlgorithm) {\n            throw new Error(\"Can't initialize base class instance\"); // eslint-disable-line quotes\n        }\n    }\n}\n","/*\n * Copyright (c) 2022-2024 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Helper function that can be used to handle double clicks.\n *\n * @param {number} timer time window in which a callback can be fired\n * @param {function} callback event fired on double click\n * @returns event that should be applied to @pointerdown\n */\nexport default function doubleClick(timer, callback) {\n    const doubleClickTimer = timer;\n    let lastClickTime = -doubleClickTimer;\n\n    /* eslint-disable vue/no-mutating-props,no-param-reassign */\n    const onMouseDown = (ev) => {\n        if (Date.now() - lastClickTime < doubleClickTimer) {\n            callback(ev);\n        }\n        lastClickTime = Date.now();\n    };\n\n    return onMouseDown;\n}\n","/*\n * Copyright (c) 2022-2023 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { useGraph } from '@baklavajs/renderer-vue';\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Function for calculating node position based on given movementStep.\n *\n * @param movementStep Vue's reference to value containing snap offset\n */\nexport function gridSnapper(movementStep) {\n    const calculateSnappedPosition = (coord) => Math.round(coord / movementStep.value) * movementStep.value;\n    return calculateSnappedPosition;\n}\n/**\n * Creates function that aligns the value of node position along specified axis if it is close\n * enough to other node position\n *\n * @param kind Either 'x' or 'y', defines along which axis the coordinate is aligned\n */\nexport function nodeSnapper(kind) {\n    const { graph } = useGraph();\n    const snapDistance = 100;\n    const calculateSnappedPosition = (coord, nodeId, selectedNodesIds) => {\n        const nearestCoords = graph.value.nodes\n            // any definition is an ad-hoc solution as we don't have our node definition\n            .filter((node) => node.id !== nodeId && !selectedNodesIds.includes(node.id))\n            .map((node) => node.position[kind])\n            .filter((otherCoords) => Math.abs(coord - otherCoords) < snapDistance);\n        return nearestCoords.length !== 0 ? Math.min(...nearestCoords) : undefined;\n    };\n    return calculateSnappedPosition;\n}\n","import { terminalStore } from '../stores';\nexport function checkTerminalExistence(name, exists = true) {\n    if (terminalStore.exists(name) !== exists) {\n        const message = `Terminal instance of name '${name} ${exists ? 'does not exist' : 'already exists'}`;\n        throw new Error(message);\n    }\n}\n","/*\n * Copyright (c) 2022-2024 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __awaiter } from \"tslib\";\n/*\n * This module contains all possible JSON-RPC requests that frontend can\n * receive and process.\n *\n * Each exported function is automatically registered as JSON-RPC method\n * when JSON-RPC server is created in fetchRequest.\n * Function name have to match with specification (resources/api_specification).\n */\nimport { useViewModel } from '@baklavajs/renderer-vue';\nimport { v4 as uuidv4 } from 'uuid';\nimport runInfo from './runInformation';\nimport EditorManager from '../EditorManager';\nimport NotificationHandler from '../notifications';\nimport { MAIN_TERMINAL, terminalStore } from '../stores';\nimport { saveSpecificationConfiguration } from '../../components/saveConfiguration.ts';\n// eslint-disable-next-line import/no-cycle\nimport getExternalApplicationManager from './ExternalApplicationManager';\nimport { checkTerminalExistence } from './utils';\nimport { prepareSubgraphInstance } from '../../custom/CustomGraphNode';\n/* eslint-disable import/prefer-default-export */\n/* eslint-disable camelcase */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst editorManager = EditorManager.getEditorManagerInstance();\n/**\n * Finds graph of id `graph_id`.\n * An error with appropriate message is thrown if any error occurs.\n *\n * @param graph_id Id of a graph to find\n * @returns found graph\n */\nfunction getGraph(graph_id) {\n    const { viewModel } = useViewModel();\n    const graph = [...viewModel.value.editor.graphs].find((g) => g.id === graph_id);\n    if (graph === undefined) {\n        throw new Error(`Graph with id '${graph_id}' does not exist.`);\n    }\n    return graph;\n}\n/**\n * Finds node of id `node_id` in graph of id `graph_id`.\n * An error with appropriate message is thrown if any error occurs.\n *\n * @param graph_id Id of a graph to find\n * @param node_id Id of a node to find\n * @returns found node\n */\nfunction getNode(graph_id, node_id) {\n    const graph = getGraph(graph_id);\n    const node = graph.nodes.find((n) => n.id === node_id);\n    if (node === undefined) {\n        throw new Error(`Node with id '${node_id}' does not exist.`);\n    }\n    return node;\n}\n/**\n * Finds property of id `id` or name `name` in node.\n * One of those values has to be defined.\n * An error with appropriate message is thrown if any error occurs.\n *\n * @param node Node instance that is searched\n * @param id id of the property\n * @param name name of the property\n * @returns found property\n */\nfunction getProperty(node, id, name) {\n    let prop;\n    if (id !== undefined) {\n        prop = Object.values(node.inputs).find((p) => p.id === id);\n        // If not property found or it is not a property, but an interface\n        if (prop === undefined || prop.side !== undefined) {\n            throw new Error(`Property with id '${id}' does not exist.`);\n        }\n    }\n    else {\n        prop = Object.values(node.inputs).find((p) => p.name === name);\n        // If not property found or it is not a property, but an interface\n        if (prop === undefined || prop.side !== undefined) {\n            throw new Error(`Property with name '${name}' does not exist.`);\n        }\n    }\n    return prop;\n}\n/**\n * Finds connection between interfaces with id `from` and `to` in graph of id `graph_id`.\n * An error with appropriate message is thrown if any error occurs.\n *\n * @param graph_id Id of a graph to find\n * @param from Id of a first interface\n * @param to Id of a second interface\n * @returns found node\n */\nfunction getConnection(graph_id, from, to) {\n    const graph = getGraph(graph_id);\n    const connection = graph.connections.find((c) => c.from.id === from && c.to.id === to);\n    if (connection === undefined) {\n        throw new Error(`Connection from ${from} to ${to} does not exist.`);\n    }\n    return connection;\n}\n/**\n * @returns status of the frontend\n */\nexport function frontend_status_get() {\n    return { status: 'ready' };\n}\n/**\n * @returns currently used specification\n */\nexport function frontend_specification_get(params) {\n    const saveConfiguration = saveSpecificationConfiguration;\n    saveConfiguration.graph = params ? params.graph : false;\n    saveConfiguration.minify = params ? params.minify : false;\n    return { specification: saveConfiguration.getSave() };\n}\n/**\n * @returns currently used dataflow\n */\nexport function graph_get() {\n    return {\n        dataflow: editorManager.saveDataflow(),\n    };\n}\n/**\n * Updates values of properties specified in `params`.\n * An error with appropriate message is thrown if any error occurs.\n */\nexport function properties_change(params) {\n    const node = getNode(params.graph_id, params.node_id);\n    // First iteration to validate that every property exists\n    // eslint-disable-next-line no-restricted-syntax\n    for (const property of params.properties) {\n        getProperty(node, property.id, property.name);\n    }\n    // Second iteration to actually alter the values\n    // eslint-disable-next-line no-restricted-syntax\n    for (const property of params.properties) {\n        const prop = getProperty(node, property.id, property.name);\n        prop.value = property.new_value;\n    }\n}\n/**\n * Updates values of properties specified in `params`.\n * An error with appropriate message is thrown if any error occurs.\n */\nexport function position_change(params) {\n    const node = getNode(params.graph_id, params.node_id);\n    node.position.x = params.position.x;\n    node.position.y = params.position.y;\n}\n/**\n * Creates and deletes nodes based on received `params`.\n */\nexport function nodes_change(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const { viewModel } = useViewModel();\n        const graph = getGraph(params.graph_id);\n        params.nodes.added.forEach((n) => {\n            const info = viewModel.value.editor.nodeTypes.get(n.name);\n            if (!info) {\n                throw new Error(`Node type not found for name ${n.name}`);\n            }\n            else {\n                const node = new info.type(); // eslint-disable-line new-cap\n                node.id = n.id;\n                if (n.color) {\n                    const editor = viewModel.value.editor;\n                    editor.setNodeColor(n.id, n.color);\n                }\n                graph.addNode(node);\n                const errors = node.load(n);\n                if (Array.isArray(errors) && errors.length)\n                    throw new Error(errors.join('\\n'));\n            }\n        });\n        params.nodes.deleted.forEach((n) => {\n            var _a;\n            const node = getNode(params.graph_id, n);\n            if ((_a = params.remove_with_connections) !== null && _a !== void 0 ? _a : true) {\n                graph.removeNode(node);\n            }\n            else {\n                graph.removeNodeOnly(node);\n            }\n        });\n    });\n}\n/**\n * Creates and deletes connections based on received `params`.\n */\nexport function connections_change(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const graph = getGraph(params.graph_id);\n        params.connections.added.forEach((c) => {\n            const fromIntf = graph.findNodeInterface(c.from);\n            if (!fromIntf)\n                throw new Error(`Interface with id ${c.from} does not exist`);\n            const toIntf = graph.findNodeInterface(c.to);\n            if (!toIntf)\n                throw new Error(`Interface with id ${c.to} does not exist`);\n            const connection = graph.addConnection(fromIntf, toIntf);\n            if (!connection)\n                throw new Error(`Connection from ${c.from} to ${c.to} cannot be created`);\n        });\n        params.connections.deleted.forEach((c) => {\n            graph.removeConnection(getConnection(params.graph_id, c.from, c.to));\n        });\n    });\n}\n/**\n * Loads received dataflow.\n */\nexport function graph_change(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const externalApplicationManager = getExternalApplicationManager();\n        yield externalApplicationManager.conditionalLoadingScreen(params.loadingScreen, () => __awaiter(this, void 0, void 0, function* () { return externalApplicationManager.updateDataflow(params.dataflow); }));\n    });\n}\n/**\n * Returns an array of properties specified in `params`.\n * An error with appropriate message is thrown if any error occurs.\n */\nexport function properties_get(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const node = getNode(params.graph_id, params.node_id);\n        const properties = [];\n        if (params.properties === undefined) {\n            // eslint-disable-next-line no-restricted-syntax\n            for (const property of Object.values(node.inputs)) {\n                if (property.side === undefined) {\n                    properties.push({\n                        id: property.id,\n                        name: property.name,\n                        value: property.value,\n                    });\n                }\n            }\n            return properties;\n        }\n        // eslint-disable-next-line no-restricted-syntax\n        for (const property of params.properties) {\n            const prop = getProperty(node, property.id, property.name);\n            properties.push({\n                id: prop.id,\n                name: prop.name,\n                value: prop.value,\n            });\n        }\n        return properties;\n    });\n}\n/**\n * Returns a serialized node state specified in `params`.\n * An error with appropriate message is thrown if any error occurs.\n */\nexport function node_get(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const node = getNode(params.graph_id, params.node_id);\n        return {\n            node: node.save(),\n        };\n    });\n}\n/**\n * Sets width of progress bar.\n * If there is not run in progress, throws error.\n */\nexport function progress_change(params) {\n    const procedureInfo = runInfo.get(params.method);\n    if (!procedureInfo.inProgress) {\n        throw new Error('No run in progress');\n    }\n    if (!procedureInfo.progressBar)\n        throw new Error(`Progress bar does not exist for method: ${params.method}`);\n    if (params.progress === -1) {\n        procedureInfo.progressBar.classList.add('animate');\n        return;\n    }\n    if (params.progress > 100 || params.progress < 0)\n        throw new Error(`Progress has to be in [0, 100] or -1. Received: ${params.progress}`);\n    procedureInfo.progressBar.style.width = `${params.progress}%`;\n    procedureInfo.progressBar.classList.remove('animate');\n}\n/**\n * Updates the editor's metadata.\n */\nexport function metadata_change(params) {\n    editorManager.updateMetadata(params.metadata, true);\n}\n/**\n * Triggers action centering the editor.\n */\nexport function viewport_center() {\n    editorManager.baklavaView.editor.centerZoom();\n}\n/**\n * Creates new terminal instance\n */\nexport function terminal_add(params) {\n    const status = terminalStore.createTerminalInstance(params.name, params.readonly);\n    if (status === false) {\n        throw new Error(`Terminal instance of name '${params.name}' already exists`);\n    }\n}\nexport function terminal_remove(params) {\n    checkTerminalExistence(params.name, true);\n    terminalStore.remove(params.name);\n}\n/**\n * Writes a single message to a chosen terminal\n */\nexport function terminal_write(params) {\n    if (!(params.name in terminalStore.logs)) {\n        terminalStore.createTerminalInstance(params.name);\n    }\n    terminalStore.add(params.message, params.name);\n}\nexport function terminal_clear(params) {\n    var _a;\n    const name = (_a = params === null || params === void 0 ? void 0 : params.name) !== null && _a !== void 0 ? _a : MAIN_TERMINAL;\n    checkTerminalExistence(name, true);\n    terminalStore.clear(name);\n}\nexport function terminal_hide() {\n    var _a;\n    (_a = terminalStore.manager) === null || _a === void 0 ? void 0 : _a.hide();\n}\nexport function terminal_show(params) {\n    var _a, _b;\n    const name = (_a = params === null || params === void 0 ? void 0 : params.name) !== null && _a !== void 0 ? _a : MAIN_TERMINAL;\n    if (name !== undefined)\n        checkTerminalExistence(name, true);\n    (_b = terminalStore.manager) === null || _b === void 0 ? void 0 : _b.show(name);\n}\nexport function terminal_view(params) {\n    var _a, _b;\n    (_a = params.names) === null || _a === void 0 ? void 0 : _a.forEach(((name) => checkTerminalExistence(name, true)));\n    (_b = terminalStore.manager) === null || _b === void 0 ? void 0 : _b.view(params);\n}\nexport function terminal_get_instances() {\n    return terminalStore.getInstances();\n}\nexport function notification_send(params) {\n    NotificationHandler.terminalLog(params.type, params.title, params.details);\n}\nexport function specification_change(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const externalApplicationManager = getExternalApplicationManager();\n        yield externalApplicationManager.conditionalLoadingScreen(params.loadingScreen, () => __awaiter(this, void 0, void 0, function* () { return externalApplicationManager.updateSpecification(params.specification, params); }));\n    });\n}\nexport function specification_graph_change(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const externalApplicationManager = getExternalApplicationManager();\n        const tryMinify = params.tryMinify ? params.dataflow : undefined;\n        yield externalApplicationManager.conditionalLoadingScreen(params.loadingScreen, () => __awaiter(this, void 0, void 0, function* () {\n            const error = yield externalApplicationManager.updateSpecification(params.specification, Object.assign(Object.assign({}, params), { tryMinify }));\n            if (!error) {\n                yield externalApplicationManager.updateDataflow(params.dataflow);\n            }\n        }));\n    });\n}\nexport function specification_preprocess(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const externalApplicationManager = getExternalApplicationManager();\n        const tryMinify = params.tryMinify ? params.dataflow : undefined;\n        const resolveSpecification = yield externalApplicationManager.preprocessSpecification(params.specification, Object.assign(Object.assign({}, params), { tryMinify }));\n        return resolveSpecification ? { specification: resolveSpecification } : undefined;\n    });\n}\nexport function specification_expand(_a) {\n    return __awaiter(this, arguments, void 0, function* ({ specification }) {\n        var _b;\n        const assertNoErrors = (errors) => {\n            if (errors.length > 0) {\n                throw new Error(errors.join('\\n'));\n            }\n        };\n        // Validate\n        const validationErrors = EditorManager.validateSpecification(specification);\n        assertNoErrors(validationErrors);\n        // Collect specification data\n        const specGraphs = (_b = specification.graphs) !== null && _b !== void 0 ? _b : [];\n        const specGraphMap = new Map(specGraphs.map((graph) => [graph.id, structuredClone(graph)]));\n        const subgraphIds = specification.nodes\n            .map((node) => node.subgraphId)\n            .filter(Boolean);\n        // Initialize loop data\n        const isNotSubgraph = (graph) => !subgraphIds.includes(graph.id);\n        const finalGraphs = specGraphs.filter(isNotSubgraph);\n        const processingQueue = subgraphIds.map((id) => ({\n            subgraphId: id,\n            instanceId: id,\n        }));\n        while (processingQueue.length) {\n            const { subgraphId, instanceId } = processingQueue.shift();\n            // Prepare graph\n            const graph = specGraphMap.get(subgraphId);\n            const { state, errors } = prepareSubgraphInstance(graph, { mode: 'spec' });\n            assertNoErrors(errors);\n            // Add nested graphs to the queue\n            state.nodes\n                .filter((node) => node.subgraph && subgraphIds.includes(node.subgraph))\n                .forEach((node) => {\n                const nestedSubgraphId = node.subgraph;\n                const nestedInstanceId = uuidv4();\n                node.subgraph = nestedInstanceId; // eslint-disable-line no-param-reassign\n                processingQueue.push({\n                    subgraphId: nestedSubgraphId,\n                    instanceId: nestedInstanceId,\n                });\n            });\n            // Save graph\n            delete state.graphLoadingState;\n            finalGraphs.push(Object.assign(Object.assign({}, state), { id: instanceId }));\n        }\n        return {\n            specification: Object.assign(Object.assign({}, specification), { graphs: finalGraphs }),\n        };\n    });\n}\n/**\n * Highlights nodes provided in params\n */\nexport function nodes_highlight(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const graph = getGraph(params.graph_id);\n        graph.selectedNodes = graph.selectedNodes.filter((node) => !params.nodes.unselected.includes(node.id));\n        params.nodes.selected.forEach((node_id) => {\n            const node = getNode(params.graph_id, node_id);\n            if (!graph.selectedNodes.includes(node)) {\n                graph.selectedNodes.push(node);\n            }\n        });\n    });\n}\nexport function register_external_frontend() {\n    throw new Error('Frontend registering available only through \"postMessage\" interface.');\n}\nexport function return_from_subgraph() {\n    const isInSubgraph = editorManager.isInSubgraph();\n    if (isInSubgraph) {\n        editorManager.returnFromSubgraph();\n    }\n    return { has_returned: isInSubgraph };\n}\n","/*\n * Copyright (c) 2022-2024 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __awaiter } from \"tslib\";\n// eslint-disable-next-line max-classes-per-file\nimport { JSONRPCServerAndClient, JSONRPCServer, JSONRPCClient, createJSONRPCErrorResponse, } from 'json-rpc-2.0';\nimport Ajv2019 from 'ajv/dist/2019.js';\nimport NotificationHandler from '../notifications';\nimport { PMMessageType } from '../utils';\nimport commonTypesSchema from '../../../../resources/api_specification/common_types.json' with { type: 'json' };\nimport specificationSchema from '../../../../resources/api_specification/specification.json' with { type: 'json' };\n// eslint-disable-next-line import/no-cycle\nimport * as remoteProcedures from './remoteProcedures';\nimport validateJSON from '../validate-json';\nclass CustomJSONRPCServerAndClient extends JSONRPCServerAndClient {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"customMethodRegex\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: null\n        });\n        Object.defineProperty(this, \"customMethodReplace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: null\n        });\n    }\n}\nexport class RPCError extends Error {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    constructor(message, data) {\n        super(message);\n        Object.defineProperty(this, \"data\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: data\n        });\n    }\n}\nconst customMethodRegex = /^custom_.*$/;\nconst customMethodReplace = 'dataflow_run';\nconst ajv = new Ajv2019({\n    schemas: [commonTypesSchema],\n    allowUnionTypes: true,\n    strict: true,\n});\n/**\n * Loads endpoints schemas and assigns $id according to a corresponding key.\n *\n * @param group - Name of the endpoints group;\n * @returns Loaded endpoints.\n */\nfunction loadEndpoints(group) {\n    const endpoints = specificationSchema[group];\n    Object.entries(endpoints).forEach(([key, value]) => {\n        const typedValue = value;\n        if (typedValue.params)\n            typedValue.params.$id = `${key}_params`;\n        if (typedValue.returns)\n            typedValue.returns.$id = `${key}_returns`;\n    });\n    return endpoints;\n}\nexport const frontendEndpoints = loadEndpoints('frontend_endpoints');\nexport const backendEndpoints = loadEndpoints('backend_endpoints');\nexport const externalEndpoints = loadEndpoints('external_endpoints');\n// This should become part of the testing suite at some point\nlet invalidDefinition;\ntry {\n    [frontendEndpoints, backendEndpoints, externalEndpoints].forEach((endpoints) => {\n        Object.entries(endpoints).forEach(([definitionName, definition]) => {\n            var _a;\n            invalidDefinition = definitionName;\n            ajv.compile(definition.params);\n            ajv.compile((_a = definition.returns) !== null && _a !== void 0 ? _a : {});\n        });\n    });\n}\ncatch (exception) {\n    throw new Error(`Procedures specification schema '${invalidDefinition}' is incorrect: ${exception}`);\n}\nconst validateRequestResponse = (schema, data, // eslint-disable-line @typescript-eslint/no-explicit-any\nid) => {\n    const errors = validateJSON(ajv, schema, data);\n    if (!errors.length)\n        return undefined;\n    const message = `Request method does not match specification`;\n    if (id === undefined)\n        throw new RPCError(message, errors);\n    return createJSONRPCErrorResponse(id, PMMessageType.ERROR, message, errors);\n};\n/**\n * Middleware that validates received requests.\n */\nconst validateServerRequestResponse = (next, request, serverParams) => __awaiter(void 0, void 0, void 0, function* () {\n    var _a;\n    // request validation\n    if (!(request.method in frontendEndpoints)) {\n        if (request.id !== undefined)\n            return createJSONRPCErrorResponse(request.id, 1, 'Requested method does not exist');\n        throw new Error('Requested method does not exist');\n    }\n    const schema = frontendEndpoints[request.method];\n    const requestError = validateRequestResponse(schema.params, (_a = request.params) !== null && _a !== void 0 ? _a : {}, request.id);\n    if (requestError)\n        return requestError;\n    const response = yield next(request, serverParams);\n    if (request.id === undefined)\n        return null;\n    // response validation\n    if ((response === null || response === void 0 ? void 0 : response.result) !== undefined && schema.returns !== null) {\n        const responseError = validateRequestResponse(schema.returns, response.result, response.id);\n        if (responseError)\n            return responseError;\n    }\n    return response;\n});\nlet jsonRPCID = 1;\n// eslint-disable-next-line no-plusplus\nconst createID = () => jsonRPCID++;\nconst requestSchema = new Map();\nlet jsonRPCServer;\nconst validateClientResponse = (response) => {\n    var _a;\n    if (response.result && response.id && ((_a = requestSchema.get(response.id)) === null || _a === void 0 ? void 0 : _a.returns)) {\n        const responseError = validateRequestResponse(\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        requestSchema.get(response.id).returns, response.result, response.id);\n        if (responseError)\n            return responseError;\n    }\n    return response;\n};\nclass CustomJSONRPCClient extends JSONRPCClient {\n    receive(responses) {\n        // eslint-disable-next-line no-param-reassign\n        responses = Array.isArray(responses) ? responses : [responses];\n        super.receive(responses.map(validateClientResponse));\n    }\n}\n/**\n * Function that creates JSON-RPC client-server and defines how messages are send and received.\n */\nfunction createServer() {\n    // Create JSON-RPC server\n    jsonRPCServer = new CustomJSONRPCServerAndClient(new JSONRPCServer(), new CustomJSONRPCClient((request_1, _a) => __awaiter(this, [request_1, _a], void 0, function* (request, { externalApp }) {\n        var _b;\n        if (!externalApp) {\n            throw new Error('Missing backend.');\n        }\n        const method = (customMethodRegex.test(request.method)) ?\n            customMethodReplace : request.method;\n        // request validation\n        if (!(method in externalEndpoints) && !(method in backendEndpoints)) {\n            throw new Error('Requested method not known');\n        }\n        const endpoints = (method in externalEndpoints) ?\n            externalEndpoints : backendEndpoints;\n        const schema = endpoints[method];\n        const requestError = validateRequestResponse(schema.params, (_b = request.params) !== null && _b !== void 0 ? _b : {}, request.id);\n        if (requestError) {\n            throw new RPCError(requestError.error.message, requestError.error.data);\n        }\n        if (request.id) {\n            requestSchema.set(request.id, schema);\n        }\n        // sending request\n        const endpoint = (endpoints === backendEndpoints) ? 'backend-api' : 'external-api';\n        try {\n            externalApp.request(JSON.parse(JSON.stringify(request)), endpoint);\n        }\n        catch (exception) {\n            return Promise.reject(exception);\n        }\n        return Promise.resolve();\n    }), createID));\n    // Add middlewares\n    jsonRPCServer.server.applyMiddleware(validateServerRequestResponse);\n    // Register JSON-RPC methods\n    Object.entries(remoteProcedures).forEach(([name, func]) => {\n        if (typeof (func) === 'function' && name in frontendEndpoints)\n            jsonRPCServer.addMethod(name, func);\n        else if (typeof (func) === 'function') {\n            NotificationHandler.showToast('warning', `Function ${name} was not registered as RPC method`);\n        }\n    });\n    jsonRPCServer.customMethodRegex = customMethodRegex;\n    jsonRPCServer.customMethodReplace = customMethodReplace;\n}\nconst obj = {\n    get jsonRPC() {\n        if (!jsonRPCServer)\n            createServer();\n        return jsonRPCServer;\n    },\n};\nexport default obj.jsonRPC;\n","/*\n * Copyright (c) 2024 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\nexport class InterfaceRegistry {\n    constructor() {\n        Object.defineProperty(this, \"exposedInterfaces\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n    }\n    /**\n     * Clears the registry.\n     */\n    clearRegistry() {\n        this.exposedInterfaces.clear();\n    }\n    /**\n     * Stores graph id of a shared interface in the registry, so that when\n     * privatizing an interface we can remove it from all the graphs that use it.\n     * If the interface is not registered, an error is thrown.\n     *\n     * @param {string} intfId Id of the interface.\n     * @param {string} graphId Id of a graph that has the registered interface\n     */\n    pushGraphIdToRegistry(intfId, graphId) {\n        const sharedInterface = this.exposedInterfaces.get(intfId);\n        if (!sharedInterface) {\n            throw new Error(`Interface with id ${intfId} not found in the register.`);\n        }\n        sharedInterface.graphIds.push(graphId);\n    }\n    /**\n     * Seamlessly wraps passed `intf`, so that the properties `maxConnectionsCount`,\n     * `connectionCount` and `type` are shared between those two interfaces.\n     *\n     * @param {NodeInterface} intf Interface for which the wrapper is created.\n     */\n    createSharedInterface(intf) {\n        const sharedInterface = this.exposedInterfaces.get(intf.id);\n        if (!sharedInterface) {\n            throw new Error(`'Interface with id ${intf.id} not found in the register.`);\n        }\n        Object.defineProperty(intf, 'maxConnectionsCount', {\n            get() {\n                return sharedInterface.sharedInterface.maxConnectionsCount;\n            },\n            set(value) {\n                sharedInterface.sharedInterface.maxConnectionsCount = value;\n            },\n        });\n        Object.defineProperty(intf, 'connectionCount', {\n            get() {\n                return sharedInterface.sharedInterface.connectionCount;\n            },\n            set(value) {\n                sharedInterface.sharedInterface.connectionCount = value;\n            },\n        });\n        Object.defineProperty(intf, 'type', {\n            get() {\n                return sharedInterface.sharedInterface.type;\n            },\n        });\n    }\n    /**\n     * Checks if the interface of given id is registered.\n     *\n     * @param {string} intfId Id of the interface to check.\n     * @returns {boolean} True if the interface is registered, false otherwise.\n     */\n    isRegistered(intfId) {\n        return this.exposedInterfaces.has(intfId);\n    }\n    /**\n     * Returns the registered interface of given id. If the interface is not registered,\n     * an error is thrown.\n     *\n     * @param {string} intfId Id of the interface to get.\n     */\n    getRegisteredInterface(intfId) {\n        if (!this.exposedInterfaces.has(intfId)) {\n            throw new Error(`Interface of id ${intfId} is not registered.`);\n        }\n        return this.exposedInterfaces.get(intfId);\n    }\n    /**\n     * Deletes the registered interface of given id. If the interface is not registered,\n     * an error is thrown.\n     *\n     * @param {string} intfId Id of the interface to delete\n     */\n    deleteRegisteredInterface(intfId) {\n        if (!this.exposedInterfaces.has(intfId)) {\n            throw new Error(`Interface of id ${intfId} is not registered.`);\n        }\n        return this.exposedInterfaces.delete(intfId);\n    }\n    /**\n     * Registers an interface in the registry, so that it can be shared between\n     * multiple graph nodes. If the interface is already registered, an error is thrown.\n     *\n     * @param {NodeInterface} intf Interface to register.\n     */\n    registerInterface(intf, graphId) {\n        if (this.exposedInterfaces.has(intf.id)) {\n            throw new Error(`Trying to register an interface of id ${intf.id}, but it is already registered.`);\n        }\n        this.exposedInterfaces.set(intf.id, {\n            sharedInterface: intf,\n            sharedInterfaceGraphId: graphId,\n            graphIds: [],\n        });\n    }\n}\nexport const ir = new InterfaceRegistry();\n","/*\n * Copyright (c) 2022-2023 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Handles incoming notifications from Pipeline Manager: creates toast\n * notifications (popup), adds them to store for notifications panel,\n * logs appropriate notification to terminal window\n */\n\nimport { createToastInterface, POSITION } from 'vue-toastification';\nimport { notificationStore, terminalStore } from './stores.js';\nimport Notification from '../components/Notification.vue';\nimport EditorManager from './EditorManager';\n\nconst toast = createToastInterface({\n    timeout: 5000,\n    position: POSITION.BOTTOM_RIGHT,\n    icon: false,\n    closeButton: false,\n});\n\nexport const LOG_LEVEL = {\n    info: 0,\n    warning: 1,\n    error: 2,\n};\n\nexport default class NotificationHandler {\n    static NotificationHandler = true;\n\n    static defaultShowOption = true;\n\n    /**\n     * Sets the showNotification flag. If set to false, no popup\n     * notifications are shown\n     *\n     * @param show new value for showNotification\n     */\n    static setShowNotification(show) {\n        NotificationHandler.showNotifications = show;\n    }\n\n    /**\n     * Sets the default showNotification flag value.\n     * Does not change whether the notifications are actually set or not,\n     * this should be done in `setShowNotification` or `restoreShowNotification`\n     * methods\n     *\n     * @param showOption default value for showNotification flag\n     */\n    static setShowOption(showOption) {\n        NotificationHandler.defaultShowOption = showOption;\n    }\n\n    /**\n     * Restores show notification flag to it's default value\n     */\n    static restoreShowNotification() {\n        NotificationHandler.showNotifications = NotificationHandler.defaultShowOption;\n    }\n\n    static showToast(type, message) {\n        const content = {\n            component: Notification,\n            props: {\n                type,\n                message,\n            },\n        };\n\n        if (\n            LOG_LEVEL[type] >= LOG_LEVEL[\n                EditorManager.getEditorManagerInstance().baklavaView.logLevel?.toLowerCase()\n            ] && NotificationHandler.showNotifications\n        ) {\n            toast(content);\n        } else {\n            const bell = document.querySelector('#navbar-bell>.indicator');\n            if (bell) {\n                bell.classList.remove('animate');\n                setTimeout(() => bell.classList.add('animate'), 300);\n            }\n        }\n        notificationStore.add({ type, message });\n    }\n\n    /**\n     * Helper function that displays the title of the message as a toast notification and\n     * a full message in terminal with a proper title.\n     *\n     * @param {string} type Type of the toast notification\n     * @param {string} title Title of the message used both for toast and terminal notification.\n     * Preferably without any punctuation marks at the end\n     * @param {Array[string] | string | undefined} messages messages that are displayed in\n     * the terminal\n     */\n    static terminalLog(type, title, messages) {\n        NotificationHandler.showToast(type, title);\n        terminalStore.addParsed(title, messages);\n    }\n}\n"],"names":["ExternalBackendApp","constructor","url","jsonRPC","maxMessageLength","Object","defineProperty","this","enumerable","configurable","writable","value","socket","io","extraHeaders","commonHeaders","on","terminalLog","rejectAllPendingRequests","data","response","server","receive","ack","emitWithAck","undefined","error","method","client","isConnected","status","connected","request","externalApp","_a","onConnect","unknownError","messageType","code","EXCEPTION_RAISED","NEWER_SESSION_AVAILABLE","message","endpoint","disconnected","Error","stringify","JSON","length","messageID","id","crypto","randomUUID","i","emit","chunk","substring","Math","min","end","ConnectionManager","connectionHook","disconnectionHook","Map","add","set","remove","delete","poll","arguments","interval","isRunning","updating","Set","Array","from","keys","filter","has","forEach","updateConnection","then","Promise","resolve","setTimeout","wasConnected","get","pollStop","ExternalFrontendApp","source","postMessage","defaultAppCapabilities","handleExternalAppResponse","type","OK","content","ERROR","WARNING","handleSpecificationResult","errors","warnings","info","errorTitle","warningTitle","infTitle","isArray","showVersionError","currentVersion","specification","usedVersion","parse","version","RPCTerminalLog","args","ExternalApplicationManager","editorManager","EditorManager","getEditorManagerInstance","appCapabilities","backend","externalApplicationManager","connectionManager","initializeConnection","itemInfo","inProgress","isExternalAppAvailable","values","some","Boolean","usesBackend","params","requestSpecification","updateSpecification","conditionalLoadingScreen","load","callback","setLoad","baklavaView","editor","events","show","validateSpecification","String","success","specificationOrError","specificationVersion","preprocessSpecification","urloverrides","tryMinify","dataflowOrError","result","updateEditorSpecification","updateDataflow","dataflow","loadDataflow","requestAppCapabilities","requestDataflowExport","saveDataflow","requestDataflowAction","procedureName","requireResponse","runProcedureInfo","validatedProcedureName","customMethodRegex","test","customMethodReplace","showToast","startsWith","requestDataflowStop","importDataflow","file","document","getElementById","files","reader","FileReader","encoding","charset","readerPromise","onloadend","replace","readAsText","readAsDataURL","external_application_dataflow","mime","base64","notifyAboutChange","changedProperties","notifyWhenChanged","requestTerminalRead","terminalName","name","_externalApp","all","JSONRPCErrorCode","MethodNotFound","EXTERNAL_APPLICATION_NOT_CONNECTED","registerConnectionHook","registerApplication","registerBackendApplication","registerFrontendApplication","sourceWindow","logAndRespond","msgType","msg","logType","createJSONRPCErrorResponse","createJSONRPCSuccessResponse","window","getExternalApplicationManager","RunInfo","progressBar","querySelector","pr_inProgress","classList","style","width","hook","DefaultMap","defaultFactory","super","key","newValue","setHook","v","setTerminalHeight","y","h","mouseMoveHandler","e","clientY","mouseUpHandler","terminalWrapper","removeEventListener","mouseDownHandler","setHeight","styles","getComputedStyle","parseInt","height","addEventListener","parseProperties","properties","parsedProperties","usedNames","prop","group","parsedGroup","push","entries","pgroupname","realname","slice","indexOf","newProperty","p","hidden","propName","propType","intf","propDef","default","readonly","max","toLowerCase","BigInt","NaN","it","map","element","toString","step","dtype","open","updated","console","hideOnDefault","interfaceMaxConnectionsCount","interfaceType","createProperties","tempProperties","pname","groupedProperty","pgroup","parseNodeState","state","newState","interfaces","out","inputs","outputs","enabledInterfaceGroups","interfaceGroups","direction","title","instanceName","parsed","CustomNode","layer","twoColumn","description","nodeExtends","nodeExtending","nodeSiblings","relatedGraphs","extends","extending","siblings","k","addInput","addOutput","updateDynamicInterfaces","propertyInput","split","interfaceName","occupied","left","right","stateIOs","ioName","ioState","side","sidePosition","directionIoName","container","externalName","prototype","hasOwnProperty","call","firstUnoccupied","sort","a","b","findIndex","index","maxConnectionCount","match","removeOutput","removeInput","join","newInputs","newOutputs","baklavaIntf","assign","node","graph","nodes","find","n","updateInterfaces","bind","reactiveUpdate","toggleInterfaceGroup","visible","graphInstance","connections","c","to","removeConnection","save","savedState","newProperties","newInterfaces","port","stateInputs","stateOutputs","include","includes","prefix","privatizeInterface","idA","intfA","foundIntf","idB","intfB","addInterface","updateProperties","stateProperties","propA","baklavaProp","parsedState","isWebpack","endsWith","parsedValue","propertyType","checkType","items","mismatchedElements","val","Number","isInteger","groupName","detectDiscrepancies","groupState","stateios","refreshSidePositions","maxposition","position","onPlaced","externalRequest","goToGraph","graphid","switchToRelatedGraph","_","componentName","subscribe","onDestroy","event","unsubscribe","createBaklavaInterfaces","parsedInterfaces","createBaklavaInterface","fromEntries","CustomNodeFactory","defaultInterfaceGroups","generatedProperties","checkInterfaceNames","countedIntfNames","create","externalInterfaces","updateInterfaceRegistry","graphId","ir","isRegistered","getRegisteredInterface","sharedInterface","sharedInterfaceGraphId","deleteRegisteredInterface","registerInterface","updateSubgraphInterfaces","INTERFACE_PREFIXES","flat","errorMessages","idx","x","newInterfacesPositionsOrErrors","updateSubgraphProperties","externalProperties","property","override","GraphFactory","menuState","configurationMenu","addNode","placeNode","propertyMenu","interfaceMenu","propertyListMenu","interfaceListMenu","layerMenu","configurationState","nodeData","category","color","CytoscapeLayoutEngine","availableAlgorithms","calculate","cytoscapeGraph","elements","edges","connection","target","selector","shape","styleEnabled","options","activeAlgorithm","boundingBox","x1","y1","w","avoidOverlapPadding","nodeOverlap","idealEdgeLength","edge","nodeSpacing","ranker","nodeSep","rankSep","layout","run","promiseOn","defaultDirection","DYNAMIC_INTERFACE_SUFFIX","createInterface","originalSide","originalSidePosition","parseSingleInterfaces","interfaceGroup","tempParsed","input","inout","output","tempIO","array","j","buildingIO","bdirection","filteredTempInouts","duplicate","validateInterfaceGroupsNames","usedInterfaces","groupDirection","intfName","intfDirection","parsedIntfName","validateInterfaceGroups","applySidePositions","tempParsedSides","stripName","occupiedInputSidePositions","occupiedOutputSidePositions","leftSidePositionIndex","rightSidePositionIndex","getLeftSidePos","getRightSidePos","generateProperties","dynamic","interfaceMaxConnectionCount","parseInterfaces","intfG","directionG","tempParsedGroups","interfacesCreatingGroups","enabledInterfaceGroupsNames","parsedSides","createdInterfaces","Specification","static","currentSpecification","includedSpecification","unresolvedSpecification","instance","getInstance","getNodeSpecification","nodeName","validateJSON","ajv","schema","reference","removeSchema","$id","addSchema","validate","getSchema","isTextFormat","dataJSON","exception","path","instancePath","errorPrefix","lineStart","pointers","line","lineEnd","valueEnd","keyword","allowedValues","additionalProperty","allowedValue","unevaluatedProperty","err","NoLayoutAlgorithm","backendApiUrl","URLSearchParams","location","search","protocol","getBackendApiUrl","PMMessageType","PROGRESS","JSONRPCCustomErrorCode","loadingScreen","callback_1","loadEvent_1","args_1","loadEvent","log","storageAvailable","randomKey","random","randomValue","localStorage","setItem","removeItem","pmStorage","getItem","notificationStore","notifications","notification","removeOne","newNotifications","MAIN_TERMINAL","terminalStore","logs","Terminal","readOnly","isReadOnly","addParsed","messages","parsedMessage","clear","exists","getInstances","createTerminalInstance","manager","commitTypeToSpecification","newNodeData","currentType","editedType","_unregisterNodeType","ret","addNodeToEditorSpecification","findNodes","nodeType","viewModel","allNodes","graphs","createNode","nodeTypes","modifyConfiguration","highlightedType","alterProperties","createdProperties","loadErrors","alterInterfaces","addProperty","validateNodeProperty","removeProperties","_b","_c","_d","_e","removeFromSubgraph","nodesToUpdate","names","externalNames","propertiesToRemove","item","refreshSubgraph","validateNodeInterface","removeInterfaces","interfacesToRemove","ids","conn","BaseLayoutEngine","chooseAlgorithm","algorithm","BaseLayoutAlgorithm","doubleClick","timer","doubleClickTimer","lastClickTime","ev","Date","now","gridSnapper","movementStep","coord","round","nodeSnapper","kind","nodeId","selectedNodesIds","nearestCoords","otherCoords","abs","checkTerminalExistence","getGraph","graph_id","g","getNode","node_id","getProperty","frontend_status_get","frontend_specification_get","saveConfiguration","minify","getSave","graph_get","properties_change","new_value","position_change","nodes_change","added","setNodeColor","deleted","remove_with_connections","removeNode","removeNodeOnly","connections_change","fromIntf","findNodeInterface","toIntf","addConnection","getConnection","graph_change","properties_get","node_get","progress_change","procedureInfo","progress","metadata_change","updateMetadata","metadata","viewport_center","centerZoom","terminal_add","terminal_remove","terminal_write","terminal_clear","terminal_hide","hide","terminal_show","terminal_view","view","terminal_get_instances","notification_send","details","specification_change","specification_graph_change","specification_preprocess","resolveSpecification","specification_expand","assertNoErrors","specGraphs","specGraphMap","structuredClone","subgraphIds","subgraphId","finalGraphs","processingQueue","instanceId","shift","mode","subgraph","nestedSubgraphId","nestedInstanceId","graphLoadingState","nodes_highlight","selectedNodes","unselected","selected","register_external_frontend","return_from_subgraph","isInSubgraph","returnFromSubgraph","has_returned","CustomJSONRPCServerAndClient","JSONRPCServerAndClient","RPCError","schemas","allowUnionTypes","strict","loadEndpoints","endpoints","typedValue","returns","frontendEndpoints","backendEndpoints","externalEndpoints","invalidDefinition","definitionName","definition","compile","validateRequestResponse","validateServerRequestResponse","next","serverParams","requestError","responseError","jsonRPCID","createID","requestSchema","jsonRPCServer","validateClientResponse","CustomJSONRPCClient","JSONRPCClient","responses","JSONRPCServer","request_1","reject","applyMiddleware","func","addMethod","createServer","clearRegistry","exposedInterfaces","pushGraphIdToRegistry","intfId","graphIds","createSharedInterface","maxConnectionsCount","connectionCount","toast","timeout","BOTTOM_RIGHT","icon","closeButton","LOG_LEVEL","warning","NotificationHandler","setShowNotification","showNotifications","setShowOption","showOption","defaultShowOption","restoreShowNotification","component","props","logLevel","bell"],"sourceRoot":""}