"use strict";(self.webpackChunkpipeline_manager=self.webpackChunkpipeline_manager||[]).push([[389],{323:(e,t,n)=>{n.d(t,{A:()=>E});var i=n(13773),r=n(86049),o=n(50953),s=n(34076),a=n(51645),c=n(881),d=n(93617),u=n(34580),l=n(15215),p=n(55729);class f{constructor(e,t,n=262144){Object.defineProperty(this,"url",{enumerable:!0,configurable:!0,writable:!0,value:e}),Object.defineProperty(this,"jsonRPC",{enumerable:!0,configurable:!0,writable:!0,value:t}),Object.defineProperty(this,"maxMessageLength",{enumerable:!0,configurable:!0,writable:!0,value:n}),Object.defineProperty(this,"socket",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.socket=(0,p.io)(e,{extraHeaders:f.commonHeaders}),this.socket.on("connect",(()=>d.A.terminalLog("info","Initialized connection with communication server",null))),this.socket.on("disconnect",(()=>{d.A.terminalLog("warning","Connection with communication server disrupted",null),this.jsonRPC.rejectAllPendingRequests("WebSocket disconnected")})),this.socket.on("api",(e=>(0,l.sH)(this,void 0,void 0,(function*(){const t=yield this.jsonRPC.server.receive(e);if(t)try{const e=yield this.socket.emitWithAck("external-api",t);void 0===e||e||d.A.terminalLog("error","Response to external app was not send",null)}catch(t){d.A.terminalLog("error",`Response to ${e.method} request cannot be send`,t)}})))),this.socket.on("api-response",(e=>{this.jsonRPC.client.receive(e)}))}isConnected(){return(0,l.sH)(this,void 0,void 0,(function*(){try{const{status:{connected:e}}=yield this.jsonRPC.request("status_get",void 0,{externalApp:this});return e}catch(e){return!1}}))}onConnect(){return(0,l.sH)(this,void 0,void 0,(function*(){var e;try{return yield this.jsonRPC.request("external_app_connect",void 0,{externalApp:this}),!0}catch(t){const n=t,i=(null!==(e=n.code)&&void 0!==e?e:s.c5.EXCEPTION_RAISED)!==s.c5.NEWER_SESSION_AVAILABLE?"warning":"info";return d.A.terminalLog(i,n.message,void 0),!1}}))}request(e,t){var n;if(this.socket.disconnected)throw new Error("WebSocket is disconnected. Make sure the communication server is available.");const i=JSON.stringify(e);if(i.length>this.maxMessageLength){const r=null!==(n=e.id)&&void 0!==n?n:crypto.randomUUID();for(let e=0;e<i.length;e+=this.maxMessageLength)this.socket.emit(t,{id:r,chunk:i.substring(e,Math.min(e+this.maxMessageLength,i.length)),end:e+this.maxMessageLength>=i.length})}else this.socket.emit(t,e)}}Object.defineProperty(f,"commonHeaders",{enumerable:!0,configurable:!0,writable:!0,value:{"Access-Control-Allow-Origin":"http://localhost","Access-Control-Allow-Headers":"Origin, X-Requested-With, Content-Type, Accept"}});const h=f;class g{constructor(e,t){Object.defineProperty(this,"connectionHook",{enumerable:!0,configurable:!0,writable:!0,value:e}),Object.defineProperty(this,"disconnectionHook",{enumerable:!0,configurable:!0,writable:!0,value:t}),Object.defineProperty(this,"isRunning",{enumerable:!0,configurable:!0,writable:!0,value:!1}),Object.defineProperty(this,"connected",{enumerable:!0,configurable:!0,writable:!0,value:new Map})}add(e){this.connected.set(e,!1)}remove(e){return this.connected.delete(e)}poll(){return(0,l.sH)(this,arguments,void 0,(function*(e=1500){this.isRunning=!0;const t=new Set;for(;this.isRunning;)Array.from(this.connected.keys()).filter((e=>!t.has(e))).forEach((e=>{t.add(e),this.updateConnection(e).then((()=>t.delete(e)))})),yield new Promise((t=>{setTimeout(t,e)}))}))}updateConnection(e){return(0,l.sH)(this,void 0,void 0,(function*(){try{const t=this.connected.get(e);let n=yield e.isConnected();!n&&t&&(d.A.terminalLog("warning","External application was disconnected",void 0),this.disconnectionHook(e)),n&&!t&&((yield e.onConnect())?this.connectionHook(e):n=!1),this.connected.set(e,n)}catch(t){this.connected.set(e,!1)}}))}pollStop(){this.isRunning=!1}}class m{constructor(e){Object.defineProperty(this,"source",{enumerable:!0,configurable:!0,writable:!0,value:e})}isConnected(){return(0,l.sH)(this,void 0,void 0,(function*(){return!0}))}onConnect(){return(0,l.sH)(this,void 0,void 0,(function*(){return!0}))}request(e,t){if("backend-api"===t)throw new Error("Frontend external app does not support backend endpoints");this.source.postMessage(e,"*")}}const y=[];function v(e){e.type===s.FC.OK?d.A.terminalLog("info",e.content):e.type===s.FC.ERROR?d.A.terminalLog("error",`Error occurred: ${e.content}`,e.content):e.type===s.FC.WARNING&&d.A.terminalLog("warning",`Warning: ${e.content}`,e.content)}function w({errors:e,warnings:t,info:n},i,r,o){return Array.isArray(t)&&t.length&&d.A.terminalLog("warning",r,t),Array.isArray(e)&&e.length?(d.A.terminalLog("error",i,e),!0):(Array.isArray(n)&&n.length&&d.A.terminalLog("info",o,n),!1)}function b(e,t){let n;try{n=JSON.parse(t).version}catch{return}e!==n&&d.A.terminalLog("error","Mismatched specification version",`Specification version (${n}) differs from the current version (${e}). It may result in unexpected behaviour.Please refer to https://antmicro.github.io/kenning-pipeline-manager/changelogs.html to see if that is the case.`)}function A(e,t,n){const i=void 0!==n?[n,[t.message,...t.data??[]]]:[t.message,t.data];d.A.terminalLog(e,...i)}class O{editorManager=u.Ay.getEditorManagerInstance();appCapabilities=(0,o.KR)([]);externalApp=null;connectionHook=null;backend=!1;constructor(){this.editorManager.externalApplicationManager=this,this.connectionManager=new g((e=>this.initializeConnection(e)),(()=>c.A.forEach((e=>{e.inProgress=!1})))),this.connectionManager.poll()}isExternalAppAvailable(){return null!==this.externalApp}isConnected(){return Array.from(this.connectionManager.connected.values()).some(Boolean)}usesBackend(){return this.backend}async request(e,t){const{externalApp:n}=this;return a.Ay.request(e,t,{externalApp:n})}async requestSpecification(){let e="Unknown error";try{const t=await this.request("specification_get");if(t.type===s.FC.OK){const e=t.content;await this.updateSpecification(e),d.A.terminalLog("info","Specification loaded successfully")}else t.type===s.FC.WARNING?(e=t.content,d.A.terminalLog("warning",e)):t.type===s.FC.ERROR&&(e=t.content,d.A.terminalLog("error",e))}catch(e){A("error",e)}}async conditionalLoadingScreen(e,t){const{setLoad:n}=this.editorManager.baklavaView.editor.events;return(0,s.NV)(t,n,{show:e})}async validateSpecification(e){if("string"==typeof e||e instanceof String){const[t,n]=await(0,u.sA)(e);if(!t)return d.A.terminalLog("error","Specification is invalid",n),Promise.resolve();e=n}return w(u.Ay.validateSpecification(e),"Specification is invalid","Warnings when validating specification","Validated specification")?(b(this.editorManager.specificationVersion,e),Promise.resolve()):e}async preprocessSpecification(e,{urloverrides:t,tryMinify:n}={}){if(!(e=await this.validateSpecification(e)))return Promise.resolve();if("string"==typeof n||n instanceof String){const[e,t]=await(0,u.sA)(n);if(!e)return d.A.terminalLog("error","Dataflow is invalid",t),Promise.resolve();n=t}const i=await this.editorManager.preprocessSpecification(e,{urloverrides:t,tryMinify:n});return w(i,"Errors when preprocessing specification","Warnings when preprocessing specification","Specification preprocessed")?Promise.resolve():i.specification}async updateSpecification(e,{urloverrides:t,tryMinify:n}={}){if(!(e=await this.validateSpecification(e)))return Promise.resolve();if("string"==typeof n||n instanceof String){const[e,t]=await(0,u.sA)(n);if(!e)return d.A.terminalLog("error","Dataflow is invalid",t),Promise.resolve();n=t}const i=w(await this.editorManager.updateEditorSpecification(e,!1,!0,t,n),"Errors when loading specification","Warnings when loading specification","Loaded specification");return i&&b(this.editorManager.specificationVersion,e),i}async updateDataflow(e){if("string"==typeof e||e instanceof String){const[t,n]=await(0,u.sA)(e);if(!t)return void d.A.terminalLog("error","Dataflow is invalid",n);e=n}const{errors:t,warnings:n,info:i}=await this.editorManager.loadDataflow(e);Array.isArray(t)&&t.length?(d.A.terminalLog("error","Dataflow is invalid",t),Array.isArray(i)&&i.length&&d.A.terminalLog("error","Mismatched specification version",`${i} Please refer to https://antmicro.github.io/kenning-pipeline-manager/changelogs.html to see if that is the case.`)):Array.isArray(n)&&n.length?d.A.terminalLog("warning","Dataflow loaded with warning",n):Array.isArray(i)&&i.length&&d.A.terminalLog("info","Dataflow loaded",i)}async requestAppCapabilities(){try{const e=await this.request("app_capabilities_get");this.appCapabilities.value=e}catch(e){this.appCapabilities.value=y,A("warning",e,"Application capabilities cannot be retrieved, using defaults")}}async requestDataflowExport(){const e=this.editorManager.saveDataflow();if(!e)return!1;let t;try{t=await this.request("dataflow_export",{dataflow:e})}catch(e){return A("error",e),!1}return t.type===s.FC.OK?t:(t.type===s.FC.ERROR?d.A.terminalLog("error",`Error occurred: ${t.content}`,t.content):t.type===s.FC.WARNING&&d.A.terminalLog("warning",`Warning: ${t.content}`,t.content),!1)}async requestDataflowAction(e,t){const n=this.editorManager.saveDataflow(),i=c.A.get(e);if(!n)return;const r=a.Ay.customMethodRegex.test(e)?a.Ay.customMethodReplace:e;if("dataflow_run"===r){if(i.inProgress)return void d.A.showToast("error","Previous run has not finished, cannot process this request");d.A.showToast("info","Running dataflow")}if(t){let t;i.inProgress=!0;try{t=r.startsWith("dataflow_")?await this.request(e,{dataflow:n}):await this.request(r)}catch(e){return A("error",e,"Cannot create a request"),void(i.inProgress=!1)}v(t),i.inProgress=!1}else r.startsWith("dataflow_")?this.request(e,{dataflow:n}):this.request(r)}async requestDataflowStop(e){if(c.A.get(e).inProgress)try{v(await this.request("dataflow_stop",{method:e}))}catch(e){A("error",e)}else d.A.showToast("error","Nothing to stop, no ongoing jobs running")}async importDataflow(){const e=document.getElementById("request-dataflow-button").files[0];if(!e)return;const t=new FileReader,n=(0,r.charset)(e.type),i=new Promise((e=>{t.onloadend=()=>{e(n?t.result:t.result.replace(/data:.*;base64,/,""))}}));n?t.readAsText(e,n):t.readAsDataURL(e);const o=await i;if(o)try{const t=await this.request("dataflow_import",{external_application_dataflow:o,mime:e.type,base64:!n});if(t.type===s.FC.OK){const{errors:e,warnings:n}=await this.editorManager.loadDataflow(t.content);Array.isArray(e)&&e.length?d.A.terminalLog("error","Dataflow is invalid",e):Array.isArray(n)&&n.length?d.A.terminalLog("warning","Dataflow imported with warning",n):d.A.showToast("info","Imported dataflow")}else if(t.type===s.FC.ERROR){const e=t.content;d.A.terminalLog("error",`Error occurred: ${t.content}`,e)}else t.type===s.FC.WARNING&&d.A.terminalLog("warning",`Warning: ${t.content}`,"Imported dataflow")}catch(e){A("error",e)}else d.A.showToast("error","File cannot be loaded")}async notifyAboutChange(e,t){if(this.isConnected()&&this.editorManager.notifyWhenChanged)try{await this.request(e,t)}catch(t){A("warning",t,`Notifying about change failed (${e})`)}}async requestTerminalRead(e,t){if(this.isConnected())try{await this.request("terminal_read",{name:e,message:t})}catch(e){A("warning",e,"Sending terminal input failed")}}async initializeConnection(e){this.backend&&d.A.terminalLog("info","External application connected successfully",void 0),await Promise.all([this.requestSpecification(),this.requestAppCapabilities()]);try{await this.request("frontend_on_connect")}catch(e){e.code!==i.JSONRPCErrorCode.MethodNotFound&&e.code!==s.c5.EXTERNAL_APPLICATION_NOT_CONNECTED&&A("error",e)}null!==this.connectionHook&&this.connectionHook()}registerConnectionHook(e){this.connectionHook=e}registerApplication(e){this.externalApp=e,this.connectionManager.add(e),null!==this.connectionHook&&this.connectionHook()}registerBackendApplication(e){this.registerApplication(new h(e,a.Ay)),this.backend=!0}registerFrontendApplication(e,t){const n=(e,n)=>{const[r,o]={[s.FC.ERROR]:["error",(0,i.createJSONRPCErrorResponse)(t.id,e,n)],[s.FC.WARNING]:["warning",(0,i.createJSONRPCSuccessResponse)(t.id,n)],[s.FC.OK]:["info",(0,i.createJSONRPCSuccessResponse)(t.id,n)]}[e];return e!==s.FC.OK&&d.A.terminalLog(r,n),o};return e===window?n(s.FC.ERROR,"External frontend cannot be a Pipeline Manager itself"):(null!==this.externalApp&&(this.connectionManager.remove(this.externalApp),n(s.FC.WARNING,"Replacing current external application.")),this.registerApplication(new m(e)),this.backend=!1,n(s.FC.OK,"Registered external frontend successfully"))}}let $;function E(){return $||($=new O,s.Ay&&$.registerBackendApplication(s.Ay)),$}},881:(e,t,n)=>{n.d(t,{A:()=>o});class i{constructor(e){Object.defineProperty(this,"procedureName",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"hook",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"pr_inProgress",{enumerable:!0,configurable:!0,writable:!0,value:!1}),this.procedureName=e}get progressBar(){return document.querySelector(`#navbar-button-${this.procedureName} > .progress-bar`)}get inProgress(){return this.pr_inProgress}set inProgress(e){const{progressBar:t}=this;t&&(e||t.classList.remove("animate"),t.style.width="0%"),this.pr_inProgress=e,void 0!==this.hook&&this.hook()}}class r extends Map{constructor(e){super(),Object.defineProperty(this,"defaultFactory",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.defaultFactory=e}get(e){return super.has(e)||super.set(e,this.defaultFactory(e)),super.get(e)}}const o=new class extends r{constructor(){super(...arguments),Object.defineProperty(this,"hook",{enumerable:!0,configurable:!0,writable:!0,value:void 0})}get(e){if(!super.has(e)){const t=this.defaultFactory(e);t.hook=this.hook,super.set(e,t)}return super.get(e)}setHook(e){this.hook=e,this.forEach((t=>{t.hook=e}))}}((e=>new i(e)))},5292:(e,t,n)=>{n.d(t,{q:()=>c});let i,r=0,o=0;const s=e=>{const{clientY:t}=e;t>61&&i(o+(r-t))},a=()=>{const e=document.querySelector(".terminal-wrapper");document.removeEventListener("mousemove",s),document.removeEventListener("mouseup",a),e.style["pointer-events"]=""},c=e=>t=>{const n=document.querySelector(".terminal-wrapper");i=e,r=t.clientY;const c=window.getComputedStyle(n);o=parseInt(c.height,10),document.addEventListener("mousemove",s),document.addEventListener("mouseup",a),n.style["pointer-events"]="none"}},8239:(e,t,n)=>{n.d(t,{$9:()=>w,$o:()=>N,Sx:()=>j,Wo:()=>x,eC:()=>A,fk:()=>S,gv:()=>b,j4:()=>E,y5:()=>$});var i=n(46171),r=n(96422),o=n(14121),s=n(878),a=n(36568),c=n(3455),d=n(21585),u=n(56761),l=n(81630),p=n(76433),f=n(66254),h=n(46363),g=n(74752),m=n(31897),y=n(15502),v=n(57565);function w(e){const t={},n=new Set,i=[];return e.forEach((e=>{if(void 0!==e.group&&Array.isArray(e.group)){const t=w(e.group);Array.isArray(t)&&t.length&&i.push(...t),Object.entries(t).forEach((([t])=>{if(n.has(t)){const n=t.slice(t.indexOf("_")+1);i.push(`Property named '${n}' in a group property '${e.name}' is a duplicate.`)}n.add(t)})),e.group=t}n.has(`property_${e.name}`)&&i.push(`Property named '${e.name}' is a duplicate.`),t[`property_${e.name}`]={...e},n.add(`property_${e.name}`)})),i.length?i:t}function b(e,t=!1){const n=e.name,i=e.type;let r,o=e.default;switch(i){case"constant":r=new g.A(n,o);break;case"text":r=new c.A(n,o,e.readonly);break;case"multiline":r=new h.A(n,o,e.readonly);break;case"number":r=new l.A(n,o,e.min,e.max,e.readonly);break;case"integer":r=new d.A(n,o,e.min,e.max,e.readonly);break;case"hex":r=new a.A(n,o.toLowerCase(),e.min?BigInt(e.min):NaN,e.max?BigInt(e.max):NaN,e.readonly);break;case"select":{const t=e.values.map((e=>e.toString()));r=new p.A(n,o,t,e.readonly)}break;case"bool":r=new s.A(n,o,e.readonly);break;case"slider":void 0===o&&(o=e.min),r=new f.A(n,o,e.min,e.max,e.step,e.readonly);break;case"list":null===o&&(o=[]),r=new u.A(n,o,e.dtype,e.readonly);break;case"button-url":r=new m.A(n,(()=>window.open(r.value,"_blank")),o,"button-url");break;case"button-api":r=new m.A(n,(()=>r.events.updated.emit(["button_click",{id:r.id,value:r.value}])),o,"button-api");break;case"button-graph":r=new m.A(n,(()=>r.events.updated.emit(r.value)),o,"button-graph");break;default:console.error(i," input type is not recognized.")}return void 0!==r&&(r.hidden=t,r.type=i,r.default=o,r.hideOnDefault=e.hideOnDefault,void 0!==e.interfaceMaxConnectionsCount&&(r.interfaceMaxConnectionsCount=e.interfaceMaxConnectionsCount),void 0!==e.interfaceType&&(r.interfaceType=e.interfaceType)),r}function A(e){const t={};return Object.entries(e).forEach((([e,n])=>{void 0!==n.group?(t[e]=()=>{const e=b(n);return e.group=Object.keys(n.group),e},Object.entries(n.group).forEach((([e,n])=>{t[e]=()=>b(n)}))):t[e]=()=>b(n)})),t}function O(e){const t=JSON.parse(JSON.stringify(e));if(void 0!==t.interfaces){const e=(0,o.Cy)(t.interfaces,[],[]);if(Array.isArray(e)&&e.length)return e;const{inputs:n,outputs:i}=e;t.inputs=n,t.outputs=i,delete t.interfaces}if(void 0!==t.properties){const e=w(t.properties);if(Array.isArray(e)&&e.length)return e;t.inputs={...t.inputs,...e},delete t.properties}if(void 0!==t.enabledInterfaceGroups){const e={};t.enabledInterfaceGroups.forEach((t=>{e[`${t.direction}_${t.name}`]={...t}})),t.enabledInterfaceGroups=e}else t.enabledInterfaceGroups={};return t.title=t.instanceName??"",delete t.instanceName,t.parsed=!0,t}class $ extends i.bP{inputs={};outputs={};type=void 0;constructor(e,t,n,i,r,o="",s=[],a=[],c=[],d=300,u=void 0){super(),this.description=o,this.extends=s,this.extending=a,this.siblings=c,this.layer=t,this.title=e,this.twoColumn=r,this.type=e,this.width=d,this.relatedGraphs=u,Object.keys(n).forEach((e=>{const t=n[e]();this.addInput(e,t)})),Object.keys(i).forEach((e=>{const t=i[e]();this.addOutput(e,t)}))}updateDynamicInterfaces(e){const t=[],{value:n}=e;if("string"!=typeof e.name)throw new Error("Property 'name' is undefined or not a string in updateDynamicInterfaces.");const r=this.inputs[`property_${e.name}`],s=r?.interfaceType,a=r?.interfaceMaxConnectionsCount,c=e.name.split(" ");if(c.length<2)throw new Error(`Property name is too short to extract direction in updateDynamicInterfaces.Property name: ${e.name}`);const d=c[c.length-2],u=e.name.slice(0,-1*(o.Yg.length+2+d.length)),l={left:[],right:[]},p={...this.inputs,...this.outputs};Object.entries(p).forEach((([e,t])=>{e.startsWith("property_")||l[t.side].push(t.sidePosition)}));for(let e=0;e<n;e+=1){const n=`${u}[${e}]`,i=`${d}_${n}`,r={name:n,direction:d},o="output"===d?this.outputs:this.inputs;if(i in o&&(r.externalName=o[i].externalName,r.side=o[i].side,r.sidePosition=o[i].sidePosition),!Object.prototype.hasOwnProperty.call(r,"sidePosition")&&!Object.prototype.hasOwnProperty.call(r,"side")){const e="output"===d?"right":"left";let t=l[e].sort(((e,t)=>e-t)).findIndex(((e,t)=>e!==t));-1===t&&(t=0===l[e].length?0:Math.max(...l[e])+1),r.sidePosition=t,r.side=e,r.type=s,r.maxConnectionCount=a,l[r.side].push(t)}t.push(r)}const f="output"===d?this.outputs:this.inputs;Object.keys(f).forEach((e=>{if(!e.startsWith(`${d}_${u}[`))return;const t=e.match(/\[(\d+)\]$/);t&&(parseInt(t[1],10)<n||("output"===d?this.removeOutput(e):this.removeInput(e)))}));const h=(0,o.Cy)(t,[],[]);if(Array.isArray(h)&&h.length)throw new Error(`Internal error, node ${this.type} invalid. Reason: ${h.join(" ")}`);const{inputs:g,outputs:m}=h;Object.entries("output"===d?m:g).forEach((([e,t])=>{if(e in f)return;const n=new i.gZ(e);Object.assign(n,t),"output"===d?this.addOutput(e,n):this.addInput(e,n)}));const y=this.graph.nodes.find((e=>e.id===this.id));this.updateInterfaces.bind(y)(g,m,!1,[`${d}_${u}`])}toggleInterfaceGroup(e,t){e.hidden||t||this.graphInstance.connections.filter((t=>t.from===e||t.to===e)).forEach((e=>{this.graphInstance.removeConnection(e)})),t&&(0,r.q6)(this,e,e.side),e.hidden=!t}save(){const e=super.save(),t=[],n=[],i=[];return Object.entries({...this.inputs,...this.outputs}).forEach((e=>{const[r,o]=e;o.port?o.hidden||(o.interfaces&&i.push({name:r.slice(o.direction.length+1),direction:o.direction}),n.push({name:r.slice(o.direction.length+1),externalName:o.externalName,id:o.id,direction:o.direction,side:o.side,sidePosition:o.sidePosition})):t.push({name:r.slice(9),externalName:o.externalName,id:o.id,value:void 0===o.value?null:o.value})})),delete e.inputs,delete e.outputs,e.interfaces=n,e.properties=t,e.enabledInterfaceGroups=i,e.relatedGraphs=this.relatedGraphs,e.name=e.type,delete e.type,e.instanceName=""===e.title?void 0:e.title,delete e.title,e}updateInterfaces(e,t,n=!0,r=void 0){const o=[];return Object.entries(this.inputs).forEach((([t,n])=>{void 0!==n.direction&&(Object.keys(e).includes(t)||void 0!==r&&!r.some((e=>t.startsWith(e)))||(o.push(`Interface '${n.name}' of direction '${n.direction}' removed as it was not found in the dataflow.`),this.graph.editor.privatizeInterface(this.graph.id,n),this.removeInput(t)))})),Object.entries(e).forEach((([e,t])=>{if(void 0===t.direction)return;const r=Object.entries(this.inputs).find((([n,i])=>n===e&&i.direction===t.direction));if(void 0===r){const n=new i.gZ(e);o.push(`Interface '${t.name}' of direction '${t.direction}' created as it was not found in the specification.`),Object.assign(n,t),this.addInterface(n.direction,e,n)}else n&&Object.assign(r[1],t)})),Object.entries(this.outputs).forEach((([e,n])=>{void 0!==n.direction&&(Object.keys(t).includes(e)||void 0!==r&&!r.some((t=>e.startsWith(t)))||(o.push(`Interface '${n.name}' of direction '${n.direction}' removed as it was not found in the dataflow.`),this.graph.editor.privatizeInterface(this.graph.id,n),this.removeOutput(e)))})),Object.entries(t).forEach((([e,t])=>{const r=Object.entries(this.outputs).find((([n,i])=>n===e&&i.direction===t.direction));if(void 0===r){const n=new i.gZ(e);o.push(`Interface '${t.name}' of direction '${t.direction}' created as it was not found in the specification.`),Object.assign(n,t),this.addInterface(n.direction,e,n)}else n&&Object.assign(r[1],t)})),o}updateProperties(e){const t=[];return Object.entries(this.inputs).forEach((([n,i])=>{void 0===i.direction&&(Object.keys(e).includes(n)||(t.push(`Property '${i.name}' removed as it was not found in the dataflow.`),this.removeInput(n)))})),Object.entries(e).forEach((([e,n])=>{if(void 0===n.direction&&void 0===Object.entries(this.inputs).find((([t])=>t===e))){const i=new c.A(n.name,n.value);t.push(`Property '${n.name}' created as it was not found in the specification.`),Object.assign(i,n),this.addInput(e,i)}})),t}load(e){let t;if(Object.prototype.hasOwnProperty.call(e,"parsed")&&e.parsed)t=e;else if(t=O(e),Array.isArray(t)&&t.length)return t;let n=!0;try{n=window.isWebpack}catch{n=!1}let r=[];if(Object.entries(t.inputs).forEach((([e,t])=>{e.startsWith("property_")&&e.startsWith("property_")&&e.endsWith(`${o.Yg}`)&&this.updateDynamicInterfaces(t)})),r=function(e,t,n){let i=[];return Object.keys({...e.inputs,...e.outputs}).forEach((r=>{const o=r.slice(r.indexOf("_")+1),s=r.slice(0,r.indexOf("_"));if(Object.prototype.hasOwnProperty.call(t,r)||Object.prototype.hasOwnProperty.call(n,r)){if("property"===s){const n=e.inputs[r].value,s=t[r].type;if(((e,t)=>{switch(e){case"constant":case"select":return!0;case"text":case"multiline":case"button-url":case"button-graph":case"hex":return"string"==typeof t;case"number":case"integer":case"slider":return"number"==typeof t;case"bool":return"boolean"==typeof t;case"list":return Array.isArray(t);case"button-api":return"object"==typeof t;default:return!1}})(s,n)){if("select"===s){const{items:e}=t[r];Array.isArray(e)?e.map(String).includes(String(n))||i.push(`Property '${o}' value mismatch. ${n} (type: ${typeof n}) not found in ${JSON.stringify(e)}`):String(n)!==String(e)&&i.push(`Property '${o}' value mismatch. Expected '${e}' (type: ${typeof e}), found '${n}' (type: ${typeof n}).`)}else if("list"===s){const{dtype:e}=t[r],s=n.filter((t=>"integer"===e?"number"!=typeof t||!Number.isInteger(t):typeof t!==e));s.length>0&&i.push(`Property '${o}' value mismatch. Items: '${s.join(" ")}' are not of '${e}' dtype.Items are of type: ${s.map((e=>typeof e)).join(", ")}`)}}else i.push(`Property '${o}' type mismatch. ${s} expected, ${typeof n} found.`)}}else"property"===s?i.push(`Property named '${o}' not found in specification!`):i.push(`Interface named '${o}' of direction '${s}' not found in specification!`)})),Object.keys(e.enabledInterfaceGroups).forEach((e=>{if(!Object.prototype.hasOwnProperty.call(t,e)&&!Object.prototype.hasOwnProperty.call(n,e)){const t=e.slice(0,e.indexOf("_")),n=e.slice(e.indexOf("_")+1);i.push(`Interface group named '${n}' of direction '${t}' not found in specification!`)}})),i&&i.length||(i=(0,o.W9)(Object.keys(e.enabledInterfaceGroups),t,n)),i}(t,this.inputs,this.outputs),Array.isArray(r)&&r.length)return r;super.load(t),Object.keys(t.enabledInterfaceGroups).length&&Object.entries({...this.inputs,...this.outputs}).forEach((([,e])=>{void 0!==e.interfaces&&(e.hidden=!0)})),Object.entries(t.enabledInterfaceGroups).forEach((([e,t])=>{"input"===t.direction||"inout"===t.direction?this.inputs[e].hidden=!1:"output"===t.direction&&(this.outputs[e].hidden=!1)}));const s={left:[],right:[]},a={...t.inputs,...t.outputs};Object.entries(a).forEach((([e,t])=>{if("input"===t.direction||"inout"===t.direction){if(!(e in this.inputs)){const n=new i.gZ(e);Object.assign(n,t),this.addInput(e,n)}this.inputs[e].side=t.side,this.inputs[e].sidePosition=t.sidePosition,this.inputs[e].externalName=t.externalName,this.inputs[e].direction=t.direction,s[t.side].push(t.sidePosition)}else if("output"===t.direction){if(!(e in this.outputs)){const n=new i.gZ(e);Object.assign(n,t),this.addOutput(e,n)}this.outputs[e].side=t.side,this.outputs[e].sidePosition=t.sidePosition,this.outputs[e].externalName=t.externalName,this.outputs[e].direction=t.direction,s[t.side].push(t.sidePosition)}else{if(!(e in this.inputs)){const n=new c.A(e);Object.assign(n,t),this.addInput(e,n)}this.inputs[e].externalName=t.externalName}}));const d=e=>{Object.entries(e).forEach((([e,t])=>{if(e.startsWith("property_"))return;if(e in a)return;if(!s[t.side].includes(t.sidePosition))return;const n=Math.max(...s[t.side]);t.sidePosition=n+1,s[t.side].push(n+1)}))};return d(this.inputs),d(this.outputs),void 0===e.position&&(this.position=void 0),this.relatedGraphs=e.relatedGraphs,r}onPlaced(){super.onPlaced();const e=([e,t])=>this.graphInstance?.editor?.editorManager?.externalApplicationManager?.request(e,t),t=e=>this.graphInstance?.editor.switchToRelatedGraph(e);Object.entries(this.inputs).filter((([e,t])=>e.startsWith("property_"))).filter((([e,t])=>"ButtonInterface"===t.componentName)).forEach((([n,i])=>"button-graph"===i.type?i.events.updated.subscribe(this,t):i.events.updated.subscribe(this,e)))}onDestroy(){[...Object.values(this.inputs),...Object.values(this.outputs)].forEach((e=>{Object.values(e.events).forEach((t=>{t.unsubscribe(this),t.unsubscribe(e)}))}))}}const E=e=>{function t(e){return()=>{const t=new i.gZ(e.name);return Object.assign(t,e),t}}return[Object.fromEntries(Object.entries(e.inputs).map((([e,n])=>[e,t(n)]))),Object.fromEntries(Object.entries(e.outputs).map((([e,n])=>[e,t(n)])))]};function x(e,t,n,i,r,s,a,c="",d=[],u=[],l=[],p=300){const f=(0,o.vS)(n);if(!f.success)return f.value.map((t=>`Node ${e} invalid. ${t}`));const h=(0,o.Cy)(n,r,s);if(Array.isArray(h)&&h.length)return h.map((t=>`Node ${e} invalid. ${t}`));const[g,m]=E(h),y=w([...i,...f.value]);if(Array.isArray(y)&&y.length)return y.map((t=>`Node ${e} invalid. ${t}`));const v={...g,...A(y)};return class extends ${constructor(){super(e,t,v,m,a,c,d,u,l,p)}}}function I(e){const t=Object.create(null),n=[];return e?.forEach((([,e])=>{t[e.externalName]=(t[e.externalName]??0)+1,1===t[e.externalName]?n.push(e):n.push(`Interface '${e.externalName}' is repeated ${t[e.externalName]} times.`)})),n}function P(e,t){v.ir.isRegistered(e.id)&&v.ir.getRegisteredInterface(e.id).sharedInterface!==e&&v.ir.getRegisteredInterface(e.id).sharedInterface.id===e.id&&v.ir.getRegisteredInterface(e.id).sharedInterfaceGraphId===t&&v.ir.deleteRegisteredInterface(e.id),v.ir.isRegistered(e.id)||v.ir.registerInterface(e,t)}function j(e,t=[],n=[]){const i=["input_","inout_","output_"],r=I([...e.map((e=>Object.entries({...e.inputs,...e.outputs}))).flat()].filter((([e])=>i.some((t=>e.startsWith(t))))).filter((([,e])=>e.externalName))),s=r.filter((e=>"string"==typeof e));if(s.length)return s;const a=[];r.forEach((i=>{const r=e[0].graph.id;P(i,r);const o="output"===i.direction?n:t,s=o.findIndex((e=>e.id===i.id));-1===s?a.push({name:i.externalName,id:i.id,externalName:void 0,side:i.side,direction:i.direction,sidePosition:void 0}):(o[s].name=i.externalName,a.push(o[s]))}));const c=(0,o.i0)(a,{});return Array.isArray(c)&&c.length?c:{inputs:Object.values(c.inputs),outputs:Object.values(c.outputs)}}function S(e){const t=I(e.map((e=>Object.entries(e.inputs))).flat().filter((([e])=>e.startsWith("property_"))).filter((([,e])=>e.externalName))),n=t?.filter((e=>"string"==typeof e));if(n.length)return n;const i=[];return t.forEach((t=>{P(t,e[0].graph.id),i.push({name:t.externalName,id:t.id,externalName:void 0,type:t.type,value:t.value,description:t.description,default:t.default,min:t.min,max:t.max,step:t.step,values:t.items,dtype:t.dtype,override:t.override,readonly:t.readonly})})),i}function N(e,t,n,i){const r=e.map((e=>O(e))),o=r.filter((e=>"string"==typeof e));if(o.length)return o;const s={name:n,nodes:r,connections:t,inputs:[],outputs:[]};return new y.A(s,i)}},8328:(e,t,n)=>{n.d(t,{c:()=>o,x:()=>r});var i=n(50953);const r=(0,i.Kh)({configurationMenu:{visible:!1,addNode:!1,placeNode:!1},propertyMenu:!1,interfaceMenu:!1,propertyListMenu:!1,interfaceListMenu:!1,layerMenu:!1}),o=(0,i.Kh)({nodeData:{name:"Custom Node",category:"Default category",layer:"",description:"",color:""},properties:[],interfaces:[],success:!1})},10892:(e,t,n)=>{n.d(t,{A:()=>a});var i=n(44726),r=n(71095),o=n(65111),s=n(39024);i.use(o),i.use(r);class a extends s.A{availableAlgorithms=["cola","dagre-network-simplex","dagre-tight-tree","dagre-longest-path","random","grid","circle","concentric","breadthfirst","cose"];async calculate(e){const t=i({elements:{nodes:e.nodes.map((e=>({data:{id:e.id,width:e.width,height:e.height}}))),edges:e.connections.map((e=>({data:{id:e.id,source:e.from,target:e.to}})))},style:[{selector:"node",style:{shape:"rectangle",width:"data(width)",height:"data(height)"}}],styleEnabled:!0}),n={name:this.activeAlgorithm};switch(this.activeAlgorithm){case"random":n.boundingBox={x1:0,y1:0,w:2e3,h:2e3};break;case"grid":n.avoidOverlapPadding=150;break;case"cose":n.nodeOverlap=1e3,n.idealEdgeLength=e=>300;break;case"cola":n.nodeSpacing=e=>150;break;case"dagre-network-simplex":case"dagre-tight-tree":case"dagre-longest-path":{const[e,...t]=this.activeAlgorithm.split("-");n.nodeSep=50,n.rankSep=100,n.ranker=t.join("-"),n.name=e;break}}const r=t.layout(n);return r.run(),["cose","cola"].includes(this.activeAlgorithm)&&await r.promiseOn("layoutstop"),{...e,nodes:t.nodes().map((e=>({id:e.id(),position:{x:e.position().x-e.width()/2,y:e.position().y-e.height()/2}})))}}}},14121:(e,t,n)=>{n.d(t,{Cy:()=>l,Sb:()=>a,W9:()=>c,Yg:()=>r,i0:()=>d,vS:()=>u});const i="inout",r="count";function o(e,t,n=void 0){const i={};return Object.assign(i,e),i.name=n??e.name,void 0!==i.type&&(i.type="string"==typeof e.type||e.type instanceof String?[e.type]:e.type),i.componentName="NodeInterface",i.hidden=t,i.originalSide=i.side,i.originalSidePosition=i.sidePosition,i}function s(e,t=!1){const n=[],r={input:{},inout:{},output:{}};e.forEach((e=>{if(Object.prototype.hasOwnProperty.call(e,"dynamic"))return;const o=JSON.parse(JSON.stringify(e)),s=e.direction??i;if(o.direction=s,void 0!==e.array){const[t,i]=e.array;for(let a=t;a<i;a+=1){const t=`${e.name}[${a}]`;void 0!==r[s][t]&&n.push(`Interface named '${t}' of direction '${s}' is a duplicate.`),o.externalName=e.externalName?`${e.externalName}[${a}]`:void 0,r[s][t]=JSON.parse(JSON.stringify(o))}}else void 0!==r[s][e.name]&&n.push(`Interface named '${e.name}' of direction '${s}' is a duplicate.`),r[s][e.name]=o;if(t){const e=[];o.interfaces.forEach((t=>{const n=t.direction??i;if(void 0!==t.array){const[i,r]=t.array;for(let o=i;o<r;o+=1){const i=`${n}_${t.name}[${o}]`;e.push(i)}}else{const i=`${n}_${t.name}`;e.push(i)}})),o.interfaces=e}}));const o=Object.fromEntries(Object.entries(r.inout).filter((([e,t])=>{const o=t.direction??i,s=Object.keys(r.output).includes(e)||Object.keys(r.input).includes(e);return s&&n.push(`Interface named '${e}' of direction '${o}' is a duplicate. There already exists an input or output of this name.`),!s})));return r.inout=o,r.input={...r.input,...r.inout},delete r.inout,r.input=Object.fromEntries(Object.entries(r.input).map((([e,t])=>[`${t.direction}_${e}`,t]))),r.output=Object.fromEntries(Object.entries(r.output).map((([e,t])=>[`${t.direction}_${e}`,t]))),n.length?n:r}function a(e,t,n){const i=[],r=new Set;return e.forEach((e=>{const o=t[e]?.interfaces??n[e]?.interfaces,s=e.slice(0,e.indexOf("_")),a=e.slice(e.indexOf("_")+1);o.forEach((e=>{if(r.has(e)){const t=e.slice(0,e.indexOf("_")),n=e.slice(e.indexOf("_")+1);i.push([n,t,a,s])}else r.add(e)}))})),i}function c(e,t,n){const i=a(e,t,n),r=[];return i.forEach((([e,t,n,i])=>{r.push(`Interface of name '${e}' and direction '${t}' has been reused by interface group named '${n}' of direction '${i}'. Make sure your interface groups are disjoint.`)})),r}function d(e,t){const n={left:{},right:{}},i=[];Object.entries({...e,...t}).forEach((([e,t])=>{"right"===t.side||void 0===t.side&&"output"===t.direction?(n.right[e]={...t},n.right[e].side="right"):("left"===t.side||void 0===t.side&&"output"!==t.direction)&&(n.left[e]={...t},n.left[e].side="left")}));const r=e=>e.slice(e.indexOf("_")+1),o=new Set,s=new Set;if(Object.entries(n.left).forEach((([e,t])=>{void 0!==t.sidePosition&&(o.has(t.sidePosition)&&i.push(`Interface named '${r(e)}' of direction '${t.direction}' has invalid sidePosition value '${t.sidePosition}'. There already exists an input or output with this sidePosition.`),o.add(t.sidePosition))})),Object.entries(n.right).forEach((([e,t])=>{void 0!==t.sidePosition&&(s.has(t.sidePosition)&&i.push(`Interface named '${r(e)}' of direction '${t.direction}' has invalid sidePosition value '${t.sidePosition}'. There already exists an input or output with this sidePosition.`),s.add(t.sidePosition))})),i.length)return i;let a=0,c=0;return Object.entries(n.left).forEach((([,e])=>{e.sidePosition=(e=>{if(void 0===e.sidePosition){for(;o.has(a);)a+=1;return o.add(a),a}return e.sidePosition})(e)})),Object.entries(n.right).forEach((([,e])=>{e.sidePosition=(e=>{if(void 0===e.sidePosition){for(;s.has(c);)c+=1;return s.add(c),c}return e.sidePosition})(e)})),{inputs:Object.fromEntries(Object.entries({...n.left,...n.right}).filter((([,e])=>"output"!==e.direction))),outputs:Object.fromEntries(Object.entries({...n.left,...n.right}).filter((([,e])=>"output"===e.direction)))}}function u(e){const t=[],n=[];return e.forEach((e=>{Object.prototype.hasOwnProperty.call(e,"dynamic")&&(Array.isArray(e.dynamic)&&2===e.dynamic.length&&Number.isInteger(e.dynamic[0])&&Number.isInteger(e.dynamic[1])?n.push({name:`${e.name} ${e.direction} ${r}`,type:"integer",min:e.dynamic[0],max:e.dynamic[1],default:e.dynamic[0],interfaceType:e.type,interfaceMaxConnectionCount:e.maxConnectionCount}):!0===e.dynamic?n.push({name:`${e.name} ${e.direction} ${r}`,type:"integer",min:0,default:0,interfaceType:e.type,interfaceMaxConnectionCount:e.maxConnectionCount}):t.push(`Interface '${e.name}' has invalid 'dynamic' attribute. It should be either a boolean or an array with two integer elements.`))})),t.length?{success:!1,value:t}:{success:!0,value:n}}function l(e,t,n){let r=[];const a=s(e);if(Array.isArray(a)&&a.length)return a;if(t.forEach((e=>{const t=e.direction??i;e.interfaces.forEach((n=>{const o=n.direction??i;if(void 0!==n.array){const[i,s]=n.array;for(let c=i;c<s;c+=1){const i=`${o}_${n.name}[${c}]`;Object.keys({...a.input,...a.output}).includes(i)||r.push(`Interface named '${n.name}[${c}]' of direction '${o}' used for interface group '${e.name}' of direction '${t}' does not exist.`)}}else{const i=`${o}_${n.name}`;Object.keys({...a.input,...a.output}).includes(i)||r.push(`Interface named '${n.name}' of direction '${o}' used for interface group '${e.name}' of direction '${t}' does not exist.`)}}))})),r.length)return r;const u=s(t,!0);if(Array.isArray(u)&&u.length)return u;const l=new Set;Object.values({...u.input,...u.output}).forEach((e=>{e.interfaces.forEach((e=>l.add(e)))}));const p=n.map((e=>`${e.direction??i}_${e.name}`));if(r=c(p,{...u.input,...a.input},{...u.output,...a.output}),r.length)return r;a.input=Object.fromEntries(Object.entries(a.input).filter((([e])=>!l.has(e)))),a.output=Object.fromEntries(Object.entries(a.output).filter((([e])=>!l.has(e))));const f=d({...a.input,...u.input},{...a.output,...u.output});if(Array.isArray(f)&&f.length)return f;const h=e=>e.slice(e.indexOf("_")+1),g={inputs:{},outputs:{}};return Object.entries(f.inputs).forEach((([e,t])=>{void 0!==t.interfaces?g.inputs[e]=o(t,!p.includes(e),h(e)):g.inputs[e]=o(t,!1,h(e))})),Object.entries(f.outputs).forEach((([e,t])=>{void 0!==t.interfaces?g.outputs[e]=o(t,!p.includes(e),h(e)):g.outputs[e]=o(t,!1,h(e))})),g}},22048:(e,t,n)=>{n.d(t,{A:()=>i});class i{static instance=void 0;currentSpecification=void 0;includedSpecification=void 0;unresolvedSpecification=void 0;constructor(){if(void 0!==i.instance)throw new Error("Error - use Specification.getInstance()")}static getInstance(){return i.instance||(i.instance=new i),i.instance}getNodeSpecification(e){if(void 0!==this.currentSpecification)return this.currentSpecification.nodes.find((t=>t.name===e))}}},23986:(e,t,n)=>{n.d(t,{A:()=>s});var i=n(63282),r=n(25504),o=n(9459);function s(e,t,n,s=""){e.removeSchema("root").removeSchema(t.$id).addSchema(t,"root");const a=e.getSchema(`root${s}`);if(void 0===a)return[`Invalid value of "reference" parameter: ${s}`];const c="string"==typeof n;let d;try{d=c?o.parse(n):n}catch(e){return[`Not a proper JSON file: ${e.toString()}`]}return a(d)?[]:(a.errors?.map((e=>{const o=`${t.$id.replace(/((_params)|(_returns))?(_schema)?(.json)?$/,"")}${e.instancePath}`;let s="";if(c){const t=r.parse(n),i=t.pointers[e.instancePath].value.line+1,o=t.pointers[e.instancePath].valueEnd.line+1;s=i===o?`Line ${i} -`:`Lines ${i}-${o} -`}switch(e.keyword){case"enum":return`${s} ${o} ${e.message} - ${(0,i.stringify)(e.params.allowedValues)}`;case"additionalProperties":return`${s} ${o} ${e.message} - ${(0,i.stringify)(e.params.additionalProperty)}`;case"const":return`${s} ${o} ${e.message} - ${(0,i.stringify)(e.params.allowedValue)}`;case"unevaluatedProperties":return`${s} ${o} ${e.message} - ${(0,i.stringify)(e.params.unevaluatedProperty)}`;case"not":case"oneOf":return"";default:return`${s} ${o} ${e.message}`}}))??[]).filter((e=>""!==e))}},30920:(e,t,n)=>{n.d(t,{A:()=>r});var i=n(39024);class r extends i.${availableAlgorithms=["NoLayout"];activeAlgorithm="NoLayout";calculate(e){const t=e.nodes.map((e=>({...e,position:{x:0,y:0}})));return{...e,nodes:t}}}},34076:(e,t,n)=>{n.d(t,{Ay:()=>s,FC:()=>a,NV:()=>d,c5:()=>c});var i=n(15215),r=n(20641),o=n(93617);const s=(()=>{const e=new URLSearchParams(window.location.search).get("backend");return null!==e?e:(window.location.protocol,null)})(),a={OK:0,ERROR:1,PROGRESS:2,WARNING:3},c={EXCEPTION_RAISED:-1,EXTERNAL_APPLICATION_NOT_CONNECTED:-2,NEWER_SESSION_AVAILABLE:-3},d=(e,t,...n)=>(0,i.sH)(void 0,[e,t,...n],void 0,(function*(e,t,{show:n,log:i}={show:!0,log:!0}){n&&(t.emit(!0),yield(0,r.dY)());try{yield e()}catch(e){i&&o.A.terminalLog("error","Unexpected error",e.message)}finally{t.emit(!1),yield(0,r.dY)()}}))},35127:(e,t,n)=>{n.d(t,{d:()=>u,iP:()=>l,xv:()=>d});var i=n(50953);const r=(()=>{try{const e=Math.random().toString(36),t=Math.random().toString(36);return localStorage.setItem(e,t),localStorage.removeItem(e),!0}catch{return!1}})(),o=new Map,s=e=>r?localStorage.getItem(e):o.get(e)??null,a=(e,t)=>{r?localStorage.setItem(e,t):o.set(e,t)},c=e=>{r?localStorage.removeItem(e):o.delete(e)},d=(0,i.Kh)({notifications:JSON.parse(s("notifications"))||[],add(e){this.notifications.push(e),a("notifications",JSON.stringify(this.notifications))},remove(){c("notifications"),this.notifications=[]},removeOne(e){const t=this.notifications.filter(((t,n)=>e!==n));a("notifications",JSON.stringify(t)),this.notifications=t}}),u="Terminal",l=(0,i.Kh)({logs:{Terminal:JSON.parse(s("logs"))||[]},readOnly:{Terminal:!0},add(e,t=u){this.logs[t].push(e),t===u&&a("logs",JSON.stringify(this.logs[t]))},isReadOnly(e=u){return this.readOnly[e]},addParsed(e,t,n=u){let i=e;t?(("string"==typeof t||t instanceof String)&&(t=[t]),i+=":",t.forEach((e=>{i+="\n",i+="    ",i+=e}))):i+=".",this.add(i,n)},clear(e=u){e===u&&c("logs"),this.logs[e]=[]},remove(e=u){this.clear(e),delete this.logs[e],delete this.readOnly[e]},exists(e=u){return e in this.logs},getInstances(){return Object.keys(this.logs)},createTerminalInstance(e,t=!0){return!Object.keys(this.logs).includes(e)&&(this.logs[e]=[],this.readOnly[e]=t,!0)},show:!1,manager:null})},39021:(e,t,n)=>{n.d(t,{$k:()=>f,Fo:()=>w,GI:()=>y,J7:()=>v,RM:()=>p,Rj:()=>g,hm:()=>m,iv:()=>h,zM:()=>l});var i=n(63491),r=n(34580),o=n(14121),s=n(8328),a=n(8239),c=n(93617),d=n(41857);function u(){(0,d.$4)(!0);const e=r.Ay.getEditorManagerInstance(),t=s.c.nodeData,n=s.c.editedType;let i=r.kx;if(void 0!==n){const t=e._unregisterNodeType(n);if(t.length)return void c.A.terminalLog("error","Error when registering the node",t);i=r.L6}const o=e.addNodeToEditorSpecification({name:t.name,layer:t.layer,category:t.category,color:t.color,description:t.description,interfaces:s.c.interfaces,properties:s.c.properties,style:i},n,!1);void 0!==o.errors&&o.errors.length?c.A.terminalLog("error","Error when registering the node",o.errors):(0,d.$4)(!1)}function l(e,t=!1){const{viewModel:n}=(0,i.if)(),{editor:r}=n.value,o=Array.from(r.graphs).map((e=>e.nodes)).flat();return t?o.filter((t=>{var n;return null===(n=t.extends)||void 0===n?void 0:n.includes(e)})):o.filter((t=>t.type===e))}function p(){const e=r.Ay.getEditorManagerInstance(),t=s.c.nodeData,n=s.c.editedType;if(e.baklavaView.editor.nodeTypes.has(t.name)&&(void 0===n||n!==t.name)){const e=[`Node of type ${t.name} already exists. Please pick another type`];return c.A.terminalLog("error","Error when creating a node",e),e}return u(),[]}function f(){(0,d.$4)(!0);const e=s.c.nodeData;return l(s.c.editedType).forEach((t=>{t.type===t.title?t.title=e.name:t.highlightedType=e.name,t.type=e.name,t.layer=e.layer,t.category=e.category,t.color=e.color,t.description=e.description})),u(),(0,d.$4)(!1),[]}function h(e,t,n=!1){if(void 0===t)return[];let i=[];const r=(0,a.$9)(t);if(Array.isArray(r)&&r.length)return r;const o=(0,a.eC)(r);return e.forEach((e=>{const t=e.save();Object.keys(o).forEach((t=>{const i=o[t]();n?e.removeInput(t,i):e.addInput(t,i),e.inputs=e.inputs}));const r=e.load(t);i=[...i,...r]})),i}function g(e,t,n=!1){if(void 0===t)return[];let i=[];const r=(0,o.Cy)(t,[],[]);if(Array.isArray(r)&&r.length)return r;const[s,c]=(0,a.j4)(r);return e.forEach((e=>{const t=e.save();Object.keys(s).forEach((t=>{const i=s[t]();n?e.removeInput(t,i):e.addInput(t,i),e.inputs=e.inputs})),Object.keys(c).forEach((t=>{const i=c[t]();n?e.removeOutput(t,i):e.addOutput(t,i),e.outputs=e.outputs}));const r=e.load(t);i=[...i,...r]})),i}function m(e){var t;const n=s.c.editedType,i=r.Ay.getEditorManagerInstance();let o=i.validateNodeProperty(e);if(o.length)return void c.A.terminalLog("error","Invalid property",o);const a=l(n);void 0!==a?(s.c.properties.push(e),o=h(a,s.c.properties),o.length?c.A.terminalLog("error","Invalid property",o):((null!==(t=i.specification.currentSpecification.nodes.filter((e=>{var t;return null===(t=e.extends)||void 0===t?void 0:t.includes(n)})))&&void 0!==t?t:[]).forEach((t=>{var n;t.properties=[...null!==(n=t.properties)&&void 0!==n?n:[],e],h(l(t.name),[e])})),u())):c.A.terminalLog("error","Node not found",`Node of type ${n} not found`)}function y(e){var t,n,i,o,a;const d=s.c.editedType,p=r.Ay.getEditorManagerInstance(),f=l(d);if(void 0===f)return void c.A.terminalLog("error","Node not found",`Node of type ${d} not found`);function g(e,t,n){const i=[];return t.forEach((e=>{const t=e.properties.filter((e=>n.includes(e.name)));e.properties=e.properties.filter((e=>!t.includes(e))),i.push(...t.map((e=>e.externalName)).filter((e=>e)))})),i}s.c.properties=s.c.properties.filter((t=>!e.includes(t))),h(f,e,!0),(null!==(t=p.specification.currentSpecification.nodes.filter((e=>{var t;return null===(t=e.extends)||void 0===t?void 0:t.includes(d)})))&&void 0!==t?t:[]).forEach((t=>{var n,i;t.properties=null!==(i=null===(n=t.properties)||void 0===n?void 0:n.filter((t=>!e.some((e=>e.name===t.name)))))&&void 0!==i?i:[],h(l(t.name),e,!0)}));const m=e.map((e=>e.name));[...null!==(n=p.specification.unresolvedSpecification.graphs)&&void 0!==n?n:[],...null!==(i=p.specification.currentSpecification.graphs)&&void 0!==i?i:[]].forEach((e=>{let t=g(0,e.nodes.filter((e=>e.name===d)),m);for(;t.length>0;)t=g(0,e.nodes,t)})),[...null!==(o=p.specification.unresolvedSpecification.nodes)&&void 0!==o?o:[],...null!==(a=p.specification.currentSpecification.nodes)&&void 0!==a?a:[]].forEach((e=>{p.refreshSubgraph(e)})),u()}function v(e){var t;const n=s.c.editedType,i=r.Ay.getEditorManagerInstance();let o=i.validateNodeInterface(e);if(o.length)return void c.A.terminalLog("error","Invalid interface",o);const a=l(n);void 0!==a?(s.c.interfaces.push(e),o=g(a,s.c.interfaces),o.length?c.A.terminalLog("error","Invalid interface",o):((null!==(t=i.specification.currentSpecification.nodes.filter((e=>{var t;return null===(t=e.extends)||void 0===t?void 0:t.includes(n)})))&&void 0!==t?t:[]).forEach((t=>{var n;t.interfaces=[...null!==(n=t.interfaces)&&void 0!==n?n:[],e],g(l(t.name),[e])})),u())):c.A.terminalLog("error","Node not found",`Node of type ${n} not found`)}function w(e){var t,n,i,o,a;const d=s.c.editedType,p=r.Ay.getEditorManagerInstance(),f=l(d);if(void 0===f)return void c.A.terminalLog("error","Node not found",`Node of type ${d} not found`);function h(e,t,n){const i=[];return t.forEach((t=>{const r=t.interfaces.filter((e=>n.includes(e.name))),o=r.map((e=>e.id));e.connections=e.connections.filter((e=>!o.includes(e.from)&&!o.includes(e.to))),t.interfaces=t.interfaces.filter((e=>!o.includes(e.id))),i.push(...r.map((e=>e.externalName)).filter((e=>e)))})),i}s.c.interfaces=s.c.interfaces.filter((t=>!e.includes(t))),g(f,e,!0),(null!==(t=p.specification.currentSpecification.nodes.filter((e=>{var t;return null===(t=e.extends)||void 0===t?void 0:t.includes(d)})))&&void 0!==t?t:[]).forEach((t=>{var n,i;t.interfaces=null!==(i=null===(n=t.interfaces)||void 0===n?void 0:n.filter((t=>!e.some((e=>e.name===t.name)))))&&void 0!==i?i:[],g(l(t.name),e,!0)}));const m=e.map((e=>e.name));[...null!==(n=p.specification.unresolvedSpecification.graphs)&&void 0!==n?n:[],...null!==(i=p.specification.currentSpecification.graphs)&&void 0!==i?i:[]].forEach((e=>{const t=e.nodes.filter((e=>e.name===d));let n=h(e,t,m);for(;n.length>0;)n=h(e,e.nodes,n)})),[...null!==(o=p.specification.unresolvedSpecification.nodes)&&void 0!==o?o:[],...null!==(a=p.specification.currentSpecification.nodes)&&void 0!==a?a:[]].forEach((e=>{p.refreshSubgraph(e)})),u()}},39024:(e,t,n)=>{n.d(t,{$:()=>r,A:()=>i});class i{availableAlgorithms=[];constructor(){if(this.constructor===i)throw new Error("Can't initialize base class instance")}chooseAlgorithm(e){if(!this.availableAlgorithms.includes(e))throw new Error(`Could not find ${e} in ${this.constructor.name} engine.\n                Available algorithms: ${this.availableAlgorithms}`);this.activeAlgorithm=e}async calculate(e){throw new Error("Method calculate() must be implemented by layout engine")}}class r extends i{constructor(){if(super(),this.availableAlgorithms=[this.constructor.name],this.activeAlgorithm=this.constructor.name,this.chooseAlgorithm=void 0,this.constructor===r)throw new Error("Can't initialize base class instance")}}},41426:(e,t,n)=>{function i(e,t){const n=e;let i=-n;return e=>{Date.now()-i<n&&t(e),i=Date.now()}}n.d(t,{A:()=>i})},45825:(e,t,n)=>{n.d(t,{Q:()=>o,i:()=>r});var i=n(63491);function r(e){return t=>Math.round(t/e.value)*e.value}function o(e){const{graph:t}=(0,i.uU)();return(n,i,r)=>{const o=t.value.nodes.filter((e=>e.id!==i&&!r.includes(e.id))).map((t=>t.position[e])).filter((e=>Math.abs(n-e)<100));return 0!==o.length?Math.min(...o):void 0}}},51645:(e,t,n)=>{n.d(t,{Ay:()=>we,D7:()=>ae});var i={};n.r(i),n.d(i,{connections_change:()=>_,frontend_specification_get:()=>I,frontend_status_get:()=>x,graph_change:()=>C,graph_get:()=>P,metadata_change:()=>L,node_get:()=>R,nodes_change:()=>N,nodes_highlight:()=>Z,notification_send:()=>K,position_change:()=>S,progress_change:()=>M,properties_change:()=>j,properties_get:()=>k,register_external_frontend:()=>X,return_from_subgraph:()=>Q,specification_change:()=>V,specification_expand:()=>Y,specification_graph_change:()=>z,specification_preprocess:()=>U,terminal_add:()=>q,terminal_clear:()=>W,terminal_get_instances:()=>B,terminal_hide:()=>F,terminal_remove:()=>H,terminal_show:()=>G,terminal_view:()=>J,terminal_write:()=>D,viewport_center:()=>T});var r=n(15215),o=n(13773),s=n(94541),a=n.n(s),c=n(93617),d=n(34076),u=n(28316),l=n(30468),p=n(63491),f=n(42302),h=n(881),g=n(34580),m=n(35127),y=n(19071),v=n(323);function w(e,t=!0){if(m.iP.exists(e)!==t)throw new Error(`Terminal instance of name '${e} ${t?"does not exist":"already exists"}`)}var b=n(70380);const A=g.Ay.getEditorManagerInstance();function O(e){const{viewModel:t}=(0,p.if)(),n=[...t.value.editor.graphs].find((t=>t.id===e));if(void 0===n)throw new Error(`Graph with id '${e}' does not exist.`);return n}function $(e,t){const n=O(e).nodes.find((e=>e.id===t));if(void 0===n)throw new Error(`Node with id '${t}' does not exist.`);return n}function E(e,t,n){let i;if(void 0!==t){if(i=Object.values(e.inputs).find((e=>e.id===t)),void 0===i||void 0!==i.side)throw new Error(`Property with id '${t}' does not exist.`)}else if(i=Object.values(e.inputs).find((e=>e.name===n)),void 0===i||void 0!==i.side)throw new Error(`Property with name '${n}' does not exist.`);return i}function x(){return{status:"ready"}}function I(e){const t=y.Ht;return t.graph=!!e&&e.graph,t.minify=!!e&&e.minify,{specification:t.getSave()}}function P(){return{dataflow:A.saveDataflow()}}function j(e){const t=$(e.graph_id,e.node_id);for(const n of e.properties)E(t,n.id,n.name);for(const n of e.properties)E(t,n.id,n.name).value=n.new_value}function S(e){const t=$(e.graph_id,e.node_id);t.position.x=e.position.x,t.position.y=e.position.y}function N(e){return(0,r.sH)(this,void 0,void 0,(function*(){const{viewModel:t}=(0,p.if)(),n=O(e.graph_id);e.nodes.added.forEach((e=>{const i=t.value.editor.nodeTypes.get(e.name);if(!i)throw new Error(`Node type not found for name ${e.name}`);{const r=new i.type;r.id=e.id,e.color&&t.value.editor.setNodeColor(e.id,e.color),n.addNode(r);const o=r.load(e);if(Array.isArray(o)&&o.length)throw new Error(o.join("\n"))}})),e.nodes.deleted.forEach((t=>{var i;const r=$(e.graph_id,t);null===(i=e.remove_with_connections)||void 0===i||i?n.removeNode(r):n.removeNodeOnly(r)}))}))}function _(e){return(0,r.sH)(this,void 0,void 0,(function*(){const t=O(e.graph_id);e.connections.added.forEach((e=>{const n=t.findNodeInterface(e.from);if(!n)throw new Error(`Interface with id ${e.from} does not exist`);const i=t.findNodeInterface(e.to);if(!i)throw new Error(`Interface with id ${e.to} does not exist`);if(!t.addConnection(n,i))throw new Error(`Connection from ${e.from} to ${e.to} cannot be created`)})),e.connections.deleted.forEach((n=>{t.removeConnection(function(e,t,n){const i=O(e).connections.find((e=>e.from.id===t&&e.to.id===n));if(void 0===i)throw new Error(`Connection from ${t} to ${n} does not exist.`);return i}(e.graph_id,n.from,n.to))}))}))}function C(e){return(0,r.sH)(this,void 0,void 0,(function*(){const t=(0,v.A)();yield t.conditionalLoadingScreen(e.loadingScreen,(()=>(0,r.sH)(this,void 0,void 0,(function*(){return t.updateDataflow(e.dataflow)}))))}))}function k(e){return(0,r.sH)(this,void 0,void 0,(function*(){const t=$(e.graph_id,e.node_id),n=[];if(void 0===e.properties){for(const e of Object.values(t.inputs))void 0===e.side&&n.push({id:e.id,name:e.name,value:e.value});return n}for(const i of e.properties){const e=E(t,i.id,i.name);n.push({id:e.id,name:e.name,value:e.value})}return n}))}function R(e){return(0,r.sH)(this,void 0,void 0,(function*(){return{node:$(e.graph_id,e.node_id).save()}}))}function M(e){const t=h.A.get(e.method);if(!t.inProgress)throw new Error("No run in progress");if(!t.progressBar)throw new Error(`Progress bar does not exist for method: ${e.method}`);if(-1!==e.progress){if(e.progress>100||e.progress<0)throw new Error(`Progress has to be in [0, 100] or -1. Received: ${e.progress}`);t.progressBar.style.width=`${e.progress}%`,t.progressBar.classList.remove("animate")}else t.progressBar.classList.add("animate")}function L(e){A.updateMetadata(e.metadata,!0)}function T(){A.baklavaView.editor.centerZoom()}function q(e){if(!1===m.iP.createTerminalInstance(e.name,e.readonly))throw new Error(`Terminal instance of name '${e.name}' already exists`)}function H(e){w(e.name,!0),m.iP.remove(e.name)}function D(e){e.name in m.iP.logs||m.iP.createTerminalInstance(e.name),m.iP.add(e.message,e.name)}function W(e){var t;const n=null!==(t=null==e?void 0:e.name)&&void 0!==t?t:m.d;w(n,!0),m.iP.clear(n)}function F(){var e;null===(e=m.iP.manager)||void 0===e||e.hide()}function G(e){var t,n;const i=null!==(t=null==e?void 0:e.name)&&void 0!==t?t:m.d;void 0!==i&&w(i,!0),null===(n=m.iP.manager)||void 0===n||n.show(i)}function J(e){var t,n;null===(t=e.names)||void 0===t||t.forEach((e=>w(e,!0))),null===(n=m.iP.manager)||void 0===n||n.view(e)}function B(){return m.iP.getInstances()}function K(e){c.A.terminalLog(e.type,e.title,e.details)}function V(e){return(0,r.sH)(this,void 0,void 0,(function*(){const t=(0,v.A)();yield t.conditionalLoadingScreen(e.loadingScreen,(()=>(0,r.sH)(this,void 0,void 0,(function*(){return t.updateSpecification(e.specification,e)}))))}))}function z(e){return(0,r.sH)(this,void 0,void 0,(function*(){const t=(0,v.A)(),n=e.tryMinify?e.dataflow:void 0;yield t.conditionalLoadingScreen(e.loadingScreen,(()=>(0,r.sH)(this,void 0,void 0,(function*(){(yield t.updateSpecification(e.specification,Object.assign(Object.assign({},e),{tryMinify:n})))||(yield t.updateDataflow(e.dataflow))}))))}))}function U(e){return(0,r.sH)(this,void 0,void 0,(function*(){const t=(0,v.A)(),n=e.tryMinify?e.dataflow:void 0,i=yield t.preprocessSpecification(e.specification,Object.assign(Object.assign({},e),{tryMinify:n}));return i?{specification:i}:void 0}))}function Y(e){return(0,r.sH)(this,arguments,void 0,(function*({specification:e}){var t;const n=e=>{if(e.length>0)throw new Error(e.join("\n"))};n(g.Ay.validateSpecification(e));const i=null!==(t=e.graphs)&&void 0!==t?t:[],r=new Map(i.map((e=>[e.id,structuredClone(e)]))),o=e.nodes.map((e=>e.subgraphId)).filter(Boolean),s=i.filter((e=>!o.includes(e.id))),a=o.map((e=>({subgraphId:e,instanceId:e})));for(;a.length;){const{subgraphId:e,instanceId:t}=a.shift(),i=r.get(e),{state:c,errors:d}=(0,b.d)(i,{mode:"spec"});n(d),c.nodes.filter((e=>e.subgraph&&o.includes(e.subgraph))).forEach((e=>{const t=e.subgraph,n=(0,f.A)();e.subgraph=n,a.push({subgraphId:t,instanceId:n})})),delete c.graphLoadingState,s.push(Object.assign(Object.assign({},c),{id:t}))}return{specification:Object.assign(Object.assign({},e),{graphs:s})}}))}function Z(e){return(0,r.sH)(this,void 0,void 0,(function*(){const t=O(e.graph_id);t.selectedNodes=t.selectedNodes.filter((t=>!e.nodes.unselected.includes(t.id))),e.nodes.selected.forEach((n=>{const i=$(e.graph_id,n);t.selectedNodes.includes(i)||t.selectedNodes.push(i)}))}))}function X(){throw new Error('Frontend registering available only through "postMessage" interface.')}function Q(){const e=A.isInSubgraph();return e&&A.returnFromSubgraph(),{has_returned:e}}var ee=n(23986);class te extends o.JSONRPCServerAndClient{constructor(){super(...arguments),Object.defineProperty(this,"customMethodRegex",{enumerable:!0,configurable:!0,writable:!0,value:null}),Object.defineProperty(this,"customMethodReplace",{enumerable:!0,configurable:!0,writable:!0,value:null})}}class ne extends Error{constructor(e,t){super(e),Object.defineProperty(this,"data",{enumerable:!0,configurable:!0,writable:!0,value:t})}}const ie=/^custom_.*$/,re="dataflow_run",oe=new(a())({schemas:[u],allowUnionTypes:!0,strict:!0});function se(e){const t=l[e];return Object.entries(t).forEach((([e,t])=>{const n=t;n.params&&(n.params.$id=`${e}_params`),n.returns&&(n.returns.$id=`${e}_returns`)})),t}const ae=se("frontend_endpoints"),ce=se("backend_endpoints"),de=se("external_endpoints");let ue;try{[ae,ce,de].forEach((e=>{Object.entries(e).forEach((([e,t])=>{var n;ue=e,oe.compile(t.params),oe.compile(null!==(n=t.returns)&&void 0!==n?n:{})}))}))}catch(e){throw new Error(`Procedures specification schema '${ue}' is incorrect: ${e}`)}const le=(e,t,n)=>{const i=(0,ee.A)(oe,e,t);if(!i.length)return;const r="Request method does not match specification";if(void 0===n)throw new ne(r,i);return(0,o.createJSONRPCErrorResponse)(n,d.FC.ERROR,r,i)},pe=(e,t,n)=>(0,r.sH)(void 0,void 0,void 0,(function*(){var i;if(!(t.method in ae)){if(void 0!==t.id)return(0,o.createJSONRPCErrorResponse)(t.id,1,"Requested method does not exist");throw new Error("Requested method does not exist")}const r=ae[t.method],s=le(r.params,null!==(i=t.params)&&void 0!==i?i:{},t.id);if(s)return s;const a=yield e(t,n);if(void 0===t.id)return null;if(void 0!==(null==a?void 0:a.result)&&null!==r.returns){const e=le(r.returns,a.result,a.id);if(e)return e}return a}));let fe=1;const he=()=>fe++,ge=new Map;let me;const ye=e=>{var t;if(e.result&&e.id&&(null===(t=ge.get(e.id))||void 0===t?void 0:t.returns)){const t=le(ge.get(e.id).returns,e.result,e.id);if(t)return t}return e};class ve extends o.JSONRPCClient{receive(e){e=Array.isArray(e)?e:[e],super.receive(e.map(ye))}}const we={get jsonRPC(){return me||function(){me=new te(new o.JSONRPCServer,new ve(((e,t)=>(0,r.sH)(this,[e,t],void 0,(function*(e,{externalApp:t}){var n;if(!t)throw new Error("Missing backend.");const i=ie.test(e.method)?re:e.method;if(!(i in de)&&!(i in ce))throw new Error("Requested method not known");const r=i in de?de:ce,o=r[i],s=le(o.params,null!==(n=e.params)&&void 0!==n?n:{},e.id);if(s)throw new ne(s.error.message,s.error.data);e.id&&ge.set(e.id,o);const a=r===ce?"backend-api":"external-api";try{t.request(JSON.parse(JSON.stringify(e)),a)}catch(e){return Promise.reject(e)}return Promise.resolve()}))),he)),me.server.applyMiddleware(pe),Object.entries(i).forEach((([e,t])=>{"function"==typeof t&&e in ae?me.addMethod(e,t):"function"==typeof t&&c.A.showToast("warning",`Function ${e} was not registered as RPC method`)})),me.customMethodRegex=ie,me.customMethodReplace=re}(),me}}.jsonRPC},57565:(e,t,n)=>{n.d(t,{ir:()=>i});const i=new class{constructor(){Object.defineProperty(this,"exposedInterfaces",{enumerable:!0,configurable:!0,writable:!0,value:new Map})}clearRegistry(){this.exposedInterfaces.clear()}pushGraphIdToRegistry(e,t){const n=this.exposedInterfaces.get(e);if(!n)throw new Error(`Interface with id ${e} not found in the register.`);n.graphIds.push(t)}createSharedInterface(e){const t=this.exposedInterfaces.get(e.id);if(!t)throw new Error(`'Interface with id ${e.id} not found in the register.`);Object.defineProperty(e,"maxConnectionsCount",{get:()=>t.sharedInterface.maxConnectionsCount,set(e){t.sharedInterface.maxConnectionsCount=e}}),Object.defineProperty(e,"connectionCount",{get:()=>t.sharedInterface.connectionCount,set(e){t.sharedInterface.connectionCount=e}}),Object.defineProperty(e,"type",{get:()=>t.sharedInterface.type})}isRegistered(e){return this.exposedInterfaces.has(e)}getRegisteredInterface(e){if(!this.exposedInterfaces.has(e))throw new Error(`Interface of id ${e} is not registered.`);return this.exposedInterfaces.get(e)}deleteRegisteredInterface(e){if(!this.exposedInterfaces.has(e))throw new Error(`Interface of id ${e} is not registered.`);return this.exposedInterfaces.delete(e)}registerInterface(e,t){if(this.exposedInterfaces.has(e.id))throw new Error(`Trying to register an interface of id ${e.id}, but it is already registered.`);this.exposedInterfaces.set(e.id,{sharedInterface:e,sharedInterfaceGraphId:t,graphIds:[]})}}},93617:(e,t,n)=>{n.d(t,{A:()=>d,E:()=>c});var i=n(85246),r=n(35127),o=n(42231),s=n(34580);const a=(0,i.bO)({timeout:5e3,position:i.II.BOTTOM_RIGHT,icon:!1,closeButton:!1}),c={info:0,warning:1,error:2};class d{static NotificationHandler=!0;static defaultShowOption=!0;static setShowNotification(e){d.showNotifications=e}static setShowOption(e){d.defaultShowOption=e}static restoreShowNotification(){d.showNotifications=d.defaultShowOption}static showToast(e,t){const n={component:o.A,props:{type:e,message:t}};if(c[e]>=c[s.Ay.getEditorManagerInstance().baklavaView.logLevel?.toLowerCase()]&&d.showNotifications)a(n);else{const e=document.querySelector("#navbar-bell>.indicator");e&&(e.classList.remove("animate"),setTimeout((()=>e.classList.add("animate")),300))}r.xv.add({type:e,message:t})}static terminalLog(e,t,n){d.showToast(e,t),r.iP.addParsed(t,n)}}}}]);
//# sourceMappingURL=index-2d0f0968.bc98a765.js.map