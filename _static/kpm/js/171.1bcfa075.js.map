{"version":3,"file":"js/171.1bcfa075.js","mappings":"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","sources":["webpack://pipeline-manager/./node_modules/@baklavajs/core/dist/esm/connection.js","webpack://pipeline-manager/./node_modules/@baklavajs/core/dist/esm/utils.js","webpack://pipeline-manager/./node_modules/@baklavajs/core/dist/esm/node.js","webpack://pipeline-manager/./node_modules/@baklavajs/core/dist/esm/defineNode.js","webpack://pipeline-manager/./node_modules/@baklavajs/core/dist/esm/graph.js","webpack://pipeline-manager/./node_modules/@baklavajs/core/dist/esm/nodeInterface.js","webpack://pipeline-manager/./node_modules/@baklavajs/core/dist/esm/graphNode.js","webpack://pipeline-manager/./node_modules/@baklavajs/core/dist/esm/graphTemplate.js","webpack://pipeline-manager/./node_modules/@baklavajs/core/dist/esm/editor.js"],"sourcesContent":["import { v4 as uuidv4 } from \"uuid\";\nimport { BaklavaEvent } from \"@baklavajs/events\";\nexport class Connection {\n    constructor(from, to) {\n        this.destructed = false;\n        this.events = {\n            destruct: new BaklavaEvent(this),\n        };\n        if (!from || !to) {\n            throw new Error(\"Cannot initialize connection with null/undefined for 'from' or 'to' values\");\n        }\n        this.id = uuidv4();\n        this.from = from;\n        this.to = to;\n        this.from.connectionCount++;\n        this.to.connectionCount++;\n    }\n    destruct() {\n        this.events.destruct.emit();\n        this.from.connectionCount--;\n        this.to.connectionCount--;\n        this.destructed = true;\n    }\n}\n/**\n * This class is used for calculation purposes only.\n * It won't alter any state of the connected nodes\n */\nexport class DummyConnection {\n    constructor(from, to) {\n        if (!from || !to) {\n            throw new Error(\"Cannot initialize connection with null/undefined for 'from' or 'to' values\");\n        }\n        this.id = uuidv4();\n        this.from = from;\n        this.to = to;\n    }\n}\n","/** Key type is limited due to https://github.com/microsoft/TypeScript/pull/37457 */\nexport function mapValues(obj, fn) {\n    return Object.fromEntries(Object.entries(obj).map(([k, v]) => [k, fn(v)]));\n}\n","import { v4 as uuidv4 } from \"uuid\";\nimport { PreventableBaklavaEvent, BaklavaEvent, SequentialHook, } from \"@baklavajs/events\";\nimport { mapValues } from \"./utils\";\nexport class AbstractNode {\n    constructor() {\n        /** Unique identifier of the node */\n        this.id = uuidv4();\n        this.events = {\n            loaded: new BaklavaEvent(this),\n            beforeAddInput: new PreventableBaklavaEvent(this),\n            addInput: new BaklavaEvent(this),\n            beforeRemoveInput: new PreventableBaklavaEvent(this),\n            removeInput: new BaklavaEvent(this),\n            beforeAddOutput: new PreventableBaklavaEvent(this),\n            addOutput: new BaklavaEvent(this),\n            beforeRemoveOutput: new PreventableBaklavaEvent(this),\n            removeOutput: new BaklavaEvent(this),\n            update: new BaklavaEvent(this),\n        };\n        this.hooks = {\n            beforeLoad: new SequentialHook(this),\n            afterSave: new SequentialHook(this),\n        };\n    }\n    /**\n     * The graph instance the node is placed in.\n     * `undefined` if the node hasn't been placed in a graph yet.\n     */\n    get graph() {\n        return this.graphInstance;\n    }\n    /**\n     * Add an input interface to the node\n     * @param key Key of the input\n     * @param input The input instance\n     * @returns True when the input was added, otherwise false (prevented by an event handler)\n     */\n    addInput(key, input) {\n        return this.addInterface(\"input\", key, input);\n    }\n    /**\n     * Add an output interface to the node\n     * @param key Key of the output\n     * @param output The output instance\n     * @returns True when the output was added, otherwise false (prevented by an event handler)\n     */\n    addOutput(key, output) {\n        return this.addInterface(\"output\", key, output);\n    }\n    /**\n     * Remove an existing input\n     * @param key Key of the input.\n     */\n    removeInput(key) {\n        return this.removeInterface(\"input\", key);\n    }\n    /**\n     * Remove an existing output\n     * @param key Key of the output.\n     */\n    removeOutput(key) {\n        return this.removeInterface(\"output\", key);\n    }\n    /**\n     * This function will automatically be called as soon as the node is added to a graph.\n     * @param editor Graph instance\n     */\n    registerGraph(graph) {\n        this.graphInstance = graph;\n    }\n    load(state) {\n        this.hooks.beforeLoad.execute(state);\n        this.id = state.id;\n        this.title = state.title;\n        Object.entries(state.inputs).forEach(([k, v]) => {\n            if (this.inputs[k]) {\n                this.inputs[k].load(v);\n                this.inputs[k].nodeId = this.id;\n            }\n        });\n        Object.entries(state.outputs).forEach(([k, v]) => {\n            if (this.outputs[k]) {\n                this.outputs[k].load(v);\n                this.outputs[k].nodeId = this.id;\n            }\n        });\n        this.events.loaded.emit(this);\n    }\n    save() {\n        const inputStates = mapValues(this.inputs, (intf) => intf.save());\n        const outputStates = mapValues(this.outputs, (intf) => intf.save());\n        const state = {\n            type: this.type,\n            id: this.id,\n            title: this.title,\n            inputs: inputStates,\n            outputs: outputStates,\n        };\n        return this.hooks.afterSave.execute(state);\n    }\n    /**\n     * @virtual\n     * Override this method to execute logic when the node is placed inside a graph\n     */\n    onPlaced() { }\n    /**\n     * @virtual\n     * Override this method to perform cleanup when the node is deleted\n     */\n    onDestroy() { }\n    initializeIo() {\n        Object.entries(this.inputs).forEach(([key, intf]) => this.initializeIntf(\"input\", key, intf));\n        Object.entries(this.outputs).forEach(([key, intf]) => this.initializeIntf(\"output\", key, intf));\n    }\n    initializeIntf(type, key, intf) {\n        intf.isInput = type === \"input\";\n        intf.nodeId = this.id;\n        intf.events.setValue.subscribe(this, () => this.events.update.emit({ type, name: key, intf }));\n    }\n    addInterface(type, key, intf) {\n        const beforeEvent = type === \"input\" ? this.events.beforeAddInput : this.events.beforeAddOutput;\n        const afterEvent = type === \"input\" ? this.events.addInput : this.events.addOutput;\n        const ioObject = type === \"input\" ? this.inputs : this.outputs;\n        if (beforeEvent.emit(intf).prevented) {\n            return false;\n        }\n        ioObject[key] = intf;\n        this.initializeIntf(type, key, intf);\n        afterEvent.emit(intf);\n        return true;\n    }\n    removeInterface(type, key) {\n        const beforeEvent = type === \"input\" ? this.events.beforeRemoveInput : this.events.beforeRemoveOutput;\n        const afterEvent = type === \"input\" ? this.events.removeInput : this.events.removeOutput;\n        const io = type === \"input\" ? this.inputs[key] : this.outputs[key];\n        if (!io || beforeEvent.emit(io).prevented) {\n            return false;\n        }\n        if (io.connectionCount > 0) {\n            if (this.graphInstance) {\n                const connections = this.graphInstance.connections.filter((c) => c.from === io || c.to === io);\n                connections.forEach((c) => {\n                    this.graphInstance.removeConnection(c);\n                });\n            }\n            else {\n                throw new Error(\"Interface is connected, but no graph instance is specified. Unable to delete interface\");\n            }\n        }\n        io.events.setValue.unsubscribe(this);\n        if (type === \"input\") {\n            delete this.inputs[key];\n        }\n        else {\n            delete this.outputs[key];\n        }\n        afterEvent.emit(io);\n        return true;\n    }\n}\n/**\n * Abstract base class for every node\n */\nexport class Node extends AbstractNode {\n    load(state) {\n        super.load(state);\n    }\n    save() {\n        return super.save();\n    }\n}\n","import { Node } from \"./node\";\nexport function defineNode(definition) {\n    return class extends Node {\n        constructor() {\n            var _a, _b;\n            super();\n            this.type = definition.type;\n            this.title = (_a = definition.title) !== null && _a !== void 0 ? _a : definition.type;\n            this.inputs = {};\n            this.outputs = {};\n            this.calculate = definition.calculate\n                ? (inputs, globalValues) => {\n                    return definition.calculate.call(this, inputs, globalValues);\n                }\n                : undefined;\n            this.executeFactory(\"input\", definition.inputs);\n            this.executeFactory(\"output\", definition.outputs);\n            (_b = definition.onCreate) === null || _b === void 0 ? void 0 : _b.call(this);\n        }\n        onPlaced() {\n            var _a;\n            (_a = definition.onPlaced) === null || _a === void 0 ? void 0 : _a.call(this);\n        }\n        onDestroy() {\n            var _a;\n            (_a = definition.onDestroy) === null || _a === void 0 ? void 0 : _a.call(this);\n        }\n        executeFactory(type, factory) {\n            Object.keys(factory || {}).forEach((k) => {\n                const intf = factory[k]();\n                if (type === \"input\") {\n                    this.addInput(k, intf);\n                }\n                else {\n                    this.addOutput(k, intf);\n                }\n            });\n        }\n    };\n}\n","import { v4 as uuidv4 } from \"uuid\";\nimport { BaklavaEvent, createProxy, PreventableBaklavaEvent, SequentialHook, ParallelHook, } from \"@baklavajs/events\";\nimport { Connection, DummyConnection } from \"./connection\";\nexport class Graph {\n    /** List of all nodes in this graph */\n    get nodes() {\n        return this._nodes;\n    }\n    /** List of all connections in this graph */\n    get connections() {\n        return this._connections;\n    }\n    /** Whether the graph is currently in the process of loading a saved graph */\n    get loading() {\n        return this._loading;\n    }\n    /** Whether the graph is currently in the process of destroying itself */\n    get destroying() {\n        return this._destroying;\n    }\n    constructor(editor, template) {\n        this.id = uuidv4();\n        this.inputs = [];\n        this.outputs = [];\n        this.activeTransactions = 0;\n        this._nodes = [];\n        this._connections = [];\n        this._loading = false;\n        this._destroying = false;\n        this.events = {\n            beforeAddNode: new PreventableBaklavaEvent(this),\n            addNode: new BaklavaEvent(this),\n            beforeRemoveNode: new PreventableBaklavaEvent(this),\n            removeNode: new BaklavaEvent(this),\n            beforeAddConnection: new PreventableBaklavaEvent(this),\n            addConnection: new BaklavaEvent(this),\n            checkConnection: new PreventableBaklavaEvent(this),\n            beforeRemoveConnection: new PreventableBaklavaEvent(this),\n            removeConnection: new BaklavaEvent(this),\n        };\n        this.hooks = {\n            save: new SequentialHook(this),\n            load: new SequentialHook(this),\n            checkConnection: new ParallelHook(this),\n        };\n        this.nodeEvents = createProxy();\n        this.nodeHooks = createProxy();\n        this.connectionEvents = createProxy();\n        this.editor = editor;\n        this.template = template;\n        editor.registerGraph(this);\n    }\n    /**\n     * Add a node to the list of nodes.\n     * @param node Instance of a node\n     * @returns Instance of the node or undefined if the node was not added\n     */\n    addNode(node) {\n        if (this.events.beforeAddNode.emit(node).prevented) {\n            return;\n        }\n        this.nodeEvents.addTarget(node.events);\n        this.nodeHooks.addTarget(node.hooks);\n        node.registerGraph(this);\n        this._nodes.push(node);\n        // when adding the node to the array, it will be made reactive by Vue.\n        // However, our current reference is the non-reactive version.\n        // Therefore, we need to get the reactive version from the array.\n        node = this.nodes.find((n) => n.id === node.id);\n        node.onPlaced();\n        this.events.addNode.emit(node);\n        return node;\n    }\n    /**\n     * Removes a node from the list.\n     * Will also remove all connections from and to the node.\n     * @param node Reference to a node in the list.\n     */\n    removeNode(node) {\n        if (this.nodes.includes(node)) {\n            if (this.events.beforeRemoveNode.emit(node).prevented) {\n                return;\n            }\n            const interfaces = [...Object.values(node.inputs), ...Object.values(node.outputs)];\n            this.connections\n                .filter((c) => interfaces.includes(c.from) || interfaces.includes(c.to))\n                .forEach((c) => this.removeConnection(c));\n            this._nodes.splice(this.nodes.indexOf(node), 1);\n            this.events.removeNode.emit(node);\n            node.onDestroy();\n            this.nodeEvents.removeTarget(node.events);\n            this.nodeHooks.removeTarget(node.hooks);\n        }\n    }\n    /**\n     * Add a connection to the list of connections.\n     * @param from Start interface for the connection\n     * @param to Target interface for the connection\n     * @returns The created connection. If no connection could be created, returns `undefined`.\n     */\n    addConnection(from, to) {\n        const checkConnectionResult = this.checkConnection(from, to);\n        if (!checkConnectionResult.connectionAllowed) {\n            return undefined;\n        }\n        if (this.events.beforeAddConnection.emit({ from, to }).prevented) {\n            return;\n        }\n        for (const connectionToRemove of checkConnectionResult.connectionsInDanger) {\n            const instance = this.connections.find((c) => c.id === connectionToRemove.id);\n            if (instance) {\n                this.removeConnection(instance);\n            }\n        }\n        const c = new Connection(checkConnectionResult.dummyConnection.from, checkConnectionResult.dummyConnection.to);\n        this.internalAddConnection(c);\n        return c;\n    }\n    /**\n     * Remove a connection from the list of connections.\n     * @param connection Connection instance that should be removed.\n     */\n    removeConnection(connection) {\n        if (this.connections.includes(connection)) {\n            if (this.events.beforeRemoveConnection.emit(connection).prevented) {\n                return;\n            }\n            connection.destruct();\n            this._connections.splice(this.connections.indexOf(connection), 1);\n            this.events.removeConnection.emit(connection);\n            this.connectionEvents.removeTarget(connection.events);\n        }\n    }\n    /**\n     * Checks, whether a connection between two node interfaces would be valid.\n     * @param from The starting node interface (must be an output interface)\n     * @param to The target node interface (must be an input interface)\n     * @returns Whether the connection is allowed or not.\n     */\n    checkConnection(from, to) {\n        if (!from || !to) {\n            return { connectionAllowed: false };\n        }\n        const fromNode = this.findNodeById(from.nodeId);\n        const toNode = this.findNodeById(to.nodeId);\n        if (fromNode && toNode && fromNode === toNode) {\n            // connections must be between two separate nodes.\n            return { connectionAllowed: false };\n        }\n        if (from.isInput && !to.isInput) {\n            // reverse connection\n            const tmp = from;\n            from = to;\n            to = tmp;\n        }\n        if (from.isInput || !to.isInput) {\n            // connections are only allowed from input to output interface\n            return { connectionAllowed: false };\n        }\n        // prevent duplicate connections\n        if (this.connections.some((c) => c.from === from && c.to === to)) {\n            return { connectionAllowed: false };\n        }\n        if (this.events.checkConnection.emit({ from, to }).prevented) {\n            return { connectionAllowed: false };\n        }\n        const hookResults = this.hooks.checkConnection.execute({ from, to });\n        if (hookResults.some((hr) => !hr.connectionAllowed)) {\n            return { connectionAllowed: false };\n        }\n        const connectionsInDanger = Array.from(new Set(hookResults.flatMap((hr) => hr.connectionsInDanger)));\n        return {\n            connectionAllowed: true,\n            dummyConnection: new DummyConnection(from, to),\n            connectionsInDanger,\n        };\n    }\n    /**\n     * Finds the NodeInterface with the provided id, as long as it exists in this graph\n     * @param id id of the NodeInterface to find\n     * @returns The NodeInterface if found, otherwise undefined\n     */\n    findNodeInterface(id) {\n        for (const node of this.nodes) {\n            for (const k in node.inputs) {\n                const nodeInput = node.inputs[k];\n                if (nodeInput.id === id) {\n                    return nodeInput;\n                }\n            }\n            for (const k in node.outputs) {\n                const nodeOutput = node.outputs[k];\n                if (nodeOutput.id === id) {\n                    return nodeOutput;\n                }\n            }\n        }\n    }\n    /**\n     * Finds the Node with the provided id, as long as it exists in this graph\n     * @param id id of the Node to find\n     * @returns The Node if found, otherwise undefined\n     */\n    findNodeById(id) {\n        return this.nodes.find((n) => n.id === id);\n    }\n    /**\n     * Load a state\n     * @param state State to load\n     * @returns An array of warnings that occured during loading. If the array is empty, the state was successfully loaded.\n     */\n    load(state) {\n        try {\n            this._loading = true;\n            const warnings = [];\n            // Clear current state\n            for (let i = this.connections.length - 1; i >= 0; i--) {\n                this.removeConnection(this.connections[i]);\n            }\n            for (let i = this.nodes.length - 1; i >= 0; i--) {\n                this.removeNode(this.nodes[i]);\n            }\n            // Load state\n            this.id = state.id;\n            this.inputs = state.inputs;\n            this.outputs = state.outputs;\n            for (const n of state.nodes) {\n                // find node type\n                const nodeInformation = this.editor.nodeTypes.get(n.type);\n                if (!nodeInformation) {\n                    warnings.push(`Node type ${n.type} is not registered`);\n                    continue;\n                }\n                const node = new nodeInformation.type();\n                this.addNode(node);\n                node.load(n);\n            }\n            for (const c of state.connections) {\n                const fromIf = this.findNodeInterface(c.from);\n                const toIf = this.findNodeInterface(c.to);\n                if (!fromIf) {\n                    warnings.push(`Could not find interface with id ${c.from}`);\n                    continue;\n                }\n                else if (!toIf) {\n                    warnings.push(`Could not find interface with id ${c.to}`);\n                    continue;\n                }\n                else {\n                    const conn = new Connection(fromIf, toIf);\n                    conn.id = c.id;\n                    this.internalAddConnection(conn);\n                }\n            }\n            this.hooks.load.execute(state);\n            return warnings;\n        }\n        finally {\n            this._loading = false;\n        }\n    }\n    /**\n     * Save a state\n     * @returns Current state\n     */\n    save() {\n        const state = {\n            id: this.id,\n            nodes: this.nodes.map((n) => n.save()),\n            connections: this.connections.map((c) => ({\n                id: c.id,\n                from: c.from.id,\n                to: c.to.id,\n            })),\n            inputs: this.inputs,\n            outputs: this.outputs,\n        };\n        return this.hooks.save.execute(state);\n    }\n    destroy() {\n        this._destroying = true;\n        for (const n of this.nodes) {\n            this.removeNode(n);\n        }\n        this.editor.unregisterGraph(this);\n    }\n    internalAddConnection(c) {\n        this.connectionEvents.addTarget(c.events);\n        this._connections.push(c);\n        this.events.addConnection.emit(c);\n    }\n}\n","import { v4 as uuidv4 } from \"uuid\";\nimport { SequentialHook, BaklavaEvent, PreventableBaklavaEvent, } from \"@baklavajs/events\";\nexport class NodeInterface {\n    set connectionCount(v) {\n        this._connectionCount = v;\n        this.events.setConnectionCount.emit(v);\n    }\n    get connectionCount() {\n        return this._connectionCount;\n    }\n    set value(v) {\n        if (this.events.beforeSetValue.emit(v).prevented) {\n            return;\n        }\n        this._value = v;\n        this.events.setValue.emit(v);\n    }\n    get value() {\n        return this._value;\n    }\n    constructor(name, value) {\n        this.id = uuidv4();\n        /** Id of the node this interface is part of */\n        this.nodeId = \"\";\n        /** Whether to show the port (the thing connections connect to) */\n        this.port = true;\n        /** Whether to hide the node interface in the UI */\n        this.hidden = false;\n        this.events = {\n            setConnectionCount: new BaklavaEvent(this),\n            beforeSetValue: new PreventableBaklavaEvent(this),\n            setValue: new BaklavaEvent(this),\n            updated: new BaklavaEvent(this),\n        };\n        this.hooks = {\n            load: new SequentialHook(this),\n            save: new SequentialHook(this),\n        };\n        this._connectionCount = 0;\n        this.name = name;\n        this._value = value;\n    }\n    load(state) {\n        this.id = state.id;\n        this.templateId = state.templateId;\n        this.value = state.value;\n        this.hooks.load.execute(state);\n    }\n    save() {\n        const state = {\n            id: this.id,\n            templateId: this.templateId,\n            value: this.value,\n        };\n        return this.hooks.save.execute(state);\n    }\n    setComponent(value) {\n        this.component = value;\n        return this;\n    }\n    setPort(value) {\n        this.port = value;\n        return this;\n    }\n    setHidden(value) {\n        this.hidden = value;\n        return this;\n    }\n    use(middleware, ...args) {\n        middleware(this, ...args);\n        return this;\n    }\n}\n","import { AbstractNode } from \"./node\";\nimport { NodeInterface } from \"./nodeInterface\";\nexport const GRAPH_NODE_TYPE_PREFIX = \"__baklava_GraphNode-\";\nexport function getGraphNodeTypeString(template) {\n    return GRAPH_NODE_TYPE_PREFIX + template.id;\n}\nexport function createGraphNodeType(template) {\n    return class GraphNode extends AbstractNode {\n        constructor() {\n            super(...arguments);\n            this.type = getGraphNodeTypeString(template);\n            this._title = \"GraphNode\";\n            this.inputs = {};\n            this.outputs = {};\n            this.template = template;\n            this.calculate = async (inputs, context) => {\n                if (!this.subgraph) {\n                    throw new Error(`GraphNode ${this.id}: calculate called without subgraph being initialized`);\n                }\n                if (typeof context.engine === \"object\" &&\n                    !!context.engine &&\n                    typeof context.engine.runGraph === \"function\") {\n                    const graphInputs = new Map();\n                    // gather all values of the unconnected inputs\n                    for (const n of this.subgraph.nodes) {\n                        Object.values(n.inputs).forEach((ni) => {\n                            if (ni.connectionCount === 0) {\n                                graphInputs.set(ni.id, ni.value);\n                            }\n                        });\n                    }\n                    // map graph inputs to their respective nodeInterfaceId in the graph\n                    Object.entries(inputs).forEach(([k, v]) => {\n                        const gi = this.subgraph.inputs.find((x) => x.id === k);\n                        graphInputs.set(gi.nodeInterfaceId, v);\n                    });\n                    const result = await context.engine.runGraph(this.subgraph, graphInputs, context.globalValues);\n                    const flatResult = new Map();\n                    result.forEach((nodeOutputs, nodeId) => {\n                        const node = this.subgraph.nodes.find((n) => n.id === nodeId);\n                        nodeOutputs.forEach((v, nodeInterfaceKey) => {\n                            flatResult.set(node.outputs[nodeInterfaceKey].id, v);\n                        });\n                    });\n                    const outputs = {};\n                    this.subgraph.outputs.forEach((graphOutput) => {\n                        outputs[graphOutput.id] = flatResult.get(graphOutput.nodeInterfaceId);\n                    });\n                    outputs._calculationResults = result;\n                    return outputs;\n                }\n            };\n        }\n        get title() {\n            return this._title;\n        }\n        set title(v) {\n            this.template.name = v;\n        }\n        load(state) {\n            if (!this.subgraph) {\n                throw new Error(\"Cannot load a graph node without a graph\");\n            }\n            if (!this.template) {\n                throw new Error(\"Unable to load graph node without graph template\");\n            }\n            this.subgraph.load(state.graphState);\n            super.load(state);\n        }\n        save() {\n            if (!this.subgraph) {\n                throw new Error(\"Cannot save a graph node without a graph\");\n            }\n            const state = super.save();\n            return {\n                ...state,\n                graphState: this.subgraph.save(),\n            };\n        }\n        onPlaced() {\n            this.template.events.updated.subscribe(this, () => this.initialize());\n            this.template.events.nameChanged.subscribe(this, (name) => {\n                this._title = name;\n            });\n            this.initialize();\n        }\n        onDestroy() {\n            var _a;\n            this.template.events.updated.unsubscribe(this);\n            this.template.events.nameChanged.unsubscribe(this);\n            (_a = this.subgraph) === null || _a === void 0 ? void 0 : _a.destroy();\n        }\n        initialize() {\n            if (this.subgraph) {\n                this.subgraph.destroy();\n            }\n            this.subgraph = this.template.createGraph();\n            this._title = this.template.name;\n            this.updateInterfaces();\n            this.events.update.emit(null);\n        }\n        updateInterfaces() {\n            if (!this.subgraph) {\n                throw new Error(\"Trying to update interfaces without graph instance\");\n            }\n            for (const graphInput of this.subgraph.inputs) {\n                if (!(graphInput.id in this.inputs)) {\n                    this.addInput(graphInput.id, new NodeInterface(graphInput.name, undefined));\n                }\n                else {\n                    this.inputs[graphInput.id].name = graphInput.name;\n                }\n            }\n            for (const k of Object.keys(this.inputs)) {\n                if (!this.subgraph.inputs.some((gi) => gi.id === k)) {\n                    this.removeInput(k);\n                }\n            }\n            for (const graphOutput of this.subgraph.outputs) {\n                if (!(graphOutput.id in this.outputs)) {\n                    this.addOutput(graphOutput.id, new NodeInterface(graphOutput.name, undefined));\n                }\n                else {\n                    this.outputs[graphOutput.id].name = graphOutput.name;\n                }\n            }\n            for (const k of Object.keys(this.outputs)) {\n                if (!this.subgraph.outputs.some((gi) => gi.id === k)) {\n                    this.removeOutput(k);\n                }\n            }\n            // Add an internal output to allow accessing the calculation results of nodes inside the graph\n            this.addOutput(\"_calculationResults\", new NodeInterface(\"_calculationResults\", undefined).setHidden(true));\n        }\n    };\n}\n","import { v4 as uuidv4 } from \"uuid\";\nimport { BaklavaEvent, SequentialHook } from \"@baklavajs/events\";\nimport { Graph } from \"./graph\";\nimport { mapValues } from \"./utils\";\nimport { getGraphNodeTypeString } from \"./graphNode\";\nexport class GraphTemplate {\n    /** Create a new GraphTemplate from the nodes and connections inside the graph instance */\n    static fromGraph(graph, editor) {\n        return new GraphTemplate(graph.save(), editor);\n    }\n    /** Get the name of the graph template */\n    get name() {\n        return this._name;\n    }\n    /** Set the name of the graph template */\n    set name(v) {\n        this._name = v;\n        this.events.nameChanged.emit(v);\n        const nt = this.editor.nodeTypes.get(getGraphNodeTypeString(this));\n        if (nt) {\n            nt.title = v;\n        }\n    }\n    constructor(state, editor) {\n        /** Graph template id */\n        this.id = uuidv4();\n        this._name = \"Subgraph\";\n        this.events = {\n            nameChanged: new BaklavaEvent(this),\n            updated: new BaklavaEvent(this),\n        };\n        this.hooks = {\n            beforeLoad: new SequentialHook(this),\n            afterSave: new SequentialHook(this),\n        };\n        this.editor = editor;\n        if (state.id) {\n            this.id = state.id;\n        }\n        if (state.name) {\n            this._name = state.name;\n        }\n        this.update(state);\n    }\n    /** Update the state of the graph template with the provided state */\n    update(state) {\n        this.nodes = state.nodes;\n        this.connections = state.connections;\n        this.inputs = state.inputs;\n        this.outputs = state.outputs;\n        this.events.updated.emit();\n    }\n    save() {\n        return {\n            id: this.id,\n            name: this.name,\n            nodes: this.nodes,\n            connections: this.connections,\n            inputs: this.inputs,\n            outputs: this.outputs,\n        };\n    }\n    /**\n     * Create a new graph instance from this template\n     * or load the state into the provided graph instance.\n     */\n    createGraph(graph) {\n        const idMap = new Map();\n        const createNewId = (oldId) => {\n            const newId = uuidv4();\n            idMap.set(oldId, newId);\n            return newId;\n        };\n        const getNewId = (oldId) => {\n            const newId = idMap.get(oldId);\n            if (!newId) {\n                throw new Error(`Unable to create graph from template: Could not map old id ${oldId} to new id`);\n            }\n            return newId;\n        };\n        const mapNodeInterfaceIds = (interfaceStates) => {\n            return mapValues(interfaceStates, (intf) => {\n                const clonedIntf = {\n                    id: createNewId(intf.id),\n                    templateId: intf.id,\n                    value: intf.value,\n                };\n                return clonedIntf;\n            });\n        };\n        const nodes = this.nodes.map((n) => ({\n            ...n,\n            id: createNewId(n.id),\n            inputs: mapNodeInterfaceIds(n.inputs),\n            outputs: mapNodeInterfaceIds(n.outputs),\n        }));\n        const connections = this.connections.map((c) => ({\n            id: createNewId(c.id),\n            from: getNewId(c.from),\n            to: getNewId(c.to),\n        }));\n        const inputs = this.inputs.map((i) => ({\n            id: i.id,\n            name: i.name,\n            nodeInterfaceId: getNewId(i.nodeInterfaceId),\n        }));\n        const outputs = this.outputs.map((o) => ({\n            id: o.id,\n            name: o.name,\n            nodeInterfaceId: getNewId(o.nodeInterfaceId),\n        }));\n        const clonedState = {\n            id: uuidv4(),\n            nodes,\n            connections,\n            inputs,\n            outputs,\n        };\n        if (!graph) {\n            graph = new Graph(this.editor);\n        }\n        graph.load(clonedState);\n        graph.template = this;\n        return graph;\n    }\n}\n","import { PreventableBaklavaEvent, BaklavaEvent, SequentialHook, createProxy, } from \"@baklavajs/events\";\nimport { Graph } from \"./graph\";\nimport { createGraphNodeType, getGraphNodeTypeString } from \"./graphNode\";\nimport { GraphTemplate } from \"./graphTemplate\";\n/** The main model class for BaklavaJS */\nexport class Editor {\n    constructor() {\n        this.events = {\n            loaded: new BaklavaEvent(this),\n            beforeRegisterNodeType: new PreventableBaklavaEvent(this),\n            registerNodeType: new BaklavaEvent(this),\n            beforeUnregisterNodeType: new PreventableBaklavaEvent(this),\n            unregisterNodeType: new BaklavaEvent(this),\n            beforeAddGraphTemplate: new PreventableBaklavaEvent(this),\n            addGraphTemplate: new BaklavaEvent(this),\n            beforeRemoveGraphTemplate: new PreventableBaklavaEvent(this),\n            removeGraphTemplate: new BaklavaEvent(this),\n            registerGraph: new BaklavaEvent(this),\n            unregisterGraph: new BaklavaEvent(this),\n        };\n        this.hooks = {\n            save: new SequentialHook(this),\n            load: new SequentialHook(this),\n        };\n        this.graphTemplateEvents = createProxy();\n        this.graphTemplateHooks = createProxy();\n        this.graphEvents = createProxy();\n        this.graphHooks = createProxy();\n        this.nodeEvents = createProxy();\n        this.nodeHooks = createProxy();\n        this.connectionEvents = createProxy();\n        this._graphs = new Set();\n        this._nodeTypes = new Map();\n        this._graph = new Graph(this);\n        this._graphTemplates = [];\n        this._loading = false;\n    }\n    /** List of all registered node types */\n    get nodeTypes() {\n        return this._nodeTypes;\n    }\n    /** The root graph */\n    get graph() {\n        return this._graph;\n    }\n    /** List of all registered graph templates (subgraphs) */\n    get graphTemplates() {\n        return this._graphTemplates;\n    }\n    /** Set of all graphs in the editor, including subgraphs */\n    get graphs() {\n        return this._graphs;\n    }\n    /** Whether the editor is currently in the process of loading a saved graph */\n    get loading() {\n        return this._loading;\n    }\n    /**\n     * Register a new node type\n     * @param type Actual type / constructor of the node\n     * @param options Optionally specify a title and/or a category for this node\n     */\n    registerNodeType(type, options) {\n        var _a, _b;\n        if (this.events.beforeRegisterNodeType.emit({ type, options }).prevented) {\n            return;\n        }\n        const nodeInstance = new type();\n        this._nodeTypes.set(nodeInstance.type, {\n            type,\n            category: (_a = options === null || options === void 0 ? void 0 : options.category) !== null && _a !== void 0 ? _a : \"default\",\n            title: (_b = options === null || options === void 0 ? void 0 : options.title) !== null && _b !== void 0 ? _b : nodeInstance.title,\n        });\n        this.events.registerNodeType.emit({ type, options });\n    }\n    /**\n     * Unregister an existing node type. Will also remove all the nodes of this type in all graphs.\n     * @param type String type or node constructor, from which the type will be detected\n     */\n    unregisterNodeType(type) {\n        const stringType = typeof type === \"string\" ? type : new type().type;\n        if (this.nodeTypes.has(stringType)) {\n            if (this.events.beforeUnregisterNodeType.emit(stringType).prevented) {\n                return;\n            }\n            this._nodeTypes.delete(stringType);\n            this.events.unregisterNodeType.emit(stringType);\n        }\n    }\n    addGraphTemplate(template) {\n        if (this.events.beforeAddGraphTemplate.emit(template).prevented) {\n            return;\n        }\n        this._graphTemplates.push(template);\n        this.graphTemplateEvents.addTarget(template.events);\n        this.graphTemplateHooks.addTarget(template.hooks);\n        const nt = createGraphNodeType(template);\n        this.registerNodeType(nt, { category: \"Subgraphs\", title: template.name });\n        this.events.addGraphTemplate.emit(template);\n    }\n    removeGraphTemplate(template) {\n        if (this.graphTemplates.includes(template)) {\n            if (this.events.beforeRemoveGraphTemplate.emit(template).prevented) {\n                return;\n            }\n            // remove all nodes of this type in all graphs\n            const graphNodeType = getGraphNodeTypeString(template);\n            for (const g of [this.graph, ...this.graphs.values()]) {\n                const nodesToRemove = g.nodes.filter((n) => n.type === graphNodeType);\n                for (const n of nodesToRemove) {\n                    g.removeNode(n);\n                }\n            }\n            this.unregisterNodeType(graphNodeType);\n            this._graphTemplates.splice(this._graphTemplates.indexOf(template), 1);\n            this.graphTemplateEvents.removeTarget(template.events);\n            this.graphTemplateHooks.removeTarget(template.hooks);\n            this.events.removeGraphTemplate.emit(template);\n        }\n    }\n    registerGraph(graph) {\n        this.graphEvents.addTarget(graph.events);\n        this.graphHooks.addTarget(graph.hooks);\n        this.nodeEvents.addTarget(graph.nodeEvents);\n        this.nodeHooks.addTarget(graph.nodeHooks);\n        this.connectionEvents.addTarget(graph.connectionEvents);\n        this.events.registerGraph.emit(graph);\n        this._graphs.add(graph);\n    }\n    unregisterGraph(graph) {\n        this.graphEvents.removeTarget(graph.events);\n        this.graphHooks.removeTarget(graph.hooks);\n        this.nodeEvents.removeTarget(graph.nodeEvents);\n        this.nodeHooks.removeTarget(graph.nodeHooks);\n        this.connectionEvents.removeTarget(graph.connectionEvents);\n        this.events.unregisterGraph.emit(graph);\n        this._graphs.delete(graph);\n    }\n    /**\n     * Load a state\n     * @param state State to load\n     * @returns An array of warnings that occured during loading. If the array is empty, the state was successfully loaded.\n     */\n    load(state) {\n        try {\n            this._loading = true;\n            state = this.hooks.load.execute(state);\n            state.graphTemplates.forEach((tState) => {\n                const template = new GraphTemplate(tState, this);\n                this.addGraphTemplate(template);\n            });\n            const warnings = this._graph.load(state.graph);\n            this.events.loaded.emit();\n            warnings.forEach((w) => console.warn(w));\n            return warnings;\n        }\n        finally {\n            this._loading = false;\n        }\n    }\n    /**\n     * Save a state\n     * @returns Current state\n     */\n    save() {\n        const state = {\n            graph: this.graph.save(),\n            graphTemplates: this.graphTemplates.map((t) => t.save()),\n        };\n        return this.hooks.save.execute(state);\n    }\n}\n"],"names":["Connection","constructor","from","to","this","destructed","events","destruct","Error","id","connectionCount","emit","DummyConnection","mapValues","obj","fn","Object","fromEntries","entries","map","k","v","AbstractNode","loaded","beforeAddInput","addInput","beforeRemoveInput","removeInput","beforeAddOutput","addOutput","beforeRemoveOutput","removeOutput","update","hooks","beforeLoad","afterSave","graph","graphInstance","key","input","addInterface","output","removeInterface","registerGraph","load","state","execute","title","inputs","forEach","nodeId","outputs","save","inputStates","intf","outputStates","type","onPlaced","onDestroy","initializeIo","initializeIntf","isInput","setValue","subscribe","name","beforeEvent","afterEvent","ioObject","prevented","io","connections","filter","c","removeConnection","unsubscribe","super","defineNode","definition","_a","_b","calculate","globalValues","call","undefined","executeFactory","onCreate","factory","keys","Graph","nodes","_nodes","_connections","loading","_loading","destroying","_destroying","editor","template","activeTransactions","beforeAddNode","addNode","beforeRemoveNode","removeNode","beforeAddConnection","addConnection","checkConnection","beforeRemoveConnection","nodeEvents","nodeHooks","connectionEvents","node","addTarget","push","find","n","includes","interfaces","values","splice","indexOf","removeTarget","checkConnectionResult","connectionAllowed","connectionToRemove","connectionsInDanger","instance","dummyConnection","internalAddConnection","connection","fromNode","findNodeById","toNode","tmp","some","hookResults","hr","Array","Set","flatMap","findNodeInterface","nodeInput","nodeOutput","warnings","i","length","nodeInformation","nodeTypes","get","fromIf","toIf","conn","destroy","unregisterGraph","NodeInterface","_connectionCount","setConnectionCount","value","beforeSetValue","_value","port","hidden","updated","templateId","setComponent","component","setPort","setHidden","use","middleware","args","GRAPH_NODE_TYPE_PREFIX","getGraphNodeTypeString","GraphTemplate","fromGraph","_name","nameChanged","nt","createGraph","idMap","Map","createNewId","oldId","newId","set","getNewId","mapNodeInterfaceIds","interfaceStates","nodeInterfaceId","o","clonedState","Editor","beforeRegisterNodeType","registerNodeType","beforeUnregisterNodeType","unregisterNodeType","beforeAddGraphTemplate","addGraphTemplate","beforeRemoveGraphTemplate","removeGraphTemplate","graphTemplateEvents","graphTemplateHooks","graphEvents","graphHooks","_graphs","_nodeTypes","_graph","_graphTemplates","graphTemplates","graphs","options","nodeInstance","category","stringType","has","delete","arguments","_title","async","context","subgraph","engine","runGraph","graphInputs","ni","gi","x","result","flatResult","nodeOutputs","nodeInterfaceKey","graphOutput","_calculationResults","graphState","initialize","updateInterfaces","graphInput","createGraphNodeType","graphNodeType","g","nodesToRemove","add","tState","w","console","warn","t"],"sourceRoot":""}