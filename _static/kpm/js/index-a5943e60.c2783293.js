"use strict";(self.webpackChunkpipeline_manager=self.webpackChunkpipeline_manager||[]).push([[197],{34580:(e,t,i)=>{i.d(t,{Wx:()=>G,dH:()=>H,L6:()=>R,kx:()=>L,Ay:()=>P,sA:()=>_});var a=i(94541),s=i(26061),n=i(63491),o=i(50953),r=i(46171),d=i(42302),c=i(41857),h=i(20641),l=i(96422);const p="COPY",u="DELETE",f="UNHIGHLIGHT",g="PASTE";var y=i(51970);class v{types=new Map;defaultStyle={interfaceConnectionPattern:"solid",interfaceConnectionColor:"#FFFFFF",interfaceColor:"#00E58D"};constructor(e){e.hooks.renderInterface.subscribe(this,(({intf:e,el:t})=>{if(e.type){const i=this.normalizeType(e.type).find((e=>void 0!==this.types[e]?.interfaceColor));if(void 0!==i){const e=this.types[i].interfaceColor,a=t.querySelector(".__port:not(.greyedout_arrow)");if(null!==a)a.style.backgroundColor=e;else{const e=t.querySelector(".__port");null!==e&&(e.style.backgroundColor=getComputedStyle(e).getPropertyValue("$gray-500"))}}}return{intf:e,el:t}}))}normalizeType(e){return"string"==typeof e||e instanceof String?[e]:e}getConnectionStyle(e,t){const i=this.normalizeType(e?.type),a=this.normalizeType(t?.type);if(void 0===e?.type)return this.defaultStyle;if(void 0===t?.type){const e=i.find((e=>void 0!==this.types[e]));return{...this.defaultStyle,...this.types[e]}}const s=i.filter((e=>a.includes(e)));if(Array.isArray(s)&&s.length>1)return this.defaultStyle;const n=s.find((e=>void 0!==this.types[e]));return{...this.defaultStyle,...this.types[n]}}readInterfaceTypes(e){this.types={},e?.interfaces&&Object.entries(e.interfaces).forEach((([e,t])=>{this.types[e]={...t,name:e}}))}}var m=i(8239),b=i(85022),w=i(75572),x=i(41686),$=i(78873),N=i(38703),S=i(80850);function k(e,t,i){const a=document.getElementById(e.nodeId);return((a?a.offsetTop:0)+i.y)*t}function E(e,t,i){const a=document.getElementById(e.nodeId);return((a?a.offsetTop+a.offsetHeight:0)+i.y)*t}function V(e,t,i,a,s){return[Math.sqrt(Math.abs((e-i)*(e-i)+(e-i)*(t-a)/s)),Math.sqrt(Math.abs((t-a)*(t-a)+(t-a)*(e-i)*s))]}class M{constructor(e,t,i,a,s){this.x1=e,this.y1=t,this.x2=i,this.y2=a,this.from=s.from,s.to&&(this.to=s.to,("input"===this.from.direction&&"output"===this.to.direction||"input"===this.from.direction&&"inout"===this.to.direction||"inout"===this.from.direction&&"output"===this.to.direction)&&([this.x1,this.x2,this.y1,this.y2]=[this.x2,this.x1,this.y2,this.y1],[this.from,this.to]=[this.to,this.from]))}}class O{style="curved";viewModel=null;randomizedOffset=!1;shiftDistance=15;getShift(e,t,i,a){const s=(e.sidePosition+t.sidePosition)/2;if(this.randomizedOffset){const n=this.getInterfaceNeighbors(e,i),o=this.getInterfaceNeighbors(t,i);let r=[...t.id].reduce(((e,t)=>e+t.charCodeAt(0)),0)??0,d=[...e.id].reduce(((e,t)=>e+t.charCodeAt(0)),0)??0;const c=r^d;d=c%n.length,r=c%o.length;const h=(d+r)/2;return this.shiftDistance*(h/2+s/2)*a}return this.shiftDistance*s*a}getMaxShift(e,t,i,a){const s=this.getInterfaceNeighbors(e,i).length-1,n=this.getInterfaceNeighbors(t,i).length-1;return this.shiftDistance*((s+n)/2)*a}getInterfaceNeighbors(e,t){const i=t.findNodeById(e.nodeId);return[...Object.values(i.inputs),...Object.values(i.outputs)].filter((t=>t.side===e.side&&t.port))}someAboveOrBelow(e,t,i){const a=k(e,i.scaling,i.panning),s=k(t,i.scaling,i.panning),n=E(e,i.scaling,i.panning),o=E(t,i.scaling,i.panning);return n<s||a>o}curvedRender(e,t,i,a,s){const n=new M(e,t,i,a,s),o=.3*Math.abs(n.x1-n.x2);if(n.to){if("right"===n.from.side&&"left"===n.to.side)return`M ${n.x1} ${n.y1} C ${n.x1+o} ${n.y1}, ${n.x2-o} ${n.y2}, ${n.x2} ${n.y2}`;if("left"===n.from.side&&"right"===n.to.side)return`M ${n.x1} ${n.y1} C ${n.x1-o} ${n.y1}, ${n.x2+o} ${n.y2}, ${n.x2} ${n.y2}`;if("right"===n.from.side&&"right"===n.to.side){const e=Math.max(n.x1+o,n.x2+o);return`M ${n.x1} ${n.y1} C ${e} ${n.y1}, ${e} ${n.y2}, ${n.x2} ${n.y2}`}if("left"===n.from.side&&"left"===n.to.side){const e=Math.min(n.x1-o,n.x2-o);return`M ${n.x1} ${n.y1} C ${e} ${n.y1}, ${e} ${n.y2}, ${n.x2} ${n.y2}`}}return"right"===n.from.side?`M ${n.x1} ${n.y1} C ${n.x1+o} ${n.y1}, ${n.x2-o} ${n.y2}, ${n.x2} ${n.y2}`:"left"===n.from.side?`M ${n.x1} ${n.y1} C ${n.x1-o} ${n.y1}, ${n.x2+o} ${n.y2}, ${n.x2} ${n.y2}`:void 0}curvedRenderLoopback(e,t,i,a,s){const n=this.viewModel.displayedGraph,o=new M(e,t,i,a,s),r=10*n.scaling;if(o.from.id===o.to.id){const e=this.getShift(o.from,o.to,n,n.scaling)+30*n.scaling,t="right"===o.from.side?o.x1+e:o.x1-e;return`M ${o.x1} ${o.y1}\n            A ${r} ${r/2} 0 0 0 ${t} ${o.y1}\n            A ${r} ${r/2} 0 0 0 ${o.x1} ${o.y1}`}if("left"===o.from.side&&"left"===o.to.side){const e=r,t=Math.abs(o.y1-o.y2)/2,i=o.y1>o.y2?1:0;return`M ${o.x1} ${o.y1}\n            A ${e} ${t} 0 0 ${i} ${o.x2} ${o.y2}`}if("right"===o.from.side&&"right"===o.to.side){const e=r,t=Math.abs(o.y1-o.y2)/2,i=o.y1>o.y2?0:1;return`M ${o.x1} ${o.y1}\n            A ${e} ${t} 0 0 ${i} ${o.x2} ${o.y2}`}const d=this.getShift(o.from,o.to,n,n.scaling)+30*n.scaling,c="left"===o.from.side?o.x1:o.x2,h="right"===o.to.side?o.x2:o.x1,l="left"===o.from.side?o.y1:o.y2,p="right"===o.to.side?o.y2:o.y1,u=E(o.from,n.scaling,n.panning),f=u+d,g=h-d,y=(f+p)/2,[v,m]=V(h,f,g,y,1),b=(h+c)/2,w=u,[x,$]=V(h,f,b,w,1),N=c+d,S=(f+l)/2,[k,O]=V(c,f,N,S,-1);return`M ${h} ${p}\n        A ${v} ${m} 0 0 1 ${h} ${f}\n        A ${x} ${$} 0 0 1 ${c} ${f}\n        A ${k} ${O} 0 0 1 ${c} ${l}`}orthogonalAnchorsPath(e,t,i){const a=e.map((e=>{return{x:((t=e).x+i.panning.x)*i.scaling,y:(t.y+i.panning.y)*i.scaling};var t})),s=[{x:t.x1,y:t.y1}];let n=t.from.side,o=0;return o="left"===n?-20:20,s.push({x:t.x1+o*i.scaling,y:t.y1}),n="horizontal",a.forEach((e=>{"vertical"===n?(s.push({x:s[s.length-1].x+(e.x-s[s.length-1].x)/2,y:s[s.length-1].y}),s.push({x:s[s.length-2].x+(e.x-s[s.length-2].x)/2,y:e.y}),s.push({x:e.x,y:e.y}),n="horizontal"):(s.push({x:s[s.length-1].x,y:s[s.length-1].y+(e.y-s[s.length-1].y)/2}),s.push({x:e.x,y:s[s.length-2].y+(e.y-s[s.length-2].y)/2}),s.push({x:e.x,y:e.y}),n="vertical")})),"vertical"===n?(s.push({x:s[s.length-1].x+(t.x2-s[s.length-1].x)/2,y:s[s.length-1].y}),s.push({x:s[s.length-2].x+(t.x2-s[s.length-2].x)/2,y:t.y2}),s.push({x:t.x2,y:t.y2})):(s.push({x:s[s.length-1].x,y:s[s.length-1].y+(t.y2-s[s.length-1].y)/2}),o="left"===t.to.side?10:-10,s.push({x:t.x2-o,y:s[s.length-2].y+(t.y2-s[s.length-2].y)/2}),s.push({x:t.x2-o,y:t.y2}),s.push({x:t.x2,y:t.y2})),s}orthogonalRender(e,t,i,a,s){const n=this.viewModel.displayedGraph,o=new M(e,t,i,a,s);if(void 0!==s.anchors&&s.anchors.length)return this.orthogonalAnchorsPath(s.anchors,o,n);const r=30*n.scaling,d=(o.x1+o.x2)/2;if(s.to){const e=this.getShift(o.from,o.to,n,n.scaling);if("right"===o.from.side&&"left"===o.to.side){const t=Math.max(o.x1,d)+e+r,i=t<o.x2-e-r?o.x1+e+r:t,a=o.x2-e-r;return t>=o.x2-e-r&&(i>o.x2-r||a<o.x1-r)?`M ${o.x1} ${o.y1}\n                    H ${i}\n                    V ${(o.y1+o.y2)/2}\n                    H ${a}\n                    V ${o.y2}\n                    H ${o.x2}`:`M ${o.x1} ${o.y1} H ${t} V ${o.y2} H ${o.x2}`}if("left"===o.from.side&&"right"===o.to.side){const t=Math.max(o.x2,d)+e+r,i=t<o.x1-e-r?o.x2+e+r:t,a=o.x1-e-r;return t>=o.x1-e-r&&(i>o.x1-r||a<o.x2-r)?`M ${o.x2} ${o.y2}\n                    H ${i}\n                    V ${(o.y1+o.y2)/2}\n                    H ${a}\n                    V ${o.y1}\n                    H ${o.x1}`:`M ${o.x2} ${o.y2} H ${t} V ${o.y1} H ${o.x1}`}if("right"===o.from.side&&"right"===o.to.side)return`M ${o.x1} ${o.y1} H ${Math.max(o.x1,o.x2,d)+e+r} V ${o.y2} H ${o.x2}`;if("left"===o.from.side&&"left"===o.to.side)return`M ${o.x1} ${o.y1} H ${Math.min(o.x1,o.x2,d)-e-r} V ${o.y2} H ${o.x2}`}return`M ${o.x1} ${o.y1} H ${d} V ${o.y2} H ${o.x2}`}orthogonalRenderLoopback(e,t,i,a,s){const n=this.viewModel.displayedGraph,o=new M(e,t,i,a,s),r=this.getShift(o.from,o.to,n,n.scaling)+30*n.scaling;if(void 0!==s.anchors&&s.anchors.length){const e=s.anchors.map((e=>({x:(e.x+n.panning.x)*n.scaling,y:(e.y+n.panning.y)*n.scaling}))),t=[{x:o.x1,y:o.y1}],i="right"===o.from.side?r:-r;return t.push({x:o.x1+i,y:o.y1}),e.forEach((e=>{t.push({x:t[t.length-1].x,y:e.y}),t.push({x:e.x,y:e.y}),t.push({x:e.x,y:e.y})})),t.push({x:t[t.length-1].x,y:o.y2}),t.push({x:o.x2+i,y:o.y2}),t.push({x:o.x2,y:o.y2}),t}const d=E(o.from,n.scaling,n.panning)+r;return"right"===o.from.side&&"left"===o.to.side?`M ${o.x1} ${o.y1}\n            h ${r}\n            V ${d} H ${o.x2-r} V ${o.y2} H ${o.x2}`:"left"===o.from.side&&"right"===o.to.side?`M ${o.x2} ${o.y2}\n            h ${r}\n            V ${d} H ${o.x1-r} V ${o.y1} H ${o.x1}`:"right"===o.from.side&&"right"===o.to.side?`M ${o.x2} ${o.y2}\n            h ${r}\n            V ${o.y1} H ${o.x1}`:"left"===o.from.side&&"left"===o.to.side?`M ${o.x2} ${o.y2}\n            h ${-r}\n            V ${o.y1} H ${o.x1}`:void 0}alternativeOrthogonalRender(e,t,i,a,s){const n=this.viewModel.displayedGraph,o=new M(e,t,i,a,s);if(void 0!==s.anchors&&s.anchors.length)return this.orthogonalAnchorsPath(s.anchors,o,n);const r=30*n.scaling,d=(o.x1+o.x2)/2;if(s.to){const e=this.getShift(o.from,o.to,n,n.scaling),t=this.getMaxShift(o.from,o.to,n,n.scaling)||1,i=Math.abs(o.x1-o.x2)-2*r,a=r*(2+t/n.scaling/30),s=i<a,c=2*a;let h;h=i<c?e/t*i:e/t*c+(i-c)/2;const l=this.someAboveOrBelow(o.from,o.to,n);if("right"===o.from.side&&"left"===o.to.side){const i=o.x1>o.x2;if(l&&s||i){const i=o.x1+r+e/t*a,s=o.x2-r+(e/t-1)*a;return`M ${o.x1} ${o.y1}\n                    H ${i}\n                    V ${(o.y1+o.y2)/2}\n                    H ${s}\n                    V ${o.y2}\n                    H ${o.x2}`}const n=o.x1+r+h;return`M ${o.x1} ${o.y1} H ${n} V ${o.y2} H ${o.x2}`}if("left"===o.from.side&&"right"===o.to.side){const i=o.x2>o.x1;if(l&&s||i){const i=o.x2+r+e/t*a,s=o.x1-r+(e/t-1)*a;return`M ${o.x2} ${o.y2}\n                    H ${i}\n                    V ${(o.y1+o.y2)/2}\n                    H ${s}\n                    V ${o.y1}\n                    H ${o.x1}`}const n=o.x2+r+h;return`M ${o.x2} ${o.y2} H ${n} V ${o.y1} H ${o.x1}`}if("right"===o.from.side&&"right"===o.to.side)return`M ${o.x1} ${o.y1} H ${Math.max(o.x1,o.x2,d)+e+r} V ${o.y2} H ${o.x2}`;if("left"===o.from.side&&"left"===o.to.side)return`M ${o.x1} ${o.y1} H ${Math.min(o.x1,o.x2,d)-e-r} V ${o.y2} H ${o.x2}`}return`M ${o.x1} ${o.y1} H ${d} V ${o.y2} H ${o.x2}`}alternativeOrthogonalRenderLoopback(e,t,i,a,s){return this.orthogonalRenderLoopback(e,t,i,a,s)}straightRender(e,t,i,a,s){const n=this.viewModel.displayedGraph;return[{x:e,y:t}].concat((s.anchors??[]).map((e=>({x:(e.x+n.panning.x)*n.scaling,y:(e.y+n.panning.y)*n.scaling})))).concat([{x:i,y:a}])}straightRenderLoopback(e,t,i,a,s){return this.curvedRenderLoopback(e,t,i,a,s)}constructor(e,t,i=!1){this.viewModel=e,this.style=t,this.randomizedOffset=i}render(e,t,i,a,s){const n=this.isLoopback(s)?"Loopback":"";return this[`${this.style}Render${n}`](e,t,i,a,s)}isLoopback(e){return!!e.to&&e.from.nodeId===e.to.nodeId}supportsAnchors(){return["orthogonal","alternativeOrthogonal","straight"].includes(this.style)}}var A=i(22048),T=i(23986);class C{constructor(){Object.entries(x.properties).forEach((([e,t])=>{this[e]=t.default}))}}const I="New Node Type",G="New Node Type",j="New Graph Node",H="New Graph Node",L="__new",R="__edited";async function _(e){const t=function(e){if(e.startsWith("data:application/json"))return e;let t,i="{}";"undefined"!=typeof document&&(i=`${document.location.href.split("/").slice(0,-1).join("/")}/{}`,t=new URLSearchParams(window.location.search));const a=e=>(e&&JSON.parse(e))??{},s={https:"https://{}",http:"http://{}",relative:`${i}`,...a(t?.get("jsonsubs")),...a({NODE_ENV:"production",VUE_APP_STATIC:"true",VUE_APP_VERBOSE:"false",VUE_APP_GRAPH_DEVELOPMENT_MODE:"false",BASE_URL:""}.VUE_APP_JSON_URL_SUBSTITUTES)},n=e.split("//");if(n.length<2)return;const o=n[0].substring(0,n[0].length-1),r=n.slice(1).join("");return Object.keys(s).includes(o)?s[o].replace("{}",r):void 0}(e);if(void 0===t)return[!1,`Could not download the resource from:  ${e}.`];let i;try{i=await fetch(t,{mode:"cors"})}catch(e){return[!1,e.message]}try{return[!0,await i.json()]}catch(e){return[!1,e.message]}}class P{static instance;defaultMetadata=new C;editor=new y.A;baklavaView=(0,n.AP)(this.editor);specificationLoaded=(0,o.KR)(!1);validating=(0,o.KR)(!1);specification=A.A.getInstance();updatedMetadata={};relatedGraphsStore=[];externalApplicationManager;constructor(){this.editor.editorManager=this,this.editor.unregisterNodes(),this.baklavaView.connectionRenderer=new O(this.baklavaView,this.defaultMetadata.connectionStyle,this.defaultMetadata.randomizedOffset),this.baklavaView.editor.layoutManager.useAlgorithm(this.defaultMetadata.layout),this.baklavaView.interfaceTypes=new v(this.baklavaView),this.baklavaView.layers=this.defaultMetadata.layers,this.baklavaView.collapseSidebar=this.defaultMetadata.collapseSidebar,this.baklavaView.movementStep=this.defaultMetadata.movementStep,this.baklavaView.editor.allowLoopbacks=this.defaultMetadata.allowLoopbacks,this.baklavaView.navbarItems=this.defaultMetadata.navbarItems,this.baklavaView.cache={},this.baklavaView.logLevel=this.defaultMetadata.logLevel,this.baklavaView.settings.editableNodeTypes=this.defaultMetadata.editableNodeTypes,this.baklavaView.settings.hideAnchors=this.defaultMetadata.hideAnchors,this.baklavaView.settings.showIds=this.defaultMetadata.showIds,this.baklavaView.settings.newGraphNode=this.defaultMetadata.newGraphNode,this.baklavaView.settings.showHiddenProperties=this.defaultMetadata.showHiddenProperties,this.specificationVersion=b.version,this.baklavaView.commandHandler=(0,n.TE)(),this.baklavaView.history=null,this.baklavaView.history=(0,c.W6)((0,o.ux)(this.baklavaView).displayedGraph,this.baklavaView.commandHandler),this.baklavaView.clipboard=function(e,t,i){const a=Symbol("ClipboardToken"),s=(0,o.KR)(""),r=(0,o.KR)(""),y=(0,o.KR)(0),v=(0,h.EW)((()=>!s.value)),m=(e,t,i)=>{for(let a=0;a<e.length;a+=1){let s;if(i&&"input"!==i||(s=Object.values(e[a].inputs).find((e=>e.id===t))),s||i&&"output"!==i||(s=Object.values(e[a].outputs).find((e=>e.id===t))),s)return s}};return i.registerCommand(u,{canExecute:()=>e.value.selectedNodes.length>0,execute:()=>{const{viewModel:t}=(0,n.if)();t.value.editor.readonly||((0,c.nb)(),e.value.selectedNodes.forEach((e=>{(0,l.bf)(e)})),(0,c.wH)())}}),i.registerHotkey(["Delete"],u),i.registerCommand(f,{canExecute:()=>!0,execute:()=>{e.value.selectedNodes=[]}}),i.registerHotkey(["Escape"],f),i.registerCommand(p,{canExecute:()=>!0,execute:()=>{const t=e.value.selectedNodes.flatMap((e=>[...Object.values(e.inputs),...Object.values(e.outputs)])),i=e.value.connections.filter((e=>t.includes(e.from)||t.includes(e.to))).map((e=>({from:e.from.id,to:e.to.id})));r.value=JSON.stringify(i),s.value=JSON.stringify(e.value.selectedNodes.map((e=>e.save()))),y.value=0}}),i.registerHotkey(["Control","c"],p),i.registerCommand(g,{canExecute:()=>!v.value,execute:()=>{var o;const{viewModel:h}=(0,n.if)();if(v.value||h.value.editor.readonly)return;(0,c.nb)();const l=null!==(o=h.value.movementStep)&&void 0!==o?o:1,p=new Map,u=JSON.parse(s.value),f=JSON.parse(r.value),g=[],b=[],w=e.value;i.executeCommand("START_TRANSACTION");for(let i=0;i<u.length;i+=1){const s=t.value.nodeTypes.get(u[i].name);if(!s)return;let n=new s.type;g.push(n),n.hooks.beforeLoad.subscribe(a,(e=>{const t=e;return t.position&&(y.value+=1,t.position.x+=y.value*Math.max(40,l),t.position.y+=y.value*Math.max(40,l)),void 0!==u[i].graphState&&u[i].graphState.nodes.forEach((e=>{void 0!==e.type&&(e.name=e.type)})),n.hooks.beforeLoad.unsubscribe(a),t})),n=w.addNode(n);const o=e=>{const t=(0,d.A)();p.set(e.id,t),e.id=t},r=e=>{o(e),void 0!==e.graphState?(o(e.graphState),e.graphState.nodes.forEach((e=>{r(e)})),e.interfaces.forEach((e=>{var t;e.id=null!==(t=p.get(e.id))&&void 0!==t?t:e.id,void 0!==e.externalName&&(e.externalName=w.resolveNewExposedName(e.externalName))})),e.graphState.connections.forEach((e=>{if(void 0===p.get(e.from)||void 0===p.get(e.to))throw new Error(`Error when executing copy and paste. Connection from interface ${e.from} to ${e.to} is invalid`);e.from=p.get(e.from),e.to=p.get(e.to)}))):e.interfaces.forEach((e=>{o(e),void 0!==e.externalName&&(e.externalName=w.resolveNewExposedName(e.externalName))}))};r(u[i]),n.load(Object.assign(Object.assign({},u[i]),{id:n.id})),void 0!==e.value.graphNode&&e.value.graphNode.updateExposedInterfaces()}for(let e=0;e<f.length;e+=1){const t=p.get(f[e].from),i=p.get(f[e].to);if(t&&i){const e=m(g,t,"output"),a=m(g,i,"input");if(e&&a){const t=w.addConnection(e,a);t&&b.push(t)}}}return(0,c.wH)(),{newNodes:g,newConnections:b}}}),i.registerHotkey(["Control","v"],g),i.registerCommand("CLEAR_CLIPBOARD",{canExecute:()=>!0,execute:()=>{s.value="",r.value=""}}),(0,o.Kh)({isEmpty:v})}((0,o.ux)(this.baklavaView).displayedGraph,(0,o.KR)(this.baklavaView.editor),this.baklavaView.commandHandler),this.modifiedNodeSpecificationRegistry={}}async preprocessSpecification(e,{unmarkNewNodes:t,urloverrides:i,tryMinify:a}){const s=[],n=[];this.globalVisitedSpecs=new Set;const o=Object.fromEntries(Object.entries({include:e.include,urloverrides:e.urloverrides}).filter((([e,t])=>void 0!==t))),{specification:r,errors:d,warnings:c}=await this.downloadNestedImports(o,void 0,i);if(s.push(...d),n.push(...c),s.length)return{errors:s,warnings:n};t&&n.push(...P.unmarkNewNodes(r));const{graphs:h,errors:l}=await P.includeGraphs([...r.includeGraphs??[],...e.includeGraphs??[]]);if(s.push(...l),s.length)return{errors:s,warnings:n};r.graphs=(r.graphs??[]).concat(h),this.specification.includedSpecification=JSON.parse(JSON.stringify(r));const{errors:p,warnings:u}=P.mergeObjects(e,r);if(s.push(...p),n.push(...u),s.length)return{errors:s,warnings:n};let f;if(delete e.include,delete e.includeGraphs,!0===a?f=e.graphs:a&&(f=a.graphs),f){const t=P.getUsedNames(f);e.nodes=P.minifySpecificationNodes(e.nodes,t)}const g=new Map((e.nodes??[]).filter((({subgraphId:e})=>e)).map((e=>[P.getNodeName(e),e])));return(e.graphs??[]).flatMap((e=>e.nodes)).filter((e=>!e.subgraph)).filter((e=>g.has(e.name))).forEach((e=>{e.subgraph=g.get(e.name).subgraphId})),{errors:s,warnings:n,specification:e}}async updateEditorSpecification(e,t=!1,i=!0,a=null,n=!1){if(!e)return{errors:["No specification passed"]};if("string"==typeof e||e instanceof String)try{e=s.parse(e)}catch(e){return{errors:[e],warnings:[]}}let r,d;this.isSpecificationLoaded()&&(r=this.saveDataflow(),d=this.baklavaView.displayedGraph.sidebar.nodeId,this.clearEditorManagerState());const c=[],h=[],l=[],{version:p}=e;if(this.specification.currentSpecification||(void 0===p?c.push(`Loaded specification has no version assigned. Please update the specification to version ${this.specificationVersion}.`):p!==this.specificationVersion&&l.push(`The specification format version (${p}) differs from the current specification format version (${this.specificationVersion}). It may result in unexpected behaviour.`)),i&&c.push(...P.unmarkNewNodes(e)),this.specification.unresolvedSpecification=(0,o.Kh)(JSON.parse(JSON.stringify(e))),this.specification.currentSpecification=e,!t){const{errors:t,specification:s}=await this.preprocessSpecification(e,{unmarkNewNodes:i,urloverrides:a,tryMinify:n});if(h.push(...t),h.length)return{errors:h,warnings:c,info:l};e=s;const{metadata:o}=e;if(h.push(...this.updateMetadata(o,!1,!0)),h.length)return{errors:h,warnings:c,info:l};const{errors:r,warnings:d}=await this.updateGraphSpecification(e);h.push(...r),c.push(...d)}if(0===h.length?this.setSpecificationLoaded(!0):this.clearEditorManagerState(),void 0!==r&&void 0===e.entryGraph&&(!(await this.loadDataflow(r)).errors.length&&d?(this.baklavaView.displayedGraph.sidebar.nodeId=d,this.baklavaView.displayedGraph.sidebar.visible=!0):this.relatedGraphsStore.forEach((e=>this.baklavaView.editor.registerGraph(e)))),this.externalApplicationManager){const e=this.specification.currentSpecification;await this.externalApplicationManager.notifyAboutChange("specification_on_change",{specification:e})}return{errors:h,warnings:c,info:l}}clearEditorManagerState(){this.baklavaView.editor.unregisterGraphs(),this.baklavaView.editor.deepCleanEditor(),this.baklavaView.editor.unregisterNodes(),this.baklavaView.editor.nodeStyles.clear(),this.setSpecificationLoaded(!1),this.specification.currentSpecification={},this.specification.includedSpecification={},this.specification.unresolvedSpecification=(0,o.Kh)({})}isSpecificationLoaded(){return"boolean"==typeof this.specificationLoaded?this.specificationLoaded:this.specificationLoaded.value}setSpecificationLoaded(e){"boolean"==typeof this.specificationLoaded?this.specificationLoaded=e:this.specificationLoaded.value=e}setValidating(e){"boolean"==typeof this.validating?this.validating=e:this.validating.value=e}async downloadNestedImports(e,t=new Set,i=null){const a=[],s=[],n=[],o=new Set,r=e.include??[];return await Promise.all(r.map((async e=>{let i;if("object"==typeof e&&null!==e&&({url:e,style:i}=e),o.has(e))s.push(`Specification is included multiple times, skipping ${e}`);else if(t.has(e))s.push(`Circular dependency detected in included specification ${e}`);else if(o.add(e),!this.globalVisitedSpecs.has(e)){this.globalVisitedSpecs.add(e);const[a,o]=await _(e);!1===a?s.push(`Could not load the included specification from ${e}. Reason: ${o}`):n.push({specification:o,trace:new Set([...t,e]),style:i})}}))),s.length||await Promise.all(n.map((async({specification:t,trace:n,style:o})=>{const{specification:r,errors:d,warnings:c}=await this.downloadNestedImports(t,n,i);s.push(...d),a.push(...c),void 0!==o&&P.includeWithStyle(r,o),P.applyUrlOverrides(r,{...e.urloverrides??{},...i??{}});const{errors:h,warnings:l}=P.mergeObjects(e,r);s.push(...h),a.push(...l)}))),{specification:e,errors:s,warnings:a}}static async includeGraphs(e){const t=[],i=[];if(0===e.length)return{graphs:i,errors:t};if(e.length!==new Set(e).size)return t.push("Duplicate subgraph includes detected. Aborting."),{graphs:i,errors:t};const a=[];if(await Promise.all(e.map((async e=>{const[i,s]=await _(e.url);!1!==i?a.push(s):t.push(`Could not load the included dataflow from '${e.url}'. Reason: ${s}`)}))),t.length)return{graphs:i,errors:t};for(let s=0;s<e.length;s+=1){const n=a[s],o=e[s];if(1!==n.graphs.length){t.push(`Only single graph dataflows are supported. Aborting loading subgraph include from ${o.url}.`);continue}const r=n.graphs[0];r.name=o.name??r.name,i.push(r)}return{graphs:i,errors:t}}registerDefaultNodes(){const e=[],t=[];if(this.editor.nodeTypes.has(H))return e.push(`Node name '${j}' is reserved by the editor, but it was included in the specification. Please change the name of the graph node to avoid conflicts.`),{errors:e,warnings:t};if(this.editor.nodeTypes.has(G))return e.push(`Node name '${I}' is reserved by the editor, but it was included in the specification. Please change the name of the graph node to avoid conflicts.`),{errors:e,warnings:t};const i={name:I,category:"Default"};this._registerNodeType(i);const a={name:j,category:"Graphs"},s=(0,m.$o)([],[],j,this.baklavaView.editor);return a.subgraphId=s.id,Array.isArray(s)&&s.length?e.push(...s):this.baklavaView.editor.addGraphTemplate(s,a),{errors:e,warnings:t}}updateExtendingNodes(e,t){const i=this.specification.unresolvedSpecification.nodes.filter((e=>e.extends?.includes(t)))??[],a=this.specification.currentSpecification.nodes.filter((e=>e.extends?.includes(t)))??[];[...i,...a].forEach((i=>{i.category=e.category,i.extends.forEach(((a,s)=>{a===t&&(i.extends[s]=P.getNodeName(e))}))})),new Map(a.map((e=>[e.name,e]))).forEach(((e,t)=>{this._unregisterNodeType(t);const{viewModel:i}=(0,n.if)(),{editor:a}=i.value;Array.from(a.graphs).map((e=>e.nodes)).flat().filter((e=>e.type===t)).forEach((t=>{Object.entries(structuredClone((0,o.ux)(e))).forEach((([e,i])=>{void 0!==i&&"interfaces"!==e&&"properties"!==e&&(t[e]=structuredClone((0,o.ux)(i)))}))})),this._registerNodeType(structuredClone((0,o.ux)(e)))}))}updateParentNode(e,t,i=!1){e?.extends?.forEach((a=>{const s=this.baklavaView.editor.parentNodes.get(a);s.extending?.includes(t)&&(i?s.extending.splice(s.extending.indexOf(t),1):s.extending.splice(s.extending.indexOf(t),1,e.name))})),this.baklavaView.editor.parentNodes.has(t)&&this.baklavaView.editor.parentNodes.delete(t),i||this.baklavaView.editor.parentNodes.set(e.name,e)}refreshSubgraph(e){let t,i;if(this.specification.currentSpecification.graphs?.forEach((a=>{e.subgraphId===a.id&&(t=e,i=a)})),i){const e=(0,m.$o)(i.nodes,i.connections,i.name,this.baklavaView.editor);this.baklavaView.editor.addGraphTemplate(e,t)}}addNodeToEditorSpecification(e,t=void 0,i=!0){Object.entries(e.properties??{}).forEach((([e,t])=>{Object.keys(t).forEach((e=>{void 0===t[e]&&delete t[e]}))})),Object.entries(e.interfaces??{}).forEach((([e,t])=>{Object.keys(t).forEach((e=>{void 0===t[e]&&delete t[e]}))}));let a=this.validateNode(e);if(a.length)return{errors:a};if(void 0===this.specification.currentSpecification)return{errors:["Current specification cannot be empty"]};if(this.specification.unresolvedSpecification.nodes??=[],void 0!==t){const s=this.specification.unresolvedSpecification.nodes.find((e=>P.getNodeName(e)===t)),n=this.specification.currentSpecification.nodes.find((e=>P.getNodeName(e)===t));if(void 0===n){if(Object.entries(e).forEach((([e,t])=>{void 0!==t&&(s[e]=structuredClone((0,o.ux)(t)))})),a=this._registerNodeType(s),a.length)return{errors:a,warnings:[]}}else{void 0===s?(e.includeName=t,this.specification.unresolvedSpecification.nodes.push(e)):(i&&Object.keys(s).filter((t=>!(t in e))).forEach((e=>{delete s[e]})),Object.entries(e).forEach((([e,t])=>{void 0!==t&&(s[e]=JSON.parse(JSON.stringify(t)))}))),Object.entries(e).forEach((([e,t])=>{void 0!==t&&(n[e]=JSON.parse(JSON.stringify(t)))}));const o=P.getNodeName(e);n.name=o;const r=this.specification.currentSpecification.nodes.filter((e=>e.extends?.includes(t))).map((e=>P.getNodeName(e)));if(void 0!==r&&(n.extending=r),a=this._registerNodeType(n),a.length)return{errors:a,warnings:[]};this.baklavaView.editor.nodeTypes.get(o).isCategory&&this.updateExtendingNodes(JSON.parse(JSON.stringify(e)),t),e.name!==t&&(this.updateParentNode(n,t),[...this.specification.unresolvedSpecification.graphs??[],...this.specification.currentSpecification.graphs??[]].forEach((i=>{i.nodes.filter((e=>e.name===t)).forEach((t=>{t.name=e.name}))})),[...this.specification.unresolvedSpecification.nodes??[],...this.specification.currentSpecification.nodes??[]].forEach((e=>{this.refreshSubgraph(e)}))),void 0!==n.subgraphId&&this.refreshSubgraph(n)}}else{if(a=this._registerNodeType(e),a.length)return{errors:a,warnings:[]};this.specification.unresolvedSpecification.nodes.push(e)}if(this.externalApplicationManager){const e=this.specification.unresolvedSpecification;this.externalApplicationManager.notifyAboutChange("specification_on_change",{specification:e}).then()}return this.editor.additionalNodeTypes.add(e.name),{errors:[],warnings:[]}}removeNodeType(e){this._unregisterNodeType(e),this.baklavaView.editor.graphs.forEach((t=>{t.nodes.filter((t=>t.type===e)).forEach((e=>t.removeNode(e)))}));const t=this.specification.currentSpecification.nodes.find((t=>P.getNodeName(t)===e));if(this.specification.unresolvedSpecification.nodes=this.specification.unresolvedSpecification.nodes.filter((t=>P.getNodeName(t)!==e)),this.specification.currentSpecification.nodes=this.specification.currentSpecification.nodes.filter((t=>P.getNodeName(t)!==e)),this.specification.unresolvedSpecification.graphs?.forEach((t=>{t.nodes=t.nodes.filter((t=>t.name!==e))})),this.specification.currentSpecification.graphs?.forEach((t=>{t.nodes=t.nodes.filter((t=>t.name!==e))})),this.specification.unresolvedSpecification.nodes.filter((e=>void 0!==e.extends)).forEach((t=>{t.extends=t.extends.filter((t=>t!==e))})),this.specification.currentSpecification.nodes.filter((e=>void 0!==e.extends)).forEach((t=>{t.extends=t.extends.filter((t=>t!==e))})),void 0!==t&&this.updateParentNode(t,e,!0),this.externalApplicationManager){const e=this.specification.unresolvedSpecification;this.externalApplicationManager.notifyAboutChange("specification_on_change",{specification:e}).then()}this.editor.additionalNodeTypes.delete(e)}addSubgraphToNode(e,t=[],i=[]){this._unregisterNodeType(e.type);const a=(0,m.$o)(t,i,e.type,this.baklavaView.editor);if(Array.isArray(a)&&a.length)return a;const s=this.specification.unresolvedSpecification.nodes?.find((t=>P.getNodeName(t)===e.type)),o=this.specification.currentSpecification.nodes?.find((t=>P.getNodeName(t)===e.type));void 0===o?(s.subgraphId=a.id,this.baklavaView.editor.addGraphTemplate(a,s)):(o.subgraphId=a.id,void 0===s?(void 0===this.specification.unresolvedSpecification.nodes&&(this.specification.unresolvedSpecification.nodes=[]),this.specification.unresolvedSpecification.nodes.push(o)):s.subgraphId=a.id,this.baklavaView.editor.addGraphTemplate(a,o));const{viewModel:r}=(0,n.if)(),{displayedGraph:d}=r.value;return d.nodes.filter((t=>t.type===e.type)).forEach((t=>{d.replaceNode(t,e.type)})),[]}_registerNodeType(e){if(this.baklavaView.editor.nodeTypes.has(e.name))return[`Node of type ${e.name} is already registered`];const t=(0,m.Wo)(e.name,e.layer,e.interfaces??[],e.properties??[],e.interfaceGroups??[],e.defaultInterfaceGroups??[],e.twoColumn??this.baklavaView.twoColumn??!1,e.description??"",e.extends??[],e.extending??[],e.siblings??[],e.width??300);if(Array.isArray(t)&&t.length)return t;if(this.baklavaView.editor.registerNodeType(t,{title:e.name,category:e.category,isCategory:e.isCategory??!1,color:e.color,style:e.style,pill:e.pill,subgraphId:e.subgraphId,relatedGraphs:e.relatedGraphs}),"icon"in e){const t="string"==typeof e.icon?e.icon:this.getMetadataIcon(e.icon);this.baklavaView.editor.nodeIcons.set(e.name,t)}return"urls"in e&&Object.entries(e.urls).forEach((([t,i])=>{this.baklavaView.editor.nodeURLs.has(e.name)||this.baklavaView.editor.nodeURLs.set(e.name,{}),this.baklavaView.editor.nodeURLs.get(e.name)[t]=i})),[]}getMetadataIcon(e){const[[t,i]]=Object.entries(e),a=this.baklavaView.editor.baseIconUrls.get(t);return`${a}${a.endsWith("/")?"":"/"}${i}`}_unregisterNodeType(e){return this.baklavaView.editor.nodeTypes.has(e)?(this.baklavaView.editor.unregisterNodeType(e),[]):[`Node of type ${e} is not registered`]}static getSubgraphs(e,t,i=!0){const a=t?.find((t=>t.id===e)),s=Object.fromEntries(t.map((e=>[e.id,e]))),n=[],o=e=>{if(n.includes(e.id))return;n.push(e.id);const t=e.nodes?.map((e=>e.subgraph))??[],i=e.nodes?.map((e=>e.relatedGraphs?.map((({id:e})=>e))??[])).flat()??[];t.concat(i).filter((e=>void 0!==e)).map((e=>s[e])).forEach(o)};return o(a),n.filter((t=>t!==e||i)).map((e=>s[e]))}async updateGraphSpecification(e){const t=[];if(!e)return{errors:["No specification passed"],warnings:t};const{nodes:i,graphs:a,metadata:s}=e;if(void 0===i&&void 0===a)return{errors:[],warnings:t};let n=[];i?.forEach((e=>{e.abstract&&this.baklavaView.editor.parentNodes.set(e.name,e)}));try{const e=P.preprocessNodes(i??[]);n=this.resolveInheritance(e)}catch(e){return{errors:[e.message],warnings:t}}n.forEach((e=>{e.isCategory&&this.baklavaView.editor.parentNodes.set(e.name,e)}));const o=[];if(o.push(...this.validateResolvedSpecification({graphs:a,nodes:n,metadata:s})),o.length)return{errors:o,warnings:t};if(this.specification.currentSpecification.nodes=JSON.parse(JSON.stringify(n)),this.specification.currentSpecification.graphs=JSON.parse(JSON.stringify(a)),n.forEach((e=>{(e.extends??[]).forEach((t=>{const i=n.find((e=>e.name===t));void 0!==i&&(void 0===i.extending&&(i.extending=[]),i.extending.push(e.name))}))})),n.forEach((e=>{const t=new Set;(e.extends??[]).forEach((e=>{const i=n.find((t=>t.name===e));void 0!==i&&i.extending.forEach((e=>t.add(e)))})),t.delete(e.name),e.siblings=Array.from(t)})),n.forEach((e=>{e.extends&&(e.extends=e.extends.filter((e=>void 0!==n.find((t=>t.name===e)))))})),n.forEach((e=>{o.push(...this.validateNodeStyle(e)),o.push(...this._registerNodeType(e))})),o.length)return{errors:o,warnings:t};if("boolean"==typeof this.validating?this.validating=!0:this.validating.value=!0,this.setValidating(!0),this.relatedGraphsStore=[],void 0!==a){const s=i.filter((({subgraphId:e})=>void 0!==e)),c=i.map((e=>e.relatedGraphs?.map((({id:e})=>e)))).filter((e=>void 0!==e)).flat(),h=async(i,s=[])=>{const n=P.getSubgraphs(i.id,a).map((e=>structuredClone(e))),{errors:r,warnings:d}=await this.loadDataflow({graphs:n,version:e.version},...s);this.baklavaView.editor.deepCleanEditor(),this.baklavaView.editor.unregisterGraphs(),d.length&&t.push(`Graph '${i.name??i.id}' is invalid:`,...d.map((e=>`    ${e}`))),r.length&&o.push(`Graph '${i.name??i.id}' is invalid:`,...r.map((e=>`    ${e}`)))};for(const e of s){const t=e.subgraphId,i=a.find((({id:e})=>e===t));if(void 0===i){o.push([`The subgraph with ID ${t} was not found`]);continue}const s=(0,m.$o)(i.nodes,i.connections,i.name,this.baklavaView.editor);if(Array.isArray(s)&&s.length){o.push(...s);continue}this.baklavaView.editor.addGraphTemplate(s,n.find((t=>t.name===e.name)));const r=[!0,!0,e.name];await h(i,r),this.baklavaView.editor.deepCleanEditor(),this.baklavaView.editor.unregisterGraphs()}for(const e of c){const t=a.find((({id:t})=>t===e));if(void 0===t){o.push([`The related graph with ID ${e} was not found`]);continue}const i=[!0,!0];if(await h(t,i),this.relatedGraphsStore.find((t=>e===t.id)))continue;const s=new r.TS(this.baklavaView.editor);s.load(t),this.relatedGraphsStore.push(s)}this.relatedGraphsStore.forEach((e=>this.baklavaView.editor.registerGraph(e))),this.editor._graph.id=(0,d.A)()}this.setValidating(!1);const c=[...new Set(t)],{errors:h,warnings:l}=this.registerDefaultNodes();o.push(...h),c.push(...l);const p=e.entryGraph;if(!o.length&&void 0!==p)if(a?.some((e=>e.id===p))){const{errors:t}=await this.loadDataflow({graphs:a,version:e.version,entryGraph:p});if(t&&0!==t.length){t.forEach((e=>o.push(e)));const e=new r.TS(this.baklavaView.editor);this.baklavaView.editor.displayedGraph=e,this.baklavaView.editor.deepCleanEditor(),this.baklavaView.editor.unregisterGraphs()}}else c.push(`'entryGraph' points to undefined graph: '${p}'`);return{errors:o,warnings:c}}static preprocessNodes(e){return e.filter((e=>e.isCategory)).forEach((e=>{e.name=P.getNodeName(e)})),e}updateMetadata(e=void 0,t=!1,i=!1){let a;if(i&&(this.updatedMetadata={}),void 0!==e&&(e={...this.updatedMetadata,...e},a=JSON.parse(JSON.stringify(e))),void 0===e&&this.specification.currentSpecification&&(e=this.specification.currentSpecification.metadata??{}),!e)return["No specification to load provided."];if(t){const t=e;e=JSON.parse(JSON.stringify(this.specification.currentSpecification?.metadata??{})),P.mergeObjects(e,t)}return this.baklavaView.interfaceTypes.readInterfaceTypes(e),e&&"urls"in e&&Object.entries(e.urls).forEach((([e,t])=>{this.baklavaView.editor.baseURLs.set(e,t)})),e&&"icons"in e&&Object.entries(e.icons).forEach((([e,t])=>{this.baklavaView.editor.baseIconUrls.set(e,t)})),e&&"navbarItems"in e&&(this.baklavaView.navbarItems=JSON.parse(JSON.stringify(e.navbarItems))),this.baklavaView.editor.readonly=e?.readonly??this.defaultMetadata.readonly,this.baklavaView.editor.hideHud=e?.hideHud??this.defaultMetadata.hideHud,this.baklavaView.editor.nodeStyles.set(L,{icon:"NewNode"}),this.baklavaView.editor.nodeStyles.set(R,{icon:"EditedNode"}),Object.entries(e?.styles??{}).forEach((([e,t])=>{this.baklavaView.editor.nodeStyles.set(e,t)})),this.editor.allowLoopbacks=e?.allowLoopbacks??this.defaultMetadata.allowLoopbacks,this.baklavaView.twoColumn=e?.twoColumn??this.defaultMetadata.twoColumn,this.baklavaView.connectionRenderer.style=e?.connectionStyle??this.defaultMetadata.connectionStyle,this.baklavaView.movementStep=e?.movementStep??this.defaultMetadata.movementStep,this.baklavaView.settings.background.gridSize=e?.backgroundSize??this.defaultMetadata.backgroundSize,this.baklavaView.connectionRenderer.randomizedOffset=e?.randomizedOffset??this.defaultMetadata.randomizedOffset,this.baklavaView.settings.toggleableEditableTypes=e?.toggleableEditableTypes??this.defaultMetadata.toggleableEditableTypes,this.baklavaView.settings.editableNodeTypes=e?.editableTypes??this.defaultMetadata.editableNodeTypes,this.baklavaView.settings.hideAnchors=e?.hideAnchors??this.defaultMetadata.hideAnchors,this.baklavaView.settings.showIds=e?.showIds??this.defaultMetadata.showIds,this.baklavaView.settings.newGraphNode=e?.newGraphNode??this.defaultMetadata.newGraphNode,this.baklavaView.settings.showHiddenProperties=e?.showHiddenProperties??this.defaultMetadata.showHiddenProperties,this.baklavaView.ignoredLayers=new Set,this.baklavaView.layers=e?.layers??this.defaultMetadata.layers,this.baklavaView.collapseSidebar=e?.collapseSidebar??this.defaultMetadata.collapseSidebar,this.baklavaView.editor.layoutManager.useAlgorithm(e?.layout??this.defaultMetadata.layout),this.baklavaView.logLevel=e?.logLevel??this.defaultMetadata.logLevel,this.baklavaView.welcome=e?.welcome??this.defaultMetadata.welcome,a&&(this.updatedMetadata=a),[]}resolveInheritance(e){const t=JSON.parse(JSON.stringify(e)),i=e=>"object"==typeof e&&null!==e&&!Array.isArray(e),a=e=>Array.isArray(e),s=(e,t)=>{const n={...structuredClone(t)};return["abstract","isCategory"].forEach((e=>{delete n[e]})),i(e)&&i(t)&&Object.keys(e).forEach((o=>{if("style"===o)n[o]=P.mergeStyles(t[o],e[o]);else if(i(e[o]))n[o]=o in n?s(e[o],t[o]):e[o];else if(a(e[o])&&a(t[o]))if("extends"===o)n[o]=e[o];else{const i=Object.fromEntries(t[o].map(((e,t)=>[e.name,t])));e[o].forEach((a=>{if(a.name&&a.name in i){const s=i[a.name];if(!a.override)throw new Error(`'${e.name}' node cannot override '${a.name}' property of '${t.name}' node`);n[o][s]={...t[o][s],...a},delete n[o][s].override}else n[o].push(a)}))}else n[o]=e[o]})),n},n={},o=t=>{if(t in n)return n[t];let i,a=e.find((e=>e.name===t));if(!a.extends)return n[t]=a,a;if(new Set(a.extends).size!==a.extends.length)throw new Error(`Repeated class in "extends" list of "${a.name}" node`);return a.extends.forEach((e=>{i=o(e),a=s(a,i)})),n[t]=a,a};return t.filter((e=>!e.abstract)).map((e=>o(e.name)))}validateNodeStyle(e){const t=[];if(void 0===e.style)return t;const i=Array.isArray(e.style)?e.style:[e.style],a=new Set(i);return a.size!==i.length&&t.push(`Repeated styles in "${P.getNodeName(e)}" node`),t.push(...Array.from(a).filter((e=>!this.baklavaView.editor.nodeStyles.has(e))).map((t=>`Non-existing style "${t}" in '${P.getNodeName(e)}' node`))),t}saveSpecification(){const e=JSON.parse(JSON.stringify(this.specification.unresolvedSpecification));return P.unmarkNewNodes(e),e}static unmarkNewNodes(e){const t=[],i=e=>{t.push(`Loaded node '${P.getNodeName(e)}' has '${L}' style, removing it.`)};return e.nodes?.forEach((e=>{e.style===L?(i(e),delete e.style):Array.isArray(e.style)&&e.style.includes(L)&&(i(e),e.style.splice(e.style.indexOf(L),1))})),t}getRootGraph(){return this.editor.subgraphStack.length?this.editor.subgraphStack[0]:this.editor.graph}saveDataflow({readonly:e,hideHud:t,position:i,graphName:a}={}){const s=this.baklavaView.editor.save();s.version=this.specificationVersion;const n=s.entryGraph?s.graphs.find((e=>e.id===s.entryGraph)):s.graphs[0];if(n&&null!=a){const e=this.getRootGraph();n.name=a,e.name=a,e===this.editor.graph&&(this.baklavaView.editor.graphName=a)}return i||s.graphs.forEach((e=>{delete e.panning,delete e.scaling})),void 0===s.metadata&&(s.metadata={}),[[e,"readonly"],[t,"hideHud"],[this.editor.allowLoopbacks,"allowLoopbacks"],[this.baklavaView.twoColumn,"twoColumn"],[this.baklavaView.connectionRenderer.style,"connectionStyle"],[this.baklavaView.movementStep,"movementStep"],[this.baklavaView.settings.background.gridSize,"backgroundSize"],[this.baklavaView.connectionRenderer.randomizedOffset,"randomizedOffset"],[this.baklavaView.settings.editableNodeTypes,"editableTypes"],[this.baklavaView.settings.toggleableEditableTypes,"toggleableEditableTypes"],[this.baklavaView.settings.hideAnchors,"hideAnchors"],[this.baklavaView.settings.showIds,"showIds"],[this.baklavaView.settings.newGraphNode,"newGraphNode"],[this.baklavaView.settings.showHiddenProperties,"showHiddenProperties"]].forEach((([e,t])=>{const i=this.specification.currentSpecification?.metadata??{},a=this.defaultMetadata;e!==(i[t]??a[t])&&(s.metadata[t]=e)})),0===Object.keys(s.metadata).length&&delete s.metadata,s}async loadDataflow(e,t=!1,i=!1,a=null){let{notifyWhenChanged:n}=this;this.updateMetadata({notifyWhenChanged:!1},!0,!0);try{const o=P.validateDataflow(e);if(o.length)return{errors:o,warnings:[]};try{("string"==typeof e||e instanceof String)&&(e=s.parse(e));const o=e.version,r=[],d=[];if(void 0===o?r.push(`Loaded dataflow has no version assigned. Please update the dataflow to version ${this.specificationVersion}.`):o!==this.specificationVersion&&d.push(`Dataflow version (${o}) differs from the current version (${this.specificationVersion}). It may result in unexpected behaviour.`),"metadata"in e&&void 0!==this.specification.currentSpecification){const t=P.validateMetadata(e.metadata);if(Array.isArray(t)&&t.length)return{errors:t,warnings:r};n=e.metadata.notifyWhenChanged??n,this.updateMetadata({...e.metadata,notifyWhenChanged:!1},!0,!0)}void 0!==this.baklavaView.displayedGraph&&this.baklavaView.history.unsubscribeFromGraphEvents(this.baklavaView.displayedGraph,Symbol("HistoryToken"));let c=!0;try{c=window.isWebpack}catch{c=!1}const h={};return c?Object.assign(h,{errors:[],warnings:[]}):(Object.assign(h,{errors:await this.baklavaView.editor.load(e,t,i,a),warnings:r,info:d}),this.baklavaView.history.graphSwitch(this.baklavaView.displayedGraph,this.baklavaView.displayedGraph)),this.verifyExposedInterfaceNamesMatchExternalNames(e),h}catch(e){return{errors:["Unrecognized format. Make sure that the passed dataflow is correct.",e.toString()],warnings:[],info:[]}}}finally{this.updateMetadata({notifyWhenChanged:n},!0)}}verifyExposedInterfaceNamesMatchExternalNames(e){const t=new Map;e.graphs.forEach((e=>{e.nodes.forEach((e=>{e.interfaces.forEach((e=>{t.has(e.id)?t.get(e.id).push(e):t.set(e.id,[e])}))}))})),t.forEach(((e,t)=>{if(e.length<2)return;const i=e.find((e=>void 0!==e.externalName));if(void 0===i)throw new Error(`The interface with id = ${t} seems to be exposed but lacks "externalName" property.`);e.forEach((e=>{if(e===i||i.externalName===e.name)return;const a=`Mismatch between "externalName" of the original interface and "name" of the exposed version of the interface, for the interface with id = ${t}\nExpected: ${i.externalName}\nGot: ${e.name}`;throw new Error(a)}))}))}static getEditorManagerInstance(){return P.instance||(P.instance=new P),P.instance}static applyUrlOverrides(e,t){Object.entries(t).forEach((([t,i])=>{Object.entries(e.metadata?.icons??{}).forEach((([a,s])=>{e.metadata.icons[a]=s.replaceAll(t,i)})),Object.values(e.metadata?.urls??{}).forEach((e=>{e.url=e.url.replaceAll(t,i)}))}))}static includeWithStyle(e,t){e.nodes?.forEach((e=>{const i=P.mergeStyles(e.style,t);void 0!==i&&(e.style=i)}))}static mergeStyles(e,t){return e===t?e:void 0===(e&&t)?e??t:([e,t]=[e,t].map((e=>Array.isArray(e)?e:[e])).map((e=>new Set(e))),e=e.difference(t),Array.from(e.union(t)))}static mergeObjects(e,t){const i=[],a=[];return t=t??{},void 0===e||0===Object.keys(e).length||Object.entries(t).forEach((([t,s])=>{if(Array.isArray(s)&&Array.isArray(e[t])){if("graphs"===t){const i=[s,e[t]].map((e=>e.map((e=>[e.id,e])))).map(Object.fromEntries);return void(e[t]=Object.values(Object.assign({},...i)))}if("nodes"!==t)return void e[t].push(...s);try{const a=Object.fromEntries(e[t].filter((e=>e.includeName)).map((e=>[e.includeName,P.getNodeName(e)]))),n=new Set,o=e=>{const t=P.getNodeName(e),i=a[t];return void 0!==i&&n.add(t),i??t},r=[s.map((e=>[o(e),e])),e[t].map((e=>[P.getNodeName(e),e]))].map(Object.fromEntries);e[t]=Object.values(Object.assign({},...r));const d=Object.keys(a).filter((e=>!n.has(e)));d.length&&i.push(`Unused include names: ${d}`)}catch(e){a.push(e)}}else if("object"==typeof s&&"object"==typeof e[t]){const{errors:n,warnings:o}=P.mergeObjects(e[t],s);a.push(...n),i.push(...o)}else void 0===e[t]&&(e[t]=s)})),{errors:a,warnings:i}}static getNodeName(e){if(!e.isCategory){if(void 0===e.name)throw new Error("Non-category node has to define field 'name'");return e.name}const t=e.category.split("/").at(-1);if(void 0!==e.name&&e.name!==t)throw new Error(`Node '${e.name}' is a category node and has a name defined different than ${t}`);return t}static validateJSONWithSchema(e,t,i="",s={}){const n=new a({allowUnionTypes:!0,addUsedSchema:!1,formats:{hex:/^0x[a-fA-F0-9]+$/},schemas:[b,w,x,$,N],...s});return n.addKeyword("version"),(0,T.A)(n,t,e,i)}validateResolvedSpecification(e){const t=P.validateSpecification(e,w);if(t.length)return t;const{nodes:i}=e,a=i.filter((e=>e.isCategory)),s={},n=[];a.forEach((e=>{e.name in s?n.push(`Category '${e.category}' has multiple nodes defining it.`):s[e.name]=e.category.split("/").slice(0,-1).join("/")}));const o=new Set;return i.forEach((e=>{void 0===e.category&&(e.category="");const t=e.category.split("/");for(let i=t.length-1;i>=0;i-=1){const a=t[i],o=t.slice(0,i).join("/");if(a in s&&e.name!==a&&o===s[a]){void 0!==e.extends&&e.extends.includes(a)||n.push(`Node '${e.name}' does not extend its category node '${a}'.`);break}}for(let t=0;t<(e.extends??[]).length;t+=1){const i=e.extends[t];if(i in s){const t=""!==s[i]?`${s[i]}/${i}`:i;if(!e.category.includes(t)){n.push(`Node '${e.name}' extends from a category node '${i}' but is not in its category`);break}}}o.has(e.name)&&n.push(`Node '${e.name}' is defined multiple times`),o.add(e.name)})),n}validateNode(e,t=b){return P.validateJSONWithSchema(e,t,"#/$defs/node")}validateNodeProperty(e,t=b){return P.validateJSONWithSchema(e,t,"#/$defs/property")}validateNodeInterface(e,t=b){return P.validateJSONWithSchema(e,t,"#/$defs/interface")}static validateSpecification(e,t=b){return P.validateJSONWithSchema(e,t)}static validateMetadata(e){return P.validateJSONWithSchema(e,x)}static validateDataflow(e){return P.validateJSONWithSchema(e,$)}static validateMessage(e){return P.validateJSONWithSchema(e,S)}returnFromSubgraph(){this.baklavaView.editor.backFromSubgraph(this.baklavaView.displayedGraph)}getParentGraph(){let e;return Array.from(this.baklavaView.editor.graphs).filter((e=>e.id!==this.baklavaView.displayedGraph.id)).forEach((t=>{t.nodes.forEach((i=>{i.subgraph?.id===this.baklavaView.displayedGraph.id&&(e=t)}))})),e}switchToGraph(e){this.baklavaView.editor.switchToGraph(e)}centerZoom(){this.baklavaView.editor.centerZoom()}updateSubgraphName(e){this.editor.updateCurrentSubgraphName(e)}get notifyWhenChanged(){return this.updatedMetadata.notifyWhenChanged??this.specification.currentSpecification?.metadata?.notifyWhenChanged??this.defaultMetadata.notifyWhenChanged}static getUsedNames(e){return e?.map((e=>e.nodes.map(this.getNodeName))).flat()??[]}static minifySpecificationNodes(e,t){const i=Object.fromEntries(e.map((e=>[this.getNodeName(e),e]))),a=e=>i[e],s=[],n=e=>{if(void 0===e)return;const t=this.getNodeName(e);s.includes(t)||(s.push(t),e.extends?.map(a).forEach(n))};return t.map(a).forEach(n),s.map(a).filter((e=>void 0!==e))}isInSubgraph(){return this.editor.isInSubgraph()}}},41857:(e,t,i)=>{i.d(t,{$4:()=>u,W6:()=>y,nb:()=>f,wH:()=>g});var a=i(50953),s=i(20641),n=i(42302),o=i(8328);const r=(0,a.KR)(!1),d=(0,a.KR)("");class c{constructor(e,t,i=(0,n.A)()){Object.defineProperty(this,"type",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"transactionId",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"topic",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.type=e,this.topic=t,this.transactionId=i}add(e){throw new Error(`Method add has thrown an error for topic: ${this.topic}`)}remove(e){throw new Error(`Method remove has thrown an error for topic: ${this.topic}`)}edit(e){throw new Error(`Method edit has thrown an error for topic: ${this.topic}`)}}class h extends c{constructor(e,t,i=(0,n.A)()){""===i&&(i=(0,n.A)()),super(e,t,i),Object.defineProperty(this,"nodeTuple",{enumerable:!0,configurable:!0,writable:!0,value:[]})}add(e){void 0!==this.nodeTuple[0]&&e.value.addNode(this.nodeTuple[0]).load(this.nodeTuple[1])}remove(e){const t=e.value.nodes.find((e=>e.id===this.topic));void 0!==t&&(this.nodeTuple=[t,t.save()],e.value.removeNode(t))}edit(e){if(void 0!==this.nodeTuple[0]){const t=[...Object.values(this.nodeTuple[0].inputs),...Object.values(this.nodeTuple[0].outputs)],i=e.value.connections.filter((e=>t.includes(e.from)||t.includes(e.to)));e.value.removeNode(this.nodeTuple[0]);const a=e.value.addNode(this.nodeTuple[0]),s=this.nodeTuple[1];this.nodeTuple=[this.nodeTuple[0],this.nodeTuple[0].save()],a.load(s),i.forEach((t=>{e.value.addConnection(t.from,t.to)}))}}}class l extends c{constructor(e,t,i=(0,n.A)()){""===i&&(i=(0,n.A)()),super(e,t,i),Object.defineProperty(this,"conn",{enumerable:!0,configurable:!0,writable:!0,value:void 0})}add(e){if(void 0!==this.conn){const t=e.value.findNodeById(this.conn.from.nodeId),i=e.value.findNodeById(this.conn.to.nodeId);if(!t||!i)return;const a=[...Object.values(t.inputs),...Object.values(t.outputs)].filter((e=>e.port)).find((e=>e.id===this.conn.from.id)),s=[...Object.values(i.inputs),...Object.values(i.outputs)].filter((e=>e.port)).find((e=>e.id===this.conn.to.id));if(!a||!s)return;const n=e.value.addConnection(a,s);if(void 0===n)return;n.id=this.conn.id}}remove(e){const t=e.value.connections.find((e=>e.id===this.topic));void 0!==t&&(this.conn=t,e.value.removeConnection(t))}}class p extends c{constructor(e,t,i=(0,n.A)()){""===i&&(i=(0,n.A)()),super(e,t,i),Object.defineProperty(this,"anchor",{enumerable:!0,configurable:!0,writable:!0,value:void 0})}add(e){if(void 0!==this.anchor){const t=e.value.connections.find((e=>e.from.id===this.anchor[0].from.id&&e.to.id===this.anchor[0].to.id&&e.id===this.anchor[0].id));void 0!==t&&void 0===t.anchors&&(t.anchors=[]),t.anchors.splice(this.anchor[2],0,this.anchor[1])}}remove(e){if(void 0!==this.anchor){const t=e.value.connections.find((e=>e.from===this.anchor[0].from&&e.to===this.anchor[0].to));void 0!==t&&t.anchors.splice(this.anchor[2],1)}}}function u(e){r.value=e}function f(e=(0,n.A)()){if(""===d.value)return d.value=e,e}function g(){d.value=""}function y(e,t){const i=Symbol("CustomHistoryToken"),n=new Map,c=new Map;let u="ThisShouldNotAppearInHistoryMaps",y="ThisShouldNotAppearInHistoryMaps";const v=(e,t)=>{e.events.addNode.unsubscribe(t),e.events.removeNode.unsubscribe(t),e.events.editNode.unsubscribe(t),e.events.addConnection.unsubscribe(t),e.events.removeConnection.unsubscribe(t),e.events.addAnchor.unsubscribe(t),e.events.removeAnchor.unsubscribe(t)},m=(e,t,a=!1)=>{if(t&&v(t,i),e){if(y=u,u=e.id,void 0===n.get(u)&&n.set(u,[]),void 0===c.get(u)&&c.set(u,[]),a){const e=c.get(y);e&&c.set(u,e);const t=n.get(y);t&&n.set(u,t)}e.events.addNode.subscribe(i,(t=>{var i;if((null===(i=o.c.nodeData)||void 0===i?void 0:i.name)!==t.type&&!r.value){const i=n.get(e.id);if(!i)return;i.push(new h("add",t.id.toString(),d.value)),c.set(e.id,[])}})),e.events.removeNode.subscribe(i,(t=>{var i;if(!r.value){if((null===(i=o.c.nodeData)||void 0===i?void 0:i.name)===t.type)return;const a=n.get(e.id);if(!a)return;const s=new h("rem",t.id.toString(),d.value);a.push(s),s.nodeTuple=[t,t.save()],c.set(e.id,[])}})),e.events.editNode.subscribe(i,(t=>{if(!r.value){const i=n.get(e.id);if(!i)return;const a=new h("edit",t.id.toString(),d.value);i.push(a),a.nodeTuple=[t,t.save()],c.set(e.id,[])}})),e.events.addConnection.subscribe(i,(t=>{if(!r.value){const i=n.get(e.id);if(!i)return;i.push(new l("add",t.id.toString(),d.value)),c.set(e.id,[])}})),e.events.removeConnection.subscribe(i,(t=>{var i;if(!r.value){const a=""!==d.value;a||f();const s=n.get(e.id);if(!s)return;(null!==(i=t.anchors)&&void 0!==i?i:[]).slice().reverse().forEach((i=>{e.events.removeAnchor.emit([t,t.anchors.indexOf(i)])}));const o=new l("rem",t.id.toString(),d.value);s.push(o),o.conn=t,c.set(e.id,[]),a||g()}})),e.events.addAnchor.subscribe(i,(t=>{if(!r.value){const i=n.get(e.id);if(!i)return;const a=Math.trunc((t[1]-1)/3),s=t[0],o=new p("add",s.anchors[a].id.toString(),d.value);i.push(o),o.anchor=[s,s.anchors[a],a],c.set(e.id,[])}})),e.events.removeAnchor.subscribe(i,(t=>{if(!r.value){const i=n.get(e.id);if(!i)return;const a=t[1],s=t[0],o=new p("rem",s.anchors[a].id.toString(),d.value);i.push(o),o.anchor=[s,s.anchors[a],a],c.set(e.id,[])}}))}};(0,s.wB)(e,((e,t)=>m(e,t)),{flush:"post",immediate:!0});const b=(t,i)=>{const a=t.pop();void 0!==a&&(r.value=!0,"add"===a.type?(a.type="rem",a.remove(e)):"rem"===a.type?(a.type="add",a.add(e)):"edit"===a.type&&(a.type="edit",a.edit(e)),i.push(a),t.length>0&&t[t.length-1].transactionId===a.transactionId&&b(t,i),r.value=!1,e.value.selectedNodes.splice(0,e.value.selectedNodes.length))};return t.registerCommand("undo",{canExecute:()=>!0,execute:()=>{const e=n.get(u);if(e&&0!==e.length){const t=c.get(u);e&&t&&b(e,t)}}}),t.registerCommand("redo",{canExecute:()=>!0,execute:()=>{const e=n.get(u),t=c.get(u);e&&t&&0!==t.length&&b(t,e)}}),t.registerCommand("START_TRANSACTION",{canExecute:()=>""===d.value,execute:()=>f}),t.registerCommand("COMMIT_TRANSACTION",{canExecute:()=>""!==d.value,execute:()=>g}),t.registerHotkey(["Control","z"],"undo"),t.registerHotkey(["Control","y"],"redo"),(0,a.Kh)({max_steps:200,graphSwitch:m,unsubscribeFromGraphEvents:v})}},54320:(e,t,i)=>{i.d(t,{A:()=>n});var a=i(10892),s=i(30920);class n{layoutEngine=void 0;usedAlgorithm=void 0;graph=void 0;availableEngines={NoLayout:new s.A,CytoscapeEngine:new a.A};constructor(){this.useAlgorithm("NoLayout")}useAlgorithm(e){const[t,i]=e.split(" - "),a=this.availableEngines[t];if(void 0===a)throw new Error(`Could not parse the ${e} autolayout algorithm`);this.layoutEngine=a,void 0!==i&&this.layoutEngine.chooseAlgorithm(i),this.usedAlgorithm=e}getAvailableAlgorithms(){return Object.entries(this.availableEngines).map((([e,t])=>1!==t.availableAlgorithms.length?t.availableAlgorithms.map((t=>`${e} - ${t}`)):e)).flat()}registerGraph(e){this.graph=function(e){const t=new Map;e.nodes.forEach((e=>{e.interfaces.forEach((i=>t.set(i.id,e.id)))}));const i=e.nodes.filter((e=>void 0===e.position)).map((e=>({id:e.id}))),a=e.connections.filter((e=>i.filter((i=>i.id===t.get(e.from))).length>0&&i.filter((i=>i.id===t.get(e.to))).length>0)).map((e=>({id:e.id,from:t.get(e.from),to:t.get(e.to)})));return{nodes:i,connections:a}}(e)}async computeLayout(e){return this.updateDimensions(),function(e,t){const i=new Map;return e.nodes.forEach((e=>i.set(e.id,e.position))),t.nodes=t.nodes.map((e=>({...e,position:i.has(e.id)?i.get(e.id):e.position}))),t}(await this.runEngine(this.graph),e)}async runEngine(e){return this.layoutEngine.calculate(e)}updateDimensions(){this.graph.nodes=this.graph.nodes.map((e=>{const t=document.getElementById(e.id);return{...e,width:t.offsetWidth,height:t.offsetHeight}}))}}}}]);
//# sourceMappingURL=index-a5943e60.c2783293.js.map