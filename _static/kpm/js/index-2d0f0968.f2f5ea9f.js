"use strict";(self.webpackChunkpipeline_manager=self.webpackChunkpipeline_manager||[]).push([[389],{323:(e,t,n)=>{n.d(t,{A:()=>E});var i=n(13773),r=n(86049),o=n(20641),s=n(34076),a=n(51645),c=n(881),d=n(93617),u=n(34580),l=n(15215),p=n(55729);class h{constructor(e,t,n=262144){Object.defineProperty(this,"url",{enumerable:!0,configurable:!0,writable:!0,value:e}),Object.defineProperty(this,"jsonRPC",{enumerable:!0,configurable:!0,writable:!0,value:t}),Object.defineProperty(this,"maxMessageLength",{enumerable:!0,configurable:!0,writable:!0,value:n}),Object.defineProperty(this,"socket",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.socket=(0,p.io)(e,{extraHeaders:h.commonHeaders}),this.socket.on("connect",(()=>d.A.terminalLog("info","Initialized connection with communication server",null))),this.socket.on("disconnect",(()=>{d.A.terminalLog("warning","Connection with communication server disrupted",null),this.jsonRPC.rejectAllPendingRequests("WebSocket disconnected")})),this.socket.on("api",(e=>(0,l.sH)(this,void 0,void 0,(function*(){const t=yield this.jsonRPC.server.receive(e);if(t)try{const e=yield this.socket.emitWithAck("external-api",t);void 0===e||e||d.A.terminalLog("error","Response to external app was not send",null)}catch(t){d.A.terminalLog("error",`Response to ${e.method} request cannot be send`,t)}})))),this.socket.on("api-response",(e=>{this.jsonRPC.client.receive(e)}))}isConnected(){return(0,l.sH)(this,void 0,void 0,(function*(){try{const{status:{connected:e}}=yield this.jsonRPC.request("status_get",void 0,{externalApp:this});return e}catch(e){return!1}}))}onConnect(){return(0,l.sH)(this,void 0,void 0,(function*(){var e;try{return yield this.jsonRPC.request("external_app_connect",void 0,{externalApp:this}),!0}catch(t){const n=t,i=(null!==(e=n.code)&&void 0!==e?e:s.c5.EXCEPTION_RAISED)!==s.c5.NEWER_SESSION_AVAILABLE?"warning":"info";return d.A.terminalLog(i,n.message,void 0),!1}}))}request(e,t){var n;if(this.socket.disconnected)throw new Error("WebSocket is disconnected. Make sure the communication server is available.");const i=JSON.stringify(e);if(i.length>this.maxMessageLength){const r=null!==(n=e.id)&&void 0!==n?n:crypto.randomUUID();for(let e=0;e<i.length;e+=this.maxMessageLength)this.socket.emit(t,{id:r,chunk:i.substring(e,Math.min(e+this.maxMessageLength,i.length)),end:e+this.maxMessageLength>=i.length})}else this.socket.emit(t,e)}}Object.defineProperty(h,"commonHeaders",{enumerable:!0,configurable:!0,writable:!0,value:{"Access-Control-Allow-Origin":"http://localhost","Access-Control-Allow-Headers":"Origin, X-Requested-With, Content-Type, Accept"}});const f=h;class g{constructor(e,t){Object.defineProperty(this,"connectionHook",{enumerable:!0,configurable:!0,writable:!0,value:e}),Object.defineProperty(this,"disconnectionHook",{enumerable:!0,configurable:!0,writable:!0,value:t}),Object.defineProperty(this,"isRunning",{enumerable:!0,configurable:!0,writable:!0,value:!1}),Object.defineProperty(this,"connected",{enumerable:!0,configurable:!0,writable:!0,value:new Map})}add(e){this.connected.set(e,!1)}remove(e){return this.connected.delete(e)}poll(){return(0,l.sH)(this,arguments,void 0,(function*(e=1500){this.isRunning=!0;const t=new Set;for(;this.isRunning;)this.connected.keys().filter((e=>!t.has(e))).forEach((e=>{t.add(e),this.updateConnection(e).then((()=>t.delete(e)))})),yield new Promise((t=>{setTimeout(t,e)}))}))}updateConnection(e){return(0,l.sH)(this,void 0,void 0,(function*(){try{const t=this.connected.get(e);let n=yield e.isConnected();!n&&t&&(d.A.terminalLog("warning","External application was disconnected",void 0),this.disconnectionHook(e)),n&&!t&&((yield e.onConnect())?this.connectionHook(e):n=!1),this.connected.set(e,n)}catch(t){this.connected.set(e,!1)}}))}pollStop(){this.isRunning=!1}}class m{constructor(e){Object.defineProperty(this,"source",{enumerable:!0,configurable:!0,writable:!0,value:e})}isConnected(){return(0,l.sH)(this,void 0,void 0,(function*(){return!0}))}onConnect(){return(0,l.sH)(this,void 0,void 0,(function*(){return!0}))}request(e,t){if("backend-api"===t)throw new Error("Frontend external app does not support backend endpoints");this.source.postMessage(e)}}const y={};function v(e){e.type===s.FC.OK?d.A.terminalLog("info",e.content):e.type===s.FC.ERROR?d.A.terminalLog("error",`Error occurred: ${e.content}`,e.content):e.type===s.FC.WARNING&&d.A.terminalLog("warning",`Warning: ${e.content}`,e.content)}function w({errors:e,warnings:t,info:n},i,r,o){return Array.isArray(t)&&t.length&&d.A.terminalLog("warning",r,t),Array.isArray(e)&&e.length?(d.A.terminalLog("error",i,e),!0):(Array.isArray(n)&&n.length&&d.A.terminalLog("info",o,n),!1)}function b(e,t){e!==t&&d.A.terminalLog("error","Mismatched specification version",`Specification version (${t}) differs from the current version (${e}). It may result in unexpected behaviour.Please refer to https://antmicro.github.io/kenning-pipeline-manager/changelogs.html to see if that is the case.`)}class A{editorManager=u.Ay.getEditorManagerInstance();appCapabilities={};externalApp=null;connectionHook=null;constructor(){this.editorManager.externalApplicationManager=this,this.connectionManager=new g((e=>this.initializeConnection(e)),(()=>c.A.forEach((e=>{e.inProgress=!1})))),this.connectionManager.poll()}isExternalAppAvailable(){return null!==this.externalApp}isConnected(){return Array.from(this.connectionManager.connected.values()).some(Boolean)}async request(e,t){const{externalApp:n}=this;return a.Ay.request(e,t,{externalApp:n})}async requestSpecification(){let e="Unknown error";try{const t=await this.request("specification_get");if(t.type===s.FC.OK){const e=t.content;await this.updateSpecification(e),d.A.terminalLog("info","Specification loaded successfully")}else t.type===s.FC.WARNING?(e=t.content,d.A.terminalLog("warning",e)):t.type===s.FC.ERROR&&(e=t.content,d.A.terminalLog("error",e))}catch(t){e=t.message,d.A.terminalLog("error",e)}}async conditionalLoadingScreen(e,t){const{setLoad:n}=this.editorManager.baklavaView.editor.events;e&&(n.emit(!0),await(0,o.dY)());const i=await t();return e&&(n.emit(!1),await(0,o.dY)()),i}async updateSpecification(e,t){if("string"==typeof e||e instanceof String){const[t,n]=await(0,u.sA)(e);if(!t)return d.A.terminalLog("error","Specification is invalid",n),!0;e=n}if(w(u.Ay.validateSpecification(e),"Specification is invalid","Warnings when validating specification","Validated specification"))return b(this.editorManager.specificationVersion,JSON.parse(e).version),!0;const n=w(await this.editorManager.updateEditorSpecification(e,!1,!0,t),"Errors when loading specification","Warnings when loading specification","Loaded specification");return n&&b(this.editorManager.specificationVersion,JSON.parse(e).version),n}async updateDataflow(e){if("string"==typeof e||e instanceof String){const[t,n]=await(0,u.sA)(e);if(!t)return void d.A.terminalLog("error","Dataflow is invalid",n);e=n}const{errors:t,warnings:n,info:i}=await this.editorManager.loadDataflow(e);Array.isArray(t)&&t.length?(d.A.terminalLog("error","Dataflow is invalid",t),Array.isArray(i)&&i.length&&d.A.terminalLog("error","Mismatched specification version",`${i} Please refer to https://antmicro.github.io/kenning-pipeline-manager/changelogs.html to see if that is the case.`)):Array.isArray(n)&&n.length?d.A.terminalLog("warning","Dataflow loaded with warning",n):Array.isArray(i)&&i.length&&d.A.terminalLog("info","Dataflow loaded",i)}async requestAppCapabilities(){try{const e=await this.request("app_capabilities_get");this.appCapabilities={...y,...e}}catch(e){this.appCapabilities={...y},d.A.terminalLog("warning","Application capabilities cannot be retrieved, using defaults",e.message)}}async requestDataflowExport(){const e=this.editorManager.saveDataflow();if(!e)return!1;let t;try{t=await this.request("dataflow_export",{dataflow:e})}catch(e){return t=e.message,d.A.terminalLog("error",t),!1}return t.type===s.FC.OK?t:(t.type===s.FC.ERROR?d.A.terminalLog("error",`Error occurred: ${t.content}`,t.content):t.type===s.FC.WARNING&&d.A.terminalLog("warning",`Warning: ${t.content}`,t.content),!1)}async requestDataflowAction(e,t){const n=this.editorManager.saveDataflow(),i=c.A.get(e);if(!n)return;const r=a.Ay.customMethodRegex.test(e)?a.Ay.customMethodReplace:e;if("dataflow_run"===r){if(i.inProgress)return void d.A.showToast("error","Previous run has not finished, cannot process this request");d.A.showToast("info","Running dataflow")}if(t){let t;i.inProgress=!0;try{t=r.startsWith("dataflow_")?await this.request(e,{dataflow:n}):await this.request(r)}catch(e){return t=e.message,d.A.terminalLog("error","Cannot create a request",t),void(i.inProgress=!1)}v(t),i.inProgress=!1}else r.startsWith("dataflow_")?this.request(e,{dataflow:n}):this.request(r)}async requestDataflowStop(e){if(c.A.get(e).inProgress)try{v(await this.request("dataflow_stop",{method:e}))}catch(e){d.A.terminalLog("error",e.message)}else d.A.showToast("error","Nothing to stop, no ongoing jobs running")}async importDataflow(){const e=document.getElementById("request-dataflow-button").files[0];if(!e)return;const t=new FileReader,n=(0,r.charset)(e.type),i=new Promise((e=>{t.onloadend=()=>{e(n?t.result:t.result.replace(/data:.*;base64,/,""))}}));n?t.readAsText(e,n):t.readAsDataURL(e);const o=await i;if(o)try{const t=await this.request("dataflow_import",{external_application_dataflow:o,mime:e.type,base64:!n});if(t.type===s.FC.OK){const{errors:e,warnings:n}=await this.editorManager.loadDataflow(t.content);Array.isArray(e)&&e.length?d.A.terminalLog("error","Dataflow is invalid",e):Array.isArray(n)&&n.length?d.A.terminalLog("warning","Dataflow imported with warning",n):d.A.showToast("info","Imported dataflow")}else if(t.type===s.FC.ERROR){const e=t.content;d.A.terminalLog("error",`Error occurred: ${t.content}`,e)}else t.type===s.FC.WARNING&&d.A.terminalLog("warning",`Warning: ${t.content}`,"Imported dataflow")}catch(e){const t=e.message;d.A.terminalLog("error",t)}else d.A.showToast("error","File cannot be loaded")}async notifyAboutChange(e,t){if(this.isConnected()&&this.editorManager.notifyWhenChanged)try{await this.request(e,t)}catch(t){d.A.terminalLog("warning","Notifying about change failed",`${t.message} (method: ${e})`)}}async requestTerminalRead(e,t){if(this.isConnected())try{await this.request("terminal_read",{name:e,message:t})}catch(e){d.A.terminalLog("warning","Sending terminal input failed",e.message)}}async initializeConnection(e){d.A.terminalLog("info","External application connected successfully",void 0),await Promise.all([this.requestSpecification(),this.requestAppCapabilities()]);try{await this.request("frontend_on_connect")}catch(e){e.code!==i.JSONRPCErrorCode.MethodNotFound&&e.code!==s.c5.EXTERNAL_APPLICATION_NOT_CONNECTED&&d.A.terminalLog("error",e.message,e.data)}null!==this.connectionHook&&this.connectionHook()}registerConnectionHook(e){this.connectionHook=e}registerApplication(e){this.externalApp=e,this.connectionManager.add(e),null!==this.connectionHook&&this.connectionHook()}registerBackendApplication(e){this.registerApplication(new f(e,a.Ay))}registerFrontendApplication(e,t){const n=(e,n)=>{const[r,o]={[s.FC.ERROR]:["error",(0,i.createJSONRPCErrorResponse)(t.id,e,n)],[s.FC.WARNING]:["warning",(0,i.createJSONRPCSuccessResponse)(t.id,n)],[s.FC.OK]:["info",(0,i.createJSONRPCSuccessResponse)(t.id,n)]}[e];return d.A.terminalLog(r,n),o};return e===window?n(s.FC.ERROR,"External frontend cannot be a Pipeline Manager itself"):(null!==this.externalApp&&(this.connectionManager.remove(this.externalApp),n(s.FC.WARNING,"Replacing current external application.")),this.registerApplication(new m(e)),n(s.FC.OK,"Registered external frontend successfully"))}}let O;function E(){return O||(O=new A,s.Ay&&O.registerBackendApplication(s.Ay)),O}},881:(e,t,n)=>{n.d(t,{A:()=>o});class i{constructor(e){Object.defineProperty(this,"procedureName",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"hook",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"pr_inProgress",{enumerable:!0,configurable:!0,writable:!0,value:!1}),this.procedureName=e}get progressBar(){return document.querySelector(`#navbar-button-${this.procedureName} > .progress-bar`)}get inProgress(){return this.pr_inProgress}set inProgress(e){const{progressBar:t}=this;t&&(e||t.classList.remove("animate"),t.style.width="0%"),this.pr_inProgress=e,void 0!==this.hook&&this.hook()}}class r extends Map{constructor(e){super(),Object.defineProperty(this,"defaultFactory",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.defaultFactory=e}get(e){return super.has(e)||super.set(e,this.defaultFactory(e)),super.get(e)}}const o=new class extends r{constructor(){super(...arguments),Object.defineProperty(this,"hook",{enumerable:!0,configurable:!0,writable:!0,value:void 0})}get(e){if(!super.has(e)){const t=this.defaultFactory(e);t.hook=this.hook,super.set(e,t)}return super.get(e)}setHook(e){this.hook=e,this.forEach((t=>{t.hook=e}))}}((e=>new i(e)))},5292:(e,t,n)=>{n.d(t,{q:()=>c});let i,r=0,o=0;const s=e=>{const{clientY:t}=e;t>61&&i(o+(r-t))},a=()=>{const e=document.querySelector(".terminal-wrapper");document.removeEventListener("mousemove",s),document.removeEventListener("mouseup",a),e.style["pointer-events"]=""},c=e=>t=>{const n=document.querySelector(".terminal-wrapper");i=e,r=t.clientY;const c=window.getComputedStyle(n);o=parseInt(c.height,10),document.addEventListener("mousemove",s),document.addEventListener("mouseup",a),n.style["pointer-events"]="none"}},8239:(e,t,n)=>{n.d(t,{$9:()=>v,$o:()=>I,Sx:()=>$,Wo:()=>E,eC:()=>w,j4:()=>O,y5:()=>A});var i=n(46171),r=n(96422),o=n(14121),s=n(878),a=n(36568),c=n(3455),d=n(21585),u=n(56761),l=n(81630),p=n(76433),h=n(66254),f=n(46363),g=n(74752),m=n(31897),y=n(57565);function v(e){const t={},n=new Set,i=[];return e.forEach((e=>{if(void 0!==e.group&&Array.isArray(e.group)){const t=v(e.group);Array.isArray(t)&&t.length&&i.push(...t),Object.entries(t).forEach((([t])=>{if(n.has(t)){const n=t.slice(t.indexOf("_")+1);i.push(`Property named '${n}' in a group property '${e.name}' is a duplicate.`)}n.add(t)})),e.group=t}n.has(`property_${e.name}`)&&i.push(`Property named '${e.name}' is a duplicate.`),t[`property_${e.name}`]={...e},n.add(`property_${e.name}`)})),i.length?i:t}function w(e){const t=(e,t=!1)=>{const n=e.name,i=e.type;let r,o=e.default;switch(i){case"constant":r=new g.A(n,o);break;case"text":r=new c.A(n,o,e.readonly);break;case"multiline":r=new f.A(n,o,e.readonly);break;case"number":r=new l.A(n,o,e.min,e.max,e.readonly);break;case"integer":r=new d.A(n,o,e.min,e.max,e.readonly);break;case"hex":r=new a.A(n,o.toLowerCase(),e.min?BigInt(e.min):NaN,e.max?BigInt(e.max):NaN,e.readonly);break;case"select":{const t=e.values.map((e=>e.toString()));r=new p.A(n,o,t,e.readonly)}break;case"bool":r=new s.A(n,o,e.readonly);break;case"slider":void 0===o&&(o=e.min),r=new h.A(n,o,e.min,e.max,e.step,e.readonly);break;case"list":null===o&&(o=[]),r=new u.A(n,o,e.dtype,e.readonly);break;case"button-url":r=new m.A(n,(()=>window.open(r.value,"_blank")),o);break;case"button-api":r=new m.A(n,(()=>r.events.updated.emit(["button_click",{id:r.id,value:r.value}])),o);break;default:console.error(i," input type is not recognized.")}return void 0!==r&&(r.hidden=t,r.type=i,void 0!==e.interfaceMaxConnectionsCount&&(r.interfaceMaxConnectionsCount=e.interfaceMaxConnectionsCount),void 0!==e.interfaceType&&(r.interfaceType=e.interfaceType)),r},n={};return Object.entries(e).forEach((([e,i])=>{void 0!==i.group?(n[e]=()=>{const e=t(i);return e.group=Object.keys(i.group),e},Object.entries(i.group).forEach((([e,i])=>{n[e]=()=>t(i)}))):n[e]=()=>t(i)})),n}function b(e){const t=JSON.parse(JSON.stringify(e));if(void 0!==t.interfaces){const e=(0,o.Cy)(t.interfaces,[],[]);if(Array.isArray(e)&&e.length)return e;const{inputs:n,outputs:i}=e;t.inputs=n,t.outputs=i,delete t.interfaces}if(void 0!==t.properties){const e=v(t.properties);if(Array.isArray(e)&&e.length)return e;t.inputs={...t.inputs,...e},delete t.properties}if(void 0!==t.enabledInterfaceGroups){const e={};t.enabledInterfaceGroups.forEach((t=>{e[`${t.direction}_${t.name}`]={...t}})),t.enabledInterfaceGroups=e}else t.enabledInterfaceGroups={};return t.title=t.instanceName??"",delete t.instanceName,t.parsed=!0,t}class A extends i.bP{inputs={};outputs={};type=void 0;constructor(e,t,n,i,r,o="",s=[],a=[],c=[],d=300,u=void 0){super(),this.description=o,this.extends=s,this.extending=a,this.siblings=c,this.layer=t,this.title=e,this.twoColumn=r,this.type=e,this.width=d,this.relatedGraphs=u,Object.keys(n).forEach((e=>{const t=n[e]();this.addInput(e,t)})),Object.keys(i).forEach((e=>{const t=i[e]();this.addOutput(e,t)}))}updateDynamicInterfaces(e){const t=[],{value:n}=e;if("string"!=typeof e.name)throw new Error("Property 'name' is undefined or not a string in updateDynamicInterfaces.");const r=this.inputs[`property_${e.name}`],s=r?.interfaceType,a=r?.interfaceMaxConnectionsCount,c=e.name.split(" ");if(c.length<2)throw new Error(`Property name is too short to extract direction in updateDynamicInterfaces.Property name: ${e.name}`);const d=c[c.length-2],u=e.name.slice(0,-1*(o.Yg.length+2+d.length)),l={left:[],right:[]},p={...this.inputs,...this.outputs};Object.entries(p).forEach((([e,t])=>{e.startsWith("property_")||l[t.side].push(t.sidePosition)}));for(let e=0;e<n;e+=1){const n=`${u}[${e}]`,i=`${d}_${n}`,r={name:n,direction:d},o="output"===d?this.outputs:this.inputs;if(i in o&&(r.externalName=o[i].externalName,r.side=o[i].side,r.sidePosition=o[i].sidePosition),!Object.prototype.hasOwnProperty.call(r,"sidePosition")&&!Object.prototype.hasOwnProperty.call(r,"side")){const e="output"===d?"right":"left";let t=l[e].sort(((e,t)=>e-t)).findIndex(((e,t)=>e!==t));-1===t&&(t=0===l[e].length?0:Math.max(...l[e])+1),r.sidePosition=t,r.side=e,r.type=s,r.maxConnectionCount=a,l[r.side].push(t)}t.push(r)}const h="output"===d?this.outputs:this.inputs;Object.keys(h).forEach((e=>{if(!e.startsWith(`${d}_${u}[`))return;const t=e.match(/\[(\d+)\]$/);t&&(parseInt(t[1],10)<n||("output"===d?this.removeOutput(e):this.removeInput(e)))}));const f=(0,o.Cy)(t,[],[]);if(Array.isArray(f)&&f.length)throw new Error(`Internal error, node ${this.type} invalid. Reason: ${f.join(" ")}`);const{inputs:g,outputs:m}=f;Object.entries("output"===d?m:g).forEach((([e,t])=>{if(e in h)return;const n=new i.gZ(e);Object.assign(n,t),"output"===d?this.addOutput(e,n):this.addInput(e,n)}));const y=this.graph.nodes.find((e=>e.id===this.id));this.updateInterfaces.bind(y)(g,m,!1,[`${d}_${u}`])}toggleInterfaceGroup(e,t){e.hidden||t||this.graphInstance.connections.filter((t=>t.from===e||t.to===e)).forEach((e=>{this.graphInstance.removeConnection(e)})),t&&(0,r.q6)(this,e,e.side),e.hidden=!t}save(){const e=super.save(),t=[],n=[],i=[];return Object.entries({...this.inputs,...this.outputs}).forEach((e=>{const[r,o]=e;o.port?o.hidden||(o.interfaces&&i.push({name:r.slice(o.direction.length+1),direction:o.direction}),n.push({name:r.slice(o.direction.length+1),externalName:o.externalName,id:o.id,direction:o.direction,side:o.side,sidePosition:o.sidePosition})):t.push({name:r.slice(9),id:o.id,value:void 0===o.value?null:o.value})})),delete e.inputs,delete e.outputs,e.interfaces=n,e.properties=t,e.enabledInterfaceGroups=i,e.relatedGraphs=this.relatedGraphs,e.name=e.type,delete e.type,e.instanceName=""===e.title?void 0:e.title,delete e.title,e}updateInterfaces(e,t,n=!0,r=void 0){const o=[];return Object.entries(this.inputs).forEach((([t,n])=>{void 0!==n.direction&&(Object.keys(e).includes(t)||void 0!==r&&!r.some((e=>t.startsWith(e)))||(o.push(`Interface '${n.name}' of direction '${n.direction}' removed as it was not found in the dataflow.`),this.graph.editor.privatizeInterface(this.graph.id,n),this.removeInput(t)))})),Object.entries(e).forEach((([e,t])=>{if(void 0===t.direction)return;const r=Object.entries(this.inputs).find((([n,i])=>n===e&&i.direction===t.direction));if(void 0===r){const n=new i.gZ(e);o.push(`Interface '${t.name}' of direction '${t.direction}' created as it was not found in the specification.`),Object.assign(n,t),this.addInterface(n.direction,e,n)}else n&&Object.assign(r[1],t)})),Object.entries(this.outputs).forEach((([e,n])=>{void 0!==n.direction&&(Object.keys(t).includes(e)||void 0!==r&&!r.some((t=>e.startsWith(t)))||(o.push(`Interface '${n.name}' of direction '${n.direction}' removed as it was not found in the dataflow.`),this.graph.editor.privatizeInterface(this.graph.id,n),this.removeOutput(e)))})),Object.entries(t).forEach((([e,t])=>{const r=Object.entries(this.outputs).find((([n,i])=>n===e&&i.direction===t.direction));if(void 0===r){const n=new i.gZ(e);o.push(`Interface '${t.name}' of direction '${t.direction}' created as it was not found in the specification.`),Object.assign(n,t),this.addInterface(n.direction,e,n)}else n&&Object.assign(r[1],t)})),o}updateProperties(e){const t=[];return Object.entries(this.inputs).forEach((([n,i])=>{void 0===i.direction&&(Object.keys(e).includes(n)||(t.push(`Property '${i.name}' removed as it was not found in the dataflow.`),this.removeInput(n)))})),Object.entries(e).forEach((([e,n])=>{if(void 0===n.direction&&void 0===Object.entries(this.inputs).find((([t])=>t===e))){const i=new c.A(n.name,n.value);t.push(`Property '${n.name}' created as it was not found in the specification.`),Object.assign(i,n),this.addInput(e,i)}})),t}load(e){let t;if(Object.prototype.hasOwnProperty.call(e,"parsed")&&e.parsed)t=e;else if(t=b(e),Array.isArray(t)&&t.length)return t.map((e=>`Node ${this.type} of id: ${this.id} invalid. ${e}`));let n=!0;try{n=window.isWebpack}catch{n=!1}let r=[];if(Object.entries(t.inputs).forEach((([e,t])=>{e.startsWith("property_")&&e.startsWith("property_")&&e.endsWith(`${o.Yg}`)&&this.updateDynamicInterfaces(t)})),r=function(e,t,n){let i=[];return Object.keys({...e.inputs,...e.outputs}).forEach((r=>{const o=r.slice(r.indexOf("_")+1),s=r.slice(0,r.indexOf("_"));if(Object.prototype.hasOwnProperty.call(t,r)||Object.prototype.hasOwnProperty.call(n,r)){if("property"===s){const n=e.inputs[r].value,s=t[r].type;if(((e,t)=>{switch(e){case"constant":case"select":return!0;case"text":case"multiline":case"button-url":case"hex":return"string"==typeof t;case"number":case"integer":case"slider":return"number"==typeof t;case"bool":return"boolean"==typeof t;case"list":return Array.isArray(t);case"button-api":return"object"==typeof t;default:return!1}})(s,n)){if("select"===s){const{items:e}=t[r];Array.isArray(e)?e.map(String).includes(String(n))||i.push(`Property '${o}' value mismatch. ${n} (type: ${typeof n}) not found in ${JSON.stringify(e)}`):String(n)!==String(e)&&i.push(`Property '${o}' value mismatch. Expected '${e}' (type: ${typeof e}), found '${n}' (type: ${typeof n}).`)}else if("list"===s){const{dtype:e}=t[r],s=n.filter((t=>"integer"===e?"number"!=typeof t||!Number.isInteger(t):typeof t!==e));s.length>0&&i.push(`Property '${o}' value mismatch. Items: '${s.join(" ")}' are not of '${e}' dtype.Items are of type: ${s.map((e=>typeof e)).join(", ")}`)}}else i.push(`Property '${o}' type mismatch. ${s} expected, ${typeof n} found.`)}}else"property"===s?i.push(`Property named '${o}' not found in specification!`):/\[\d+\]$/.test(o)||i.push(`Interface named '${o}' of direction '${s}' not found in specification!`)})),Object.keys(e.enabledInterfaceGroups).forEach((e=>{if(!Object.prototype.hasOwnProperty.call(t,e)&&!Object.prototype.hasOwnProperty.call(n,e)){const t=e.slice(0,e.indexOf("_")),n=e.slice(e.indexOf("_")+1);i.push(`Interface group named '${n}' of direction '${t}' not found in specification!`)}})),i&&i.length||(i=(0,o.W9)(Object.keys(e.enabledInterfaceGroups),t,n)),i}(t,this.inputs,this.outputs),Array.isArray(r)&&r.length)return r.map((e=>`Node ${this.type} of id: ${this.id} invalid. ${e}`));super.load(t),Object.keys(t.enabledInterfaceGroups).length&&Object.entries({...this.inputs,...this.outputs}).forEach((([,e])=>{void 0!==e.interfaces&&(e.hidden=!0)})),Object.entries(t.enabledInterfaceGroups).forEach((([e,t])=>{"input"===t.direction||"inout"===t.direction?this.inputs[e].hidden=!1:"output"===t.direction&&(this.outputs[e].hidden=!1)}));const s={left:[],right:[]},a={...t.inputs,...t.outputs};Object.entries(a).forEach((([e,t])=>{if("input"===t.direction||"inout"===t.direction){if(!(e in this.inputs)){const n=new i.gZ(e);Object.assign(n,t),this.addInput(e,n)}this.inputs[e].side=t.side,this.inputs[e].sidePosition=t.sidePosition,this.inputs[e].externalName=t.externalName,this.inputs[e].direction=t.direction,s[t.side].push(t.sidePosition)}else if("output"===t.direction){if(!(e in this.outputs)){const n=new i.gZ(e);Object.assign(n,t),this.addOutput(e,n)}this.outputs[e].side=t.side,this.outputs[e].sidePosition=t.sidePosition,this.outputs[e].externalName=t.externalName,this.outputs[e].direction=t.direction,s[t.side].push(t.sidePosition)}}));const c=e=>{Object.entries(e).forEach((([e,t])=>{if(e.startsWith("property_"))return;if(e in a)return;if(!s[t.side].includes(t.sidePosition))return;const n=Math.max(...s[t.side]);t.sidePosition=n+1,s[t.side].push(n+1)}))};return c(this.inputs),c(this.outputs),void 0===e.position&&(this.position=void 0),this.relatedGraphs=e.relatedGraphs,r}onPlaced(){super.onPlaced();const e=([e,t])=>this.graphInstance?.editor?.editorManager?.externalApplicationManager?.request(e,t);Object.entries(this.inputs).filter((([e,t])=>e.startsWith("property_"))).filter((([e,t])=>"ButtonInterface"===t.componentName)).forEach((([t,n])=>n.events.updated.subscribe(this,e)))}onDestroy(){[...Object.values(this.inputs),...Object.values(this.outputs)].forEach((e=>{Object.values(e.events).forEach((t=>{t.unsubscribe(this),t.unsubscribe(e)}))}))}}const O=e=>{function t(e){return()=>{const t=new i.gZ(e.name);return Object.assign(t,e),t}}return[Object.fromEntries(Object.entries(e.inputs).map((([e,n])=>[e,t(n)]))),Object.fromEntries(Object.entries(e.outputs).map((([e,n])=>[e,t(n)])))]};function E(e,t,n,i,r,s,a,c="",d=[],u=[],l=[],p=300){const h=(0,o.vS)(n);if(!h.success)return h.value.map((t=>`Node ${e} invalid. ${t}`));const f=(0,o.Cy)(n,r,s);if(Array.isArray(f)&&f.length)return f.map((t=>`Node ${e} invalid. ${t}`));const[g,m]=O(f),y=v([...i,...h.value]);if(Array.isArray(y)&&y.length)return y.map((t=>`Node ${e} invalid. ${t}`));const b={...g,...w(y)};return class extends A{constructor(){super(e,t,b,m,a,c,d,u,l,p)}}}function $(e,t=[],n=[]){const i=["input_","inout_","output_"],r=[...e.map((e=>Object.entries({...e.inputs,...e.outputs}))).flat()].filter((([e])=>i.some((t=>e.startsWith(t))))).filter((([,e])=>e.externalName)),s=Object.create(null),a=[];r.forEach((([,e])=>{s[e.externalName]=(s[e.externalName]??0)+1,1===s[e.externalName]?a.push(e):a.push(`Interface '${e.externalName}' is repeated ${s[e.externalName]} times.`)}));const c=a.filter((e=>"string"==typeof e));if(c.length)return c;const d=[];a.forEach((i=>{const r=e[0].graph.id;y.ir.isRegistered(i.id)&&y.ir.getRegisteredInterface(i.id).sharedInterface!==i&&y.ir.getRegisteredInterface(i.id).sharedInterface.id===i.id&&y.ir.getRegisteredInterface(i.id).sharedInterfaceGraphId===r&&y.ir.deleteRegisteredInterface(i.id),y.ir.isRegistered(i.id)||y.ir.registerInterface(i,r);const o="output"===i.direction?n:t,s=o.findIndex((e=>e.id===i.id));-1===s?d.push({name:i.externalName,id:i.id,externalName:void 0,side:i.side,direction:i.direction,sidePosition:void 0}):(o[s].name=i.externalName,d.push(o[s]))}));const u=(0,o.i0)(d,{});return Array.isArray(u)&&u.length?u:{inputs:Object.values(u.inputs),outputs:Object.values(u.outputs)}}function I(e,t,n,r){const o=e.map((e=>b(e))),s=o.filter((e=>"string"==typeof e));if(s.length)return s;const a={name:n,nodes:o,connections:t,inputs:[],outputs:[]};return new i.b1(a,r)}},8328:(e,t,n)=>{n.d(t,{c:()=>o,x:()=>r});var i=n(50953);const r=(0,i.Kh)({configurationMenu:{visible:!1,addNode:!1,placeNode:!1},propertyMenu:!1,interfaceMenu:!1,propertyListMenu:!1,interfaceListMenu:!1,layerMenu:!1}),o=(0,i.Kh)({nodeData:{name:"Custom Node",category:"Default category",layer:"",description:"",color:""},properties:[],interfaces:[],success:!1})},10892:(e,t,n)=>{n.d(t,{A:()=>a});var i=n(44726),r=n(71095),o=n(65111),s=n(39024);i.use(o),i.use(r);class a extends s.A{availableAlgorithms=["cola","dagre-network-simplex","dagre-tight-tree","dagre-longest-path","random","grid","circle","concentric","breadthfirst","cose"];async calculate(e){const t=i({elements:{nodes:e.nodes.map((e=>({data:{id:e.id,width:e.width,height:e.height}}))),edges:e.connections.map((e=>({data:{id:e.id,source:e.from,target:e.to}})))},style:[{selector:"node",style:{shape:"rectangle",width:"data(width)",height:"data(height)"}}],styleEnabled:!0}),n={name:this.activeAlgorithm};switch(this.activeAlgorithm){case"random":n.boundingBox={x1:0,y1:0,w:2e3,h:2e3};break;case"grid":n.avoidOverlapPadding=150;break;case"cose":n.nodeOverlap=1e3,n.idealEdgeLength=e=>300;break;case"cola":n.nodeSpacing=e=>150;break;case"dagre-network-simplex":case"dagre-tight-tree":case"dagre-longest-path":{const[e,...t]=this.activeAlgorithm.split("-");n.nodeSep=50,n.rankSep=100,n.ranker=t.join("-"),n.name=e;break}}const r=t.layout(n);return r.run(),["cose","cola"].includes(this.activeAlgorithm)&&await r.promiseOn("layoutstop"),{...e,nodes:t.nodes().map((e=>({id:e.id(),position:{x:e.position().x-e.width()/2,y:e.position().y-e.height()/2}})))}}}},14121:(e,t,n)=>{n.d(t,{Cy:()=>l,Sb:()=>a,W9:()=>c,Yg:()=>r,i0:()=>d,vS:()=>u});const i="inout",r="count";function o(e,t,n=void 0){const i={};return Object.assign(i,e),i.name=n??e.name,void 0!==i.type&&(i.type="string"==typeof e.type||e.type instanceof String?[e.type]:e.type),i.componentName="NodeInterface",i.hidden=t,i.originalSide=i.side,i.originalSidePosition=i.sidePosition,i}function s(e,t=!1){const n=[],r={input:{},inout:{},output:{}};e.forEach((e=>{if(Object.prototype.hasOwnProperty.call(e,"dynamic"))return;const o=JSON.parse(JSON.stringify(e)),s=e.direction??i;if(o.direction=s,void 0!==e.array){const[t,i]=e.array;for(let a=t;a<i;a+=1){const t=`${e.name}[${a}]`;void 0!==r[s][t]&&n.push(`Interface named '${t}' of direction '${s}' is a duplicate.`),o.externalName=e.externalName?`${e.externalName}[${a}]`:void 0,r[s][t]=JSON.parse(JSON.stringify(o))}}else void 0!==r[s][e.name]&&n.push(`Interface named '${e.name}' of direction '${s}' is a duplicate.`),r[s][e.name]=o;if(t){const e=[];o.interfaces.forEach((t=>{const n=t.direction??i;if(void 0!==t.array){const[i,r]=t.array;for(let o=i;o<r;o+=1){const i=`${n}_${t.name}[${o}]`;e.push(i)}}else{const i=`${n}_${t.name}`;e.push(i)}})),o.interfaces=e}}));const o=Object.fromEntries(Object.entries(r.inout).filter((([e,t])=>{const o=t.direction??i,s=Object.keys(r.output).includes(e)||Object.keys(r.input).includes(e);return s&&n.push(`Interface named '${e}' of direction '${o}' is a duplicate. There already exists an input or output of this name.`),!s})));return r.inout=o,r.input={...r.input,...r.inout},delete r.inout,r.input=Object.fromEntries(Object.entries(r.input).map((([e,t])=>[`${t.direction}_${e}`,t]))),r.output=Object.fromEntries(Object.entries(r.output).map((([e,t])=>[`${t.direction}_${e}`,t]))),n.length?n:r}function a(e,t,n){const i=[],r=new Set;return e.forEach((e=>{const o=t[e]?.interfaces??n[e]?.interfaces,s=e.slice(0,e.indexOf("_")),a=e.slice(e.indexOf("_")+1);o.forEach((e=>{if(r.has(e)){const t=e.slice(0,e.indexOf("_")),n=e.slice(e.indexOf("_")+1);i.push([n,t,a,s])}else r.add(e)}))})),i}function c(e,t,n){const i=a(e,t,n),r=[];return i.forEach((([e,t,n,i])=>{r.push(`Interface of name '${e}' and direction '${t}' has been reused by interface group named '${n}' of direction '${i}'. Make sure your interface groups are disjoint.`)})),r}function d(e,t){const n={left:{},right:{}},i=[];Object.entries({...e,...t}).forEach((([e,t])=>{"right"===t.side||void 0===t.side&&"output"===t.direction?(n.right[e]={...t},n.right[e].side="right"):("left"===t.side||void 0===t.side&&"output"!==t.direction)&&(n.left[e]={...t},n.left[e].side="left")}));const r=e=>e.slice(e.indexOf("_")+1),o=new Set,s=new Set;if(Object.entries(n.left).forEach((([e,t])=>{void 0!==t.sidePosition&&(o.has(t.sidePosition)&&i.push(`Interface named '${r(e)}' of direction '${t.direction}' has invalid sidePosition value '${t.sidePosition}'. There already exists an input or output with this sidePosition.`),o.add(t.sidePosition))})),Object.entries(n.right).forEach((([e,t])=>{void 0!==t.sidePosition&&(s.has(t.sidePosition)&&i.push(`Interface named '${r(e)}' of direction '${t.direction}' has invalid sidePosition value '${t.sidePosition}'. There already exists an input or output with this sidePosition.`),s.add(t.sidePosition))})),i.length)return i;let a=0,c=0;return Object.entries(n.left).forEach((([,e])=>{e.sidePosition=(e=>{if(void 0===e.sidePosition){for(;o.has(a);)a+=1;return o.add(a),a}return e.sidePosition})(e)})),Object.entries(n.right).forEach((([,e])=>{e.sidePosition=(e=>{if(void 0===e.sidePosition){for(;s.has(c);)c+=1;return s.add(c),c}return e.sidePosition})(e)})),{inputs:Object.fromEntries(Object.entries({...n.left,...n.right}).filter((([,e])=>"output"!==e.direction))),outputs:Object.fromEntries(Object.entries({...n.left,...n.right}).filter((([,e])=>"output"===e.direction)))}}function u(e){const t=[],n=[];return e.forEach((e=>{Object.prototype.hasOwnProperty.call(e,"dynamic")&&(Array.isArray(e.dynamic)&&2===e.dynamic.length&&Number.isInteger(e.dynamic[0])&&Number.isInteger(e.dynamic[1])?n.push({name:`${e.name} ${e.direction} ${r}`,type:"integer",min:e.dynamic[0],max:e.dynamic[1],default:e.dynamic[0],interfaceType:e.type,interfaceMaxConnectionCount:e.maxConnectionCount}):!0===e.dynamic?n.push({name:`${e.name} ${e.direction} ${r}`,type:"integer",min:0,default:0,interfaceType:e.type,interfaceMaxConnectionCount:e.maxConnectionCount}):t.push(`Interface '${e.name}' has invalid 'dynamic' attribute. It should be either a boolean or an array with two integer elements.`))})),t.length?{success:!1,value:t}:{success:!0,value:n}}function l(e,t,n){let r=[];const a=s(e);if(Array.isArray(a)&&a.length)return a;if(t.forEach((e=>{const t=e.direction??i;e.interfaces.forEach((n=>{const o=n.direction??i;if(void 0!==n.array){const[i,s]=n.array;for(let c=i;c<s;c+=1){const i=`${o}_${n.name}[${c}]`;Object.keys({...a.input,...a.output}).includes(i)||r.push(`Interface named '${n.name}[${c}]' of direction '${o}' used for interface group '${e.name}' of direction '${t}' does not exist.`)}}else{const i=`${o}_${n.name}`;Object.keys({...a.input,...a.output}).includes(i)||r.push(`Interface named '${n.name}' of direction '${o}' used for interface group '${e.name}' of direction '${t}' does not exist.`)}}))})),r.length)return r;const u=s(t,!0);if(Array.isArray(u)&&u.length)return u;const l=new Set;Object.values({...u.input,...u.output}).forEach((e=>{e.interfaces.forEach((e=>l.add(e)))}));const p=n.map((e=>`${e.direction??i}_${e.name}`));if(r=c(p,{...u.input,...a.input},{...u.output,...a.output}),r.length)return r;a.input=Object.fromEntries(Object.entries(a.input).filter((([e])=>!l.has(e)))),a.output=Object.fromEntries(Object.entries(a.output).filter((([e])=>!l.has(e))));const h=d({...a.input,...u.input},{...a.output,...u.output});if(Array.isArray(h)&&h.length)return h;const f=e=>e.slice(e.indexOf("_")+1),g={inputs:{},outputs:{}};return Object.entries(h.inputs).forEach((([e,t])=>{void 0!==t.interfaces?g.inputs[e]=o(t,!p.includes(e),f(e)):g.inputs[e]=o(t,!1,f(e))})),Object.entries(h.outputs).forEach((([e,t])=>{void 0!==t.interfaces?g.outputs[e]=o(t,!p.includes(e),f(e)):g.outputs[e]=o(t,!1,f(e))})),g}},22048:(e,t,n)=>{n.d(t,{A:()=>i});class i{static instance=void 0;currentSpecification=void 0;includedSpecification=void 0;unresolvedSpecification=void 0;constructor(){if(void 0!==i.instance)throw new Error("Error - use Specification.getInstance()")}static getInstance(){return i.instance||(i.instance=new i),i.instance}getNodeSpecification(e){if(void 0!==this.currentSpecification)return this.currentSpecification.nodes.find((t=>t.name===e))}}},30920:(e,t,n)=>{n.d(t,{A:()=>r});var i=n(39024);class r extends i.${availableAlgorithms=["NoLayout"];activeAlgorithm="NoLayout";calculate(e){const t=e.nodes.map((e=>({...e,position:{x:0,y:0}})));return{...e,nodes:t}}}},34076:(e,t,n)=>{n.d(t,{Ay:()=>i,FC:()=>r,c5:()=>o});const i=(()=>{const e=new URLSearchParams(window.location.search).get("backend");return null!==e?e:(window.location.protocol,null)})(),r={OK:0,ERROR:1,PROGRESS:2,WARNING:3},o={EXCEPTION_RAISED:-1,EXTERNAL_APPLICATION_NOT_CONNECTED:-2,NEWER_SESSION_AVAILABLE:-3}},35127:(e,t,n)=>{n.d(t,{d:()=>u,iP:()=>l,xv:()=>d});var i=n(50953);const r=(()=>{try{const e=Math.random().toString(36),t=Math.random().toString(36);return localStorage.setItem(e,t),localStorage.removeItem(e),!0}catch{return!1}})(),o=new Map,s=e=>r?localStorage.getItem(e):o.get(e)??null,a=(e,t)=>{r?localStorage.setItem(e,t):o.set(e,t)},c=e=>{r?localStorage.removeItem(e):o.delete(e)},d=(0,i.Kh)({notifications:JSON.parse(s("notifications"))||[],add(e){this.notifications.push(e),a("notifications",JSON.stringify(this.notifications))},remove(){c("notifications"),this.notifications=[]},removeOne(e){const t=this.notifications.filter(((t,n)=>e!==n));a("notifications",JSON.stringify(t)),this.notifications=t}}),u="Terminal",l=(0,i.Kh)({logs:{Terminal:JSON.parse(s("logs"))||[]},readOnly:{Terminal:!0},add(e,t=u){this.logs[t].push(e),t===u&&a("logs",JSON.stringify(this.logs[t]))},isReadOnly(e=u){return this.readOnly[e]},addParsed(e,t,n=u){let i=e;t?(("string"==typeof t||t instanceof String)&&(t=[t]),i+=":",t.forEach((e=>{i+="\n",i+="    ",i+=e}))):i+=".",this.add(i,n)},clear(e=u){e===u&&c("logs"),this.logs[e]=[]},remove(e=u){this.clear(e),delete this.logs[e],delete this.readOnly[e]},exists(e=u){return e in this.logs},getInstances(){return Object.keys(this.logs)},createTerminalInstance(e,t=!0){return!Object.keys(this.logs).includes(e)&&(this.logs[e]=[],this.readOnly[e]=t,!0)},show:!1,manager:null})},39021:(e,t,n)=>{n.d(t,{$k:()=>h,Fo:()=>w,GI:()=>y,J7:()=>v,RM:()=>p,Rj:()=>g,hm:()=>m,iv:()=>f,zM:()=>l});var i=n(63491),r=n(34580),o=n(14121),s=n(8328),a=n(8239),c=n(93617),d=n(41857);function u(){(0,d.$4)(!0);const e=r.Ay.getEditorManagerInstance(),t=s.c.nodeData,n=s.c.editedType;let i=r.kx;if(void 0!==n){const t=e._unregisterNodeType(n);if(t.length)return void c.A.terminalLog("error","Error when registering the node",t);i=r.L6}const o=e.addNodeToEditorSpecification({name:t.name,layer:t.layer,category:t.category,color:t.color,description:t.description,interfaces:s.c.interfaces,properties:s.c.properties,style:i},n,!1);void 0!==o.errors&&o.errors.length?c.A.terminalLog("error","Error when registering the node",o.errors):(0,d.$4)(!1)}function l(e,t=!1){const{viewModel:n}=(0,i.if)(),{editor:r}=n.value,o=Array.from(r.graphs).map((e=>e.nodes)).flat();return t?o.filter((t=>{var n;return null===(n=t.extends)||void 0===n?void 0:n.includes(e)})):o.filter((t=>t.type===e))}function p(){const e=r.Ay.getEditorManagerInstance(),t=s.c.nodeData,n=s.c.editedType;if(e.baklavaView.editor.nodeTypes.has(t.name)&&(void 0===n||n!==t.name)){const e=[`Node of type ${t.name} already exists. Please pick another type`];return c.A.terminalLog("error","Error when creating a node",e),e}return u(),[]}function h(){(0,d.$4)(!0);const e=s.c.nodeData;return l(s.c.editedType).forEach((t=>{t.type===t.title?t.title=e.name:t.highlightedType=e.name,t.type=e.name,t.layer=e.layer,t.category=e.category,t.color=e.color,t.description=e.description})),u(),(0,d.$4)(!1),[]}function f(e,t,n=!1){if(void 0===t)return[];const i=(0,a.$9)(t);if(Array.isArray(i)&&i.length)return i;const r=(0,a.eC)(i);return e.forEach((e=>{const t=e.save();Object.keys(r).forEach((t=>{const i=r[t]();n?e.removeInput(t,i):e.addInput(t,i),e.inputs=e.inputs})),e.load(t)})),[]}function g(e,t,n=!1){if(void 0===t)return[];const i=(0,o.Cy)(t,[],[]);if(Array.isArray(i)&&i.length)return i;const[r,s]=(0,a.j4)(i);return e.forEach((e=>{const t=e.save();Object.keys(r).forEach((t=>{const i=r[t]();n?e.removeInput(t,i):e.addInput(t,i),e.inputs=e.inputs})),Object.keys(s).forEach((t=>{const i=s[t]();n?e.removeOutput(t,i):e.addOutput(t,i),e.outputs=e.outputs})),e.load(t)})),[]}function m(e){var t;const n=s.c.editedType,i=r.Ay.getEditorManagerInstance();let o=i.validateNodeProperty(e);if(o.length)return void c.A.terminalLog("error","Invalid property",o);const a=l(n);void 0!==a?(s.c.properties.push(e),o=f(a,s.c.properties),o.length?c.A.terminalLog("error","Invalid property",o):((null!==(t=i.specification.currentSpecification.nodes.filter((e=>{var t;return null===(t=e.extends)||void 0===t?void 0:t.includes(n)})))&&void 0!==t?t:[]).forEach((t=>{var n;t.properties=[...null!==(n=t.properties)&&void 0!==n?n:[],e],f(l(t.name),[e])})),u())):c.A.terminalLog("error","Node not found",`Node of type ${n} not found`)}function y(e){var t;const n=s.c.editedType,i=r.Ay.getEditorManagerInstance(),o=l(n);void 0!==o?(s.c.properties=s.c.properties.filter((t=>!e.includes(t))),f(o,e,!0),(null!==(t=i.specification.currentSpecification.nodes.filter((e=>{var t;return null===(t=e.extends)||void 0===t?void 0:t.includes(n)})))&&void 0!==t?t:[]).forEach((t=>{var n,i;t.properties=null!==(i=null===(n=t.properties)||void 0===n?void 0:n.filter((t=>!e.some((e=>e.name===t.name)))))&&void 0!==i?i:[],f(l(t.name),e,!0)})),u()):c.A.terminalLog("error","Node not found",`Node of type ${n} not found`)}function v(e){var t;const n=s.c.editedType,i=r.Ay.getEditorManagerInstance();let o=i.validateNodeInterface(e);if(o.length)return void c.A.terminalLog("error","Invalid interface",o);const a=l(n);void 0!==a?(s.c.interfaces.push(e),o=g(a,s.c.interfaces),o.length?c.A.terminalLog("error","Invalid interface",o):((null!==(t=i.specification.currentSpecification.nodes.filter((e=>{var t;return null===(t=e.extends)||void 0===t?void 0:t.includes(n)})))&&void 0!==t?t:[]).forEach((t=>{var n;t.interfaces=[...null!==(n=t.interfaces)&&void 0!==n?n:[],e],g(l(t.name),[e])})),u())):c.A.terminalLog("error","Node not found",`Node of type ${n} not found`)}function w(e){var t;const n=s.c.editedType,i=r.Ay.getEditorManagerInstance(),o=l(n);void 0!==o?(s.c.interfaces=s.c.interfaces.filter((t=>!e.includes(t))),g(o,e,!0),(null!==(t=i.specification.currentSpecification.nodes.filter((e=>{var t;return null===(t=e.extends)||void 0===t?void 0:t.includes(n)})))&&void 0!==t?t:[]).forEach((t=>{var n,i;t.interfaces=null!==(i=null===(n=t.interfaces)||void 0===n?void 0:n.filter((t=>!e.some((e=>e.name===t.name)))))&&void 0!==i?i:[],g(l(t.name),e,!0)})),u()):c.A.terminalLog("error","Node not found",`Node of type ${n} not found`)}},39024:(e,t,n)=>{n.d(t,{$:()=>r,A:()=>i});class i{availableAlgorithms=[];constructor(){if(this.constructor===i)throw new Error("Can't initialize base class instance")}chooseAlgorithm(e){if(!this.availableAlgorithms.includes(e))throw new Error(`Could not find ${e} in ${this.constructor.name} engine.\n                Available algorithms: ${this.availableAlgorithms}`);this.activeAlgorithm=e}async calculate(e){throw new Error("Method calculate() must be implemented by layout engine")}}class r extends i{constructor(){if(super(),this.availableAlgorithms=[this.constructor.name],this.activeAlgorithm=this.constructor.name,this.chooseAlgorithm=void 0,this.constructor===r)throw new Error("Can't initialize base class instance")}}},41426:(e,t,n)=>{function i(e,t){const n=e;let i=-n;return e=>{Date.now()-i<n&&t(e),i=Date.now()}}n.d(t,{A:()=>i})},45825:(e,t,n)=>{n.d(t,{Q:()=>o,i:()=>r});var i=n(63491);function r(e){return t=>Math.round(t/e.value)*e.value}function o(e){const{graph:t}=(0,i.uU)();return(n,i,r)=>{const o=t.value.nodes.filter((e=>e.id!==i&&!r.includes(e.id))).map((t=>t.position[e])).filter((e=>Math.abs(n-e)<100));return 0!==o.length?Math.min(...o):void 0}}},51645:(e,t,n)=>{n.d(t,{Ay:()=>ce,D7:()=>Z});var i={};n.r(i),n.d(i,{connections_change:()=>P,frontend_specification_get:()=>O,graph_change:()=>j,graph_get:()=>E,metadata_change:()=>_,node_get:()=>C,nodes_change:()=>x,nodes_highlight:()=>B,notification_send:()=>F,position_change:()=>I,progress_change:()=>S,properties_change:()=>$,properties_get:()=>N,register_external_frontend:()=>K,specification_change:()=>G,specification_graph_change:()=>J,terminal_add:()=>k,terminal_clear:()=>T,terminal_get_instances:()=>W,terminal_hide:()=>q,terminal_remove:()=>L,terminal_show:()=>H,terminal_view:()=>D,terminal_write:()=>M,viewport_center:()=>R});var r=n(15215),o=n(13773),s=n(94541),a=n.n(s),c=n(93617),d=n(34076),u=n(28316),l=n(30468),p=n(63491),h=n(881),f=n(34580),g=n(35127),m=n(323);function y(e,t=!0){if(g.iP.exists(e)!==t)throw new Error(`Terminal instance of name '${e} ${t?"does not exist":"already exists"}`)}const v=f.Ay.getEditorManagerInstance();function w(e){const{viewModel:t}=(0,p.if)(),n=[...t.value.editor.graphs].find((t=>t.id===e));if(void 0===n)throw new Error(`Graph with id '${e}' does not exist.`);return n}function b(e,t){const n=w(e).nodes.find((e=>e.id===t));if(void 0===n)throw new Error(`Node with id '${t}' does not exist.`);return n}function A(e,t,n){let i;if(void 0!==t){if(i=Object.values(e.inputs).find((e=>e.id===t)),void 0===i||void 0!==i.side)throw new Error(`Property with id '${t}' does not exist.`)}else if(i=Object.values(e.inputs).find((e=>e.name===n)),void 0===i||void 0!==i.side)throw new Error(`Property with name '${n}' does not exist.`);return i}function O(){return{specification:v.saveSpecification()}}function E(){return{dataflow:v.saveDataflow()}}function $(e){const t=b(e.graph_id,e.node_id);for(const n of e.properties)A(t,n.id,n.name);for(const n of e.properties)A(t,n.id,n.name).value=n.new_value}function I(e){const t=b(e.graph_id,e.node_id);t.position.x=e.position.x,t.position.y=e.position.y}function x(e){return(0,r.sH)(this,void 0,void 0,(function*(){const{viewModel:t}=(0,p.if)(),n=w(e.graph_id);e.nodes.added.forEach((e=>{const i=t.value.editor.nodeTypes.get(e.name);if(!i)throw new Error(`Node type not found for name ${e.name}`);{const r=new i.type;r.id=e.id,e.color&&t.value.editor.setNodeColor(e.id,e.color),n.addNode(r);const o=r.load(e);if(Array.isArray(o)&&o.length)throw new Error(o.join("\n"))}})),e.nodes.deleted.forEach((t=>{var i;const r=b(e.graph_id,t);null===(i=e.remove_with_connections)||void 0===i||i?n.removeNode(r):n.removeNodeOnly(r)}))}))}function P(e){return(0,r.sH)(this,void 0,void 0,(function*(){const t=w(e.graph_id);e.connections.added.forEach((e=>{const n=t.findNodeInterface(e.from);if(!n)throw new Error(`Interface with id ${e.from} does not exist`);const i=t.findNodeInterface(e.to);if(!i)throw new Error(`Interface with id ${e.to} does not exist`);if(!t.addConnection(n,i))throw new Error(`Connection from ${e.from} to ${e.to} cannot be created`)})),e.connections.deleted.forEach((n=>{t.removeConnection(function(e,t,n){const i=w(e).connections.find((e=>e.from.id===t&&e.to.id===n));if(void 0===i)throw new Error(`Connection from ${t} to ${n} does not exist.`);return i}(e.graph_id,n.from,n.to))}))}))}function j(e){return(0,r.sH)(this,void 0,void 0,(function*(){const t=(0,m.A)();yield t.conditionalLoadingScreen(e.loadingScreen,(()=>(0,r.sH)(this,void 0,void 0,(function*(){return t.updateDataflow(e.dataflow)}))))}))}function N(e){return(0,r.sH)(this,void 0,void 0,(function*(){const t=b(e.graph_id,e.node_id),n=[];if(void 0===e.properties){for(const e of Object.values(t.inputs))void 0===e.side&&n.push({id:e.id,name:e.name,value:e.value});return n}for(const i of e.properties){const e=A(t,i.id,i.name);n.push({id:e.id,name:e.name,value:e.value})}return n}))}function C(e){return(0,r.sH)(this,void 0,void 0,(function*(){return{node:b(e.graph_id,e.node_id).save()}}))}function S(e){const t=h.A.get(e.method);if(!t.inProgress)throw new Error("No run in progress");if(!t.progressBar)throw new Error(`Progress bar does not exist for method: ${e.method}`);if(-1!==e.progress){if(e.progress>100||e.progress<0)throw new Error(`Progress has to be in [0, 100] or -1. Received: ${e.progress}`);t.progressBar.style.width=`${e.progress}%`,t.progressBar.classList.remove("animate")}else t.progressBar.classList.add("animate")}function _(e){v.updateMetadata(e.metadata,!0)}function R(){v.baklavaView.editor.centerZoom()}function k(e){if(!1===g.iP.createTerminalInstance(e.name,e.readonly))throw new Error(`Terminal instance of name '${e.name}' already exists`)}function L(e){y(e.name,!0),g.iP.remove(e.name)}function M(e){e.name in g.iP.logs||g.iP.createTerminalInstance(e.name),g.iP.add(e.message,e.name)}function T(e){var t;const n=null!==(t=null==e?void 0:e.name)&&void 0!==t?t:g.d;y(n,!0),g.iP.clear(n)}function q(){var e;null===(e=g.iP.manager)||void 0===e||e.hide()}function H(e){var t,n;const i=null!==(t=null==e?void 0:e.name)&&void 0!==t?t:g.d;void 0!==i&&y(i,!0),null===(n=g.iP.manager)||void 0===n||n.show(i)}function D(e){var t,n;null===(t=e.names)||void 0===t||t.forEach((e=>y(e,!0))),null===(n=g.iP.manager)||void 0===n||n.view(e)}function W(){return g.iP.getInstances()}function F(e){c.A.terminalLog(e.type,e.title,e.details)}function G(e){return(0,r.sH)(this,void 0,void 0,(function*(){const t=(0,m.A)();yield t.conditionalLoadingScreen(e.loadingScreen,(()=>(0,r.sH)(this,void 0,void 0,(function*(){return t.updateSpecification(e.specification,e.urloverrides)}))))}))}function J(e){return(0,r.sH)(this,void 0,void 0,(function*(){const t=(0,m.A)();yield t.conditionalLoadingScreen(e.loadingScreen,(()=>(0,r.sH)(this,void 0,void 0,(function*(){(yield t.updateSpecification(e.specification,e.urloverrides))||(yield t.updateDataflow(e.dataflow))}))))}))}function B(e){return(0,r.sH)(this,void 0,void 0,(function*(){const t=w(e.graph_id);t.selectedNodes=t.selectedNodes.filter((t=>!e.nodes.unselected.includes(t.id))),e.nodes.selected.forEach((n=>{const i=b(e.graph_id,n);t.selectedNodes.includes(i)||t.selectedNodes.push(i)}))}))}function K(){throw new Error('Frontend registering available only through "postMessage" interface.')}class z extends o.JSONRPCServerAndClient{constructor(){super(...arguments),Object.defineProperty(this,"customMethodRegex",{enumerable:!0,configurable:!0,writable:!0,value:null}),Object.defineProperty(this,"customMethodReplace",{enumerable:!0,configurable:!0,writable:!0,value:null})}}const V=/^custom_.*$/,U="dataflow_run",Y=new(a())({schemas:[u],allowUnionTypes:!0,strict:!0}),Z=l.cj,X=l.s,Q=l.ji;let ee;try{[Z,X,Q].forEach((e=>{Object.entries(e).forEach((([e,t])=>{var n;ee=e,Y.compile(t.params),Y.compile(null!==(n=t.returns)&&void 0!==n?n:{})}))}))}catch(e){throw new Error(`Procedures specification schema '${ee}' is incorrect: ${e}`)}const te=(e,t,n)=>(0,r.sH)(void 0,void 0,void 0,(function*(){var i;if(!(t.method in Z)){if(void 0!==t.id)return(0,o.createJSONRPCErrorResponse)(t.id,1,"Requested method does not exist");throw new Error("Requested method does not exist")}const r=Z[t.method];if(!Y.validate(r.params,null!==(i=t.params)&&void 0!==i?i:{})){if(void 0!==t.id)return(0,o.createJSONRPCErrorResponse)(t.id,1,"Request does not match specification");throw new Error("Request does not match specification")}const s=yield e(t,n);if(void 0===t.id)return null;if(void 0!==(null==s?void 0:s.result)&&null!==r.returns&&!Y.validate(r.returns,s.result)){if(void 0!==t.id)return(0,o.createJSONRPCErrorResponse)(t.id,1,"Response does not match specification");throw new Error("Response does not match specification")}return s}));let ne=1;const ie=()=>ne++,re=new Map;let oe;const se=e=>{var t;return e.result&&e.id&&(null===(t=re.get(e.id))||void 0===t?void 0:t.returns)&&!Y.validate(re.get(e.id).returns,e.result)?(0,o.createJSONRPCErrorResponse)(e.id,d.FC.ERROR,"Response does not match specification"):e};class ae extends o.JSONRPCClient{receive(e){e=Array.isArray(e)?e:[e],super.receive(e.map(se))}}const ce={get jsonRPC(){return oe||function(){oe=new z(new o.JSONRPCServer,new ae(((e,t)=>(0,r.sH)(this,[e,t],void 0,(function*(e,{externalApp:t}){var n;if(!t)throw new Error("Missing backend.");const i=V.test(e.method)?U:e.method;if(!(i in Q)&&!(i in X))throw new Error("Requested method not known");const r=i in Q?Q:X,o=r[i];if(!Y.validate(o.params,null!==(n=e.params)&&void 0!==n?n:{}))return Promise.reject(new Error("Request does not match specification"));e.id&&re.set(e.id,o);const s=r===X?"backend-api":"external-api";try{t.request(JSON.parse(JSON.stringify(e)),s)}catch(e){return Promise.reject(e)}return Promise.resolve()}))),ie)),oe.server.applyMiddleware(te),Object.entries(i).forEach((([e,t])=>{"function"==typeof t&&e in Z?oe.addMethod(e,t):"function"==typeof t&&c.A.showToast("warning",`Function ${e} was not registered as RPC method`)})),oe.customMethodRegex=V,oe.customMethodReplace=U}(),oe}}.jsonRPC},57565:(e,t,n)=>{n.d(t,{ir:()=>i});const i=new class{constructor(){Object.defineProperty(this,"exposedInterfaces",{enumerable:!0,configurable:!0,writable:!0,value:new Map})}clearRegistry(){this.exposedInterfaces.clear()}pushGraphIdToRegistry(e,t){const n=this.exposedInterfaces.get(e);if(!n)throw new Error(`Interface with id ${e} not found in the register.`);n.graphIds.push(t)}createSharedInterface(e){const t=this.exposedInterfaces.get(e.id);if(!t)throw new Error(`'Interface with id ${e.id} not found in the register.`);Object.defineProperty(e,"maxConnectionsCount",{get:()=>t.sharedInterface.maxConnectionsCount,set(e){t.sharedInterface.maxConnectionsCount=e}}),Object.defineProperty(e,"connectionCount",{get:()=>t.sharedInterface.connectionCount,set(e){t.sharedInterface.connectionCount=e}}),Object.defineProperty(e,"type",{get:()=>t.sharedInterface.type})}isRegistered(e){return this.exposedInterfaces.has(e)}getRegisteredInterface(e){if(!this.exposedInterfaces.has(e))throw new Error(`Interface of id ${e} is not registered.`);return this.exposedInterfaces.get(e)}deleteRegisteredInterface(e){if(!this.exposedInterfaces.has(e))throw new Error(`Interface of id ${e} is not registered.`);return this.exposedInterfaces.delete(e)}registerInterface(e,t){if(this.exposedInterfaces.has(e.id))throw new Error(`Trying to register an interface of id ${e.id}, but it is already registered.`);this.exposedInterfaces.set(e.id,{sharedInterface:e,sharedInterfaceGraphId:t,graphIds:[]})}}},93617:(e,t,n)=>{n.d(t,{A:()=>d,E:()=>c});var i=n(85246),r=n(35127),o=n(42231),s=n(34580);const a=(0,i.bO)({timeout:5e3,position:i.II.BOTTOM_RIGHT,icon:!1,closeButton:!1}),c={info:0,warning:1,error:2};class d{static NotificationHandler=!0;static defaultShowOption=!0;static setShowNotification(e){d.showNotifications=e}static setShowOption(e){d.defaultShowOption=e}static restoreShowNotification(){d.showNotifications=d.defaultShowOption}static showToast(e,t){const n={component:o.A,props:{type:e,message:t}};if(c[e]>=c[s.Ay.getEditorManagerInstance().baklavaView.logLevel?.toLowerCase()]&&d.showNotifications)a(n);else{const e=document.querySelector("#navbar-bell>.indicator");e&&(e.classList.remove("animate"),setTimeout((()=>e.classList.add("animate")),300))}r.xv.add({type:e,message:t})}static terminalLog(e,t,n){d.showToast(e,t),r.iP.addParsed(t,n)}}}}]);
//# sourceMappingURL=index-2d0f0968.f2f5ea9f.js.map