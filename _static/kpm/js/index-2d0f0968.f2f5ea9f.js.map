{"version":3,"file":"js/index-2d0f0968.f2f5ea9f.js","mappings":"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","sources":["webpack://pipeline-manager/./src/core/communication/externalApp/backend.ts","webpack://pipeline-manager/./src/core/communication/connectionManager.ts","webpack://pipeline-manager/./src/core/communication/externalApp/frontend.ts","webpack://pipeline-manager/./src/core/communication/ExternalApplicationManager.js","webpack://pipeline-manager/./src/core/communication/runInformation.ts","webpack://pipeline-manager/./src/core/events.js","webpack://pipeline-manager/./src/core/NodeFactory.js","webpack://pipeline-manager/./src/core/nodeCreation/ConfigurationState.ts","webpack://pipeline-manager/./src/core/layoutEngines/cytoscapeEngine.js","webpack://pipeline-manager/./src/core/interfaceParser.js","webpack://pipeline-manager/./src/core/Specification.js","webpack://pipeline-manager/./src/core/layoutEngines/noLayoutEngine.js","webpack://pipeline-manager/./src/core/utils.ts","webpack://pipeline-manager/./src/core/stores.js","webpack://pipeline-manager/./src/core/nodeCreation/Configuration.ts","webpack://pipeline-manager/./src/core/layoutEngines/baseEngine.js","webpack://pipeline-manager/./src/core/doubleClick.js","webpack://pipeline-manager/./src/core/snappers.ts","webpack://pipeline-manager/./src/core/communication/utils.ts","webpack://pipeline-manager/./src/core/communication/remoteProcedures.ts","webpack://pipeline-manager/./src/core/communication/rpcCommunication.ts","webpack://pipeline-manager/./src/core/interfaceRegistry.ts","webpack://pipeline-manager/./src/core/notifications.js"],"sourcesContent":["import { __awaiter } from \"tslib\";\nimport { io } from 'socket.io-client';\nimport { JSONRPCCustomErrorCode } from '../../utils';\nimport NotificationHandler from '../../notifications';\nclass ExternalBackendApp {\n    // eslint-disable-next-line no-useless-constructor\n    constructor(url, jsonRPC, maxMessageLength = 256 * 1024) {\n        Object.defineProperty(this, \"url\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: url\n        });\n        Object.defineProperty(this, \"jsonRPC\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: jsonRPC\n        });\n        Object.defineProperty(this, \"maxMessageLength\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: maxMessageLength\n        });\n        Object.defineProperty(this, \"socket\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.socket = io(url, { extraHeaders: ExternalBackendApp.commonHeaders });\n        this.socket.on('connect', () => NotificationHandler.terminalLog('info', 'Initialized connection with communication server', null));\n        this.socket.on('disconnect', () => {\n            NotificationHandler.terminalLog('warning', 'Connection with communication server disrupted', null);\n            this.jsonRPC.rejectAllPendingRequests('WebSocket disconnected');\n        });\n        this.socket.on('api', (data) => __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.jsonRPC.server.receive(data);\n            if (response) {\n                try {\n                    const ack = yield this.socket.emitWithAck('external-api', response);\n                    if (ack !== undefined && !ack) {\n                        NotificationHandler.terminalLog('error', 'Response to external app was not send', null);\n                    }\n                }\n                catch (error) {\n                    NotificationHandler.terminalLog('error', `Response to ${data.method} request cannot be send`, error);\n                }\n            }\n        }));\n        this.socket.on('api-response', (response) => { this.jsonRPC.client.receive(response); });\n    }\n    isConnected() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const { status: { connected } } = yield this.jsonRPC.request('status_get', undefined, { externalApp: this });\n                return connected;\n            }\n            catch (_a) {\n                return false;\n            }\n        });\n    }\n    onConnect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a;\n            try {\n                yield this.jsonRPC.request('external_app_connect', undefined, { externalApp: this });\n                return true;\n            }\n            catch (unknownError) {\n                const error = unknownError;\n                const errorCode = (_a = error.code) !== null && _a !== void 0 ? _a : JSONRPCCustomErrorCode.EXCEPTION_RAISED;\n                const messageType = (errorCode !== JSONRPCCustomErrorCode.NEWER_SESSION_AVAILABLE) ? 'warning' : 'info';\n                NotificationHandler.terminalLog(messageType, error.message, undefined);\n                return false;\n            }\n        });\n    }\n    request(data, endpoint) {\n        var _a;\n        if (this.socket.disconnected)\n            throw new Error('WebSocket is disconnected. Make sure the communication server is available.');\n        const stringify = JSON.stringify(data);\n        // Emit request in chunks\n        if (stringify.length > this.maxMessageLength) {\n            const messageID = (_a = data.id) !== null && _a !== void 0 ? _a : crypto.randomUUID();\n            for (let i = 0; i < stringify.length; i += this.maxMessageLength) {\n                this.socket.emit(endpoint, {\n                    id: messageID,\n                    chunk: stringify.substring(i, Math.min(i + this.maxMessageLength, stringify.length)),\n                    end: i + this.maxMessageLength >= stringify.length,\n                });\n            }\n            // Emit whole request\n        }\n        else {\n            this.socket.emit(endpoint, data);\n        }\n    }\n}\nObject.defineProperty(ExternalBackendApp, \"commonHeaders\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: {\n        'Access-Control-Allow-Origin': 'http://localhost',\n        'Access-Control-Allow-Headers': 'Origin, X-Requested-With, Content-Type, Accept',\n    }\n});\nexport default ExternalBackendApp;\n","import { __awaiter } from \"tslib\";\nimport NotificationHandler from '../notifications.js';\nexport default class ConnectionManager {\n    // eslint-disable-next-line no-useless-constructor\n    constructor(connectionHook, disconnectionHook) {\n        Object.defineProperty(this, \"connectionHook\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: connectionHook\n        });\n        Object.defineProperty(this, \"disconnectionHook\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: disconnectionHook\n        });\n        Object.defineProperty(this, \"isRunning\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"connected\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n    }\n    add(externalApp) { this.connected.set(externalApp, false); }\n    remove(externalApp) { return this.connected.delete(externalApp); }\n    poll() {\n        return __awaiter(this, arguments, void 0, function* (interval = 1500) {\n            this.isRunning = true;\n            const updating = new Set();\n            while (this.isRunning) {\n                this.connected.keys()\n                    .filter((externalApp) => !updating.has(externalApp))\n                    .forEach((externalApp) => {\n                    updating.add(externalApp);\n                    this.updateConnection(externalApp).then(() => updating.delete(externalApp));\n                });\n                // eslint-disable-next-line no-await-in-loop\n                yield new Promise((resolve) => { setTimeout(resolve, interval); });\n            }\n        });\n    }\n    updateConnection(externalApp) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const wasConnected = this.connected.get(externalApp);\n                let isConnected = yield externalApp.isConnected();\n                // If the application was connected and the connection was lost, a warning is displayed.\n                if (!isConnected && wasConnected) {\n                    NotificationHandler.terminalLog('warning', 'External application was disconnected', undefined);\n                    this.disconnectionHook(externalApp);\n                }\n                if (isConnected && !wasConnected) {\n                    if (yield externalApp.onConnect()) {\n                        this.connectionHook(externalApp);\n                    }\n                    else {\n                        isConnected = false;\n                    }\n                }\n                this.connected.set(externalApp, isConnected);\n            }\n            catch (error) {\n                this.connected.set(externalApp, false);\n            }\n        });\n    }\n    pollStop() { this.isRunning = false; }\n}\n","import { __awaiter } from \"tslib\";\nexport default class ExternalFrontendApp {\n    // eslint-disable-next-line no-useless-constructor\n    constructor(source) {\n        Object.defineProperty(this, \"source\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: source\n        });\n    }\n    // eslint-disable-next-line class-methods-use-this\n    isConnected() {\n        return __awaiter(this, void 0, void 0, function* () { return true; });\n    }\n    // eslint-disable-next-line class-methods-use-this\n    onConnect() {\n        return __awaiter(this, void 0, void 0, function* () { return true; });\n    }\n    request(data, endpoint) {\n        if (endpoint === 'backend-api')\n            throw new Error('Frontend external app does not support backend endpoints');\n        this.source.postMessage(data);\n    }\n}\n","/*\n * Copyright (c) 2022-2024 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { createJSONRPCErrorResponse, createJSONRPCSuccessResponse, JSONRPCErrorCode } from 'json-rpc-2.0';\nimport { charset } from 'mime-types';\nimport { nextTick } from 'vue';\nimport { backendApiUrl, PMMessageType, JSONRPCCustomErrorCode } from '../utils';\n\n// eslint-disable-next-line import/no-cycle\nimport jsonRPC from './rpcCommunication';\nimport runInfo from './runInformation';\nimport NotificationHandler from '../notifications';\nimport EditorManager, { loadJsonFromRemoteLocation } from '../EditorManager';\nimport ExternalBackendApp from './externalApp/backend.ts';\nimport ConnectionManager from './connectionManager.ts';\nimport ExternalFrontendApp from './externalApp/frontend.ts';\n\n// Default external application capabilities\nconst defaultAppCapabilities = {};\n\n/**\n * Creates notifications based on response received from external application.\n */\nfunction handleExternalAppResponse(response) {\n    // Status is HTTPCodes.OK so a message from the application is received.\n    if (response.type === PMMessageType.OK) {\n        NotificationHandler.terminalLog('info', response.content);\n    } else if (response.type === PMMessageType.ERROR) {\n        NotificationHandler.terminalLog('error', `Error occurred: ${response.content}`, response.content);\n    } else if (response.type === PMMessageType.WARNING) {\n        NotificationHandler.terminalLog('warning', `Warning: ${response.content}`, response.content);\n    }\n}\n\n/**\n * Creates notifications based on specification.\n * Returns `true` if error appeared.\n */\nfunction handleSpecificationResult({ errors, warnings, info }, errorTitle, warningTitle, infTitle) {\n    if (Array.isArray(warnings) && warnings.length) {\n        NotificationHandler.terminalLog('warning', warningTitle, warnings);\n    }\n    if (Array.isArray(errors) && errors.length) {\n        NotificationHandler.terminalLog('error', errorTitle, errors);\n        return true;\n    }\n    if (Array.isArray(info) && info.length) {\n        NotificationHandler.terminalLog('info', infTitle, info);\n    }\n    return false;\n}\n\n/**\n * Creates notification about mismatched specification versions\n */\nfunction showVersionError(currentVersion, usedVersion) {\n    if (currentVersion === usedVersion) return;\n    NotificationHandler.terminalLog(\n        'error',\n        'Mismatched specification version',\n        `Specification version (${usedVersion}) differs from the current version (${currentVersion}). It may result in unexpected behaviour.` +\n        'Please refer to https://antmicro.github.io/kenning-pipeline-manager/changelogs.html to see if that is the case.',\n    );\n}\n\nclass ExternalApplicationManager {\n    editorManager = EditorManager.getEditorManagerInstance();\n\n    appCapabilities = {};\n\n    externalApp = null;\n\n    connectionHook = null;\n\n    constructor() {\n        /**\n         * Assigning the ExternalApplicationManager instance to the EditorManager properties.\n         * This assignment bypasses the cycle problem if the ExternalApplicationManager was normally\n         * imported in the EditorManager.\n         */\n        this.editorManager.externalApplicationManager = this;\n\n        // eslint-disable-next-line no-param-reassign\n        const resetProgress = () => runInfo.forEach((itemInfo) => { itemInfo.inProgress = false; });\n        this.connectionManager = new ConnectionManager(\n            (externalApp) => this.initializeConnection(externalApp),\n            resetProgress,\n        );\n        this.connectionManager.poll();\n    }\n\n    isExternalAppAvailable() {\n        return this.externalApp !== null;\n    }\n\n    isConnected() {\n        return Array.from(this.connectionManager.connected.values()).some(Boolean);\n    }\n\n    /**\n     * Wrap the RPC request with the current application.\n     *\n     * @param {string} method - API endpoint.\n     * @param {any} params - Parameters for the given API endpoint.\n     * @returns RPC response.\n     */\n    async request(method, params) {\n        const { externalApp } = this;\n        return jsonRPC.request(method, params, { externalApp });\n    }\n\n    /**\n     * Event handler that asks the backend to send a dataflow specification.\n     * If the backend did not manage to send it the user is alerted with a feedback message.\n     * Otherwise the specification is passed to the editor that renders a new environment.\n     */\n    async requestSpecification() {\n        let message = 'Unknown error';\n        try {\n            const data = await this.request('specification_get');\n\n            if (data.type === PMMessageType.OK) {\n                const specification = data.content;\n\n                await this.updateSpecification(specification);\n\n                NotificationHandler.terminalLog('info', 'Specification loaded successfully');\n            } else if (data.type === PMMessageType.WARNING) {\n                message = data.content;\n                NotificationHandler.terminalLog('warning', message);\n            } else if (data.type === PMMessageType.ERROR) {\n                message = data.content;\n                NotificationHandler.terminalLog('error', message);\n            }\n        } catch (error) {\n            message = error.message;\n            NotificationHandler.terminalLog('error', message);\n        }\n    }\n\n    async conditionalLoadingScreen(load, callback) {\n        const { setLoad } = this.editorManager.baklavaView.editor.events;\n\n        if (load) {\n            setLoad.emit(true);\n            await nextTick();\n        }\n        const result = await callback();\n        if (load) {\n            setLoad.emit(false);\n            await nextTick();\n        }\n        return result;\n    }\n\n    async updateSpecification(specification, urloverrides) {\n        if (typeof specification === 'string' || specification instanceof String) {\n            const [success, specificationOrError] = await loadJsonFromRemoteLocation(specification);\n            if (!success) {\n                NotificationHandler.terminalLog('error', 'Specification is invalid', specificationOrError);\n                return true;\n            }\n\n            // eslint-disable-next-line no-param-reassign\n            specification = specificationOrError;\n        }\n\n        if (handleSpecificationResult(\n            EditorManager.validateSpecification(specification),\n            'Specification is invalid',\n            'Warnings when validating specification',\n            'Validated specification',\n        )) {\n            showVersionError(\n                this.editorManager.specificationVersion,\n                JSON.parse(specification).version,\n            );\n            return true;\n        }\n\n        const error = handleSpecificationResult(\n            await this.editorManager.updateEditorSpecification(\n                specification, false, true, urloverrides,\n            ),\n            'Errors when loading specification',\n            'Warnings when loading specification',\n            'Loaded specification',\n        );\n        if (error) {\n            showVersionError(\n                this.editorManager.specificationVersion,\n                JSON.parse(specification).version,\n            );\n        }\n        return error;\n    }\n\n    async updateDataflow(dataflow) {\n        if (typeof dataflow === 'string' || dataflow instanceof String) {\n            const [success, dataflowOrError] = await loadJsonFromRemoteLocation(dataflow);\n            if (!success) {\n                NotificationHandler.terminalLog('error', 'Dataflow is invalid', dataflowOrError);\n                return;\n            }\n\n            // eslint-disable-next-line no-param-reassign\n            dataflow = dataflowOrError;\n        }\n        const { errors, warnings, info } = await this.editorManager.loadDataflow(dataflow);\n        if (Array.isArray(errors) && errors.length) {\n            NotificationHandler.terminalLog('error', 'Dataflow is invalid', errors);\n            if (Array.isArray(info) && info.length) {\n                NotificationHandler.terminalLog(\n                    'error',\n                    'Mismatched specification version',\n                    `${info} Please refer to https://antmicro.github.io/kenning-pipeline-manager/changelogs.html to see if that is the case.`,\n                );\n            }\n        } else if (Array.isArray(warnings) && warnings.length) {\n            NotificationHandler.terminalLog('warning', 'Dataflow loaded with warning', warnings);\n        } else if (Array.isArray(info) && info.length) {\n            NotificationHandler.terminalLog('info', 'Dataflow loaded', info);\n        }\n    }\n\n    /**\n    * Provides capabilities of the third-party app connected via server\n    * to Pipeline Manager's frontend.\n    */\n    async requestAppCapabilities() {\n        try {\n            const appCapabilities = await this.request('app_capabilities_get');\n            this.appCapabilities = { ...defaultAppCapabilities, ...appCapabilities };\n        } catch (error) {\n            this.appCapabilities = { ...defaultAppCapabilities };\n            NotificationHandler.terminalLog('warning', 'Application capabilities cannot be retrieved, using defaults', error.message);\n        }\n    }\n\n    /**\n    * Handles dataflow export.\n    */\n    async requestDataflowExport() {\n        const dataflow = this.editorManager.saveDataflow();\n        if (!dataflow) return false;\n\n        let data;\n        try {\n            data = await this.request('dataflow_export', { dataflow });\n        } catch (error) {\n            // The connection was closed.\n            data = error.message;\n            NotificationHandler.terminalLog('error', data);\n            return false;\n        }\n\n        // Status is HTTPCodes.OK so a message from the application is received.\n        if (data.type === PMMessageType.OK) {\n            return data;\n        }\n\n        if (data.type === PMMessageType.ERROR) {\n            NotificationHandler.terminalLog('error', `Error occurred: ${data.content}`, data.content);\n        } else if (data.type === PMMessageType.WARNING) {\n            NotificationHandler.terminalLog('warning', `Warning: ${data.content}`, data.content);\n        }\n        return false;\n    }\n\n    /**\n     * Event handler that loads a current dataflow from the editor and sends a request\n     * to the backend based on the action argument.\n     * The user is alerted with a feedback message.\n     *\n     * @param procedureName Name of the requested procedure.\n     * @param requireResponse Whether response from external application should be awaited.\n     */\n    async requestDataflowAction(procedureName, requireResponse) {\n        const dataflow = this.editorManager.saveDataflow();\n        const runProcedureInfo = runInfo.get(procedureName);\n        if (!dataflow) return;\n        const validatedProcedureName = (jsonRPC.customMethodRegex.test(procedureName)) ?\n            jsonRPC.customMethodReplace : procedureName;\n\n        if (validatedProcedureName === 'dataflow_run') {\n            if (runProcedureInfo.inProgress) {\n                NotificationHandler.showToast('error', 'Previous run has not finished, cannot process this request');\n                return;\n            }\n            NotificationHandler.showToast('info', 'Running dataflow');\n        }\n        if (requireResponse) {\n            runProcedureInfo.inProgress = true;\n\n            let data;\n            try {\n                if (validatedProcedureName.startsWith('dataflow_')) {\n                    data = await this.request(procedureName, { dataflow });\n                } else {\n                    data = await this.request(validatedProcedureName);\n                }\n            } catch (error) {\n                // The connection was closed\n                data = error.message;\n                NotificationHandler.terminalLog('error', 'Cannot create a request', data);\n                runProcedureInfo.inProgress = false;\n                return;\n            }\n\n            handleExternalAppResponse(data);\n            runProcedureInfo.inProgress = false;\n        } else if (validatedProcedureName.startsWith('dataflow_')) {\n            this.request(procedureName, { dataflow });\n        } else {\n            this.request(validatedProcedureName);\n        }\n    }\n\n    /**\n     * Event handler that check if remote procedure is running and send stop request.\n     * The user is alerted with a feedback message.\n     *\n     * @param procedureName Name of the requested procedure.\n     */\n    // eslint-disable-next-line class-methods-use-this\n    async requestDataflowStop(procedureName) {\n        if (!runInfo.get(procedureName).inProgress) {\n            NotificationHandler.showToast('error', 'Nothing to stop, no ongoing jobs running');\n            return;\n        }\n\n        try {\n            const response = await this.request('dataflow_stop', { method: procedureName });\n            handleExternalAppResponse(response);\n        } catch (error) {\n            NotificationHandler.terminalLog('error', error.message);\n        }\n    }\n\n    /**\n     * Event handler that loads a file and asks the backend to delegate this operation\n     * to the external application to parse it into the Pipeline Manager format\n     * so that it can be loaded into the editor.\n     * It the validation is successful it is loaded as the current dataflow.\n     * Otherwise the user is alerted with a feedback message.\n     *\n     * @param dataflow Dataflow to be impported\n     */\n    async importDataflow() {\n        const file = document.getElementById('request-dataflow-button').files[0];\n        if (!file) return;\n\n        const reader = new FileReader();\n        const encoding = charset(file.type);\n        const readerPromise = new Promise((resolve) => {\n            reader.onloadend = () => {\n                resolve(\n                    (encoding) ? reader.result : reader.result.replace(/data:.*;base64,/, ''),\n                );\n            };\n        });\n        // Read file as text if possible, otherwise return base64 string\n        if (encoding) {\n            reader.readAsText(file, encoding);\n        } else {\n            reader.readAsDataURL(file);\n        }\n        const dataflow = await readerPromise;\n        if (!dataflow) {\n            NotificationHandler.showToast('error', 'File cannot be loaded');\n            return;\n        }\n\n        try {\n            const data = await this.request('dataflow_import', { external_application_dataflow: dataflow, mime: file.type, base64: !encoding });\n            if (data.type === PMMessageType.OK) {\n                const { errors, warnings } = await this.editorManager.loadDataflow(data.content);\n                if (Array.isArray(errors) && errors.length) {\n                    NotificationHandler.terminalLog('error', 'Dataflow is invalid', errors);\n                } else if (Array.isArray(warnings) && warnings.length) {\n                    NotificationHandler.terminalLog('warning', 'Dataflow imported with warning', warnings);\n                } else {\n                    NotificationHandler.showToast('info', 'Imported dataflow');\n                }\n            } else if (data.type === PMMessageType.ERROR) {\n                const message = data.content;\n                NotificationHandler.terminalLog('error', `Error occurred: ${data.content}`, message);\n            } else if (data.type === PMMessageType.WARNING) {\n                NotificationHandler.terminalLog('warning', `Warning: ${data.content}`, 'Imported dataflow');\n            }\n        } catch (error) {\n            const data = error.message;\n            NotificationHandler.terminalLog('error', data);\n        }\n    }\n\n    /**\n     * Send information to external application about changed values (like nodes, connections,\n     * positions, properties).\n     *\n     * @param method Name of the JSON-RPC method.\n     * @param changedProperties Params of the send request, should contain changed values.\n     */\n    async notifyAboutChange(method, changedProperties) {\n        if (!this.isConnected() || !this.editorManager.notifyWhenChanged) return;\n        try {\n            await this.request(method, changedProperties);\n        } catch (error) {\n            NotificationHandler.terminalLog(\n                'warning', 'Notifying about change failed', `${error.message} (method: ${method})`,\n            );\n        }\n    }\n\n    /**\n     * Send information to external application about input received by writable terminal.\n     *\n     * @param terminal Name Name of the terminal\n     * @param message Input provided for the terminal\n     */\n    async requestTerminalRead(terminalName, message) {\n        if (!this.isConnected()) return;\n        try {\n            await this.request('terminal_read', { name: terminalName, message });\n        } catch (error) {\n            NotificationHandler.terminalLog('warning', 'Sending terminal input failed', error.message);\n        }\n    }\n\n    /**\n     * Function used to initialize connection with the external application and request\n     * specification. Should be called after DOM is created.\n     *\n     * It checks whether a connection is established.\n     * If it is then it just requests a specification.\n     * If it is not then it opens a TCP port, wait for the application to connect and then\n     * requests specification.\n     *\n     * @param {import('./externalApp/base.ts').ExternalApp} externalApp\n     */\n    async initializeConnection(_externalApp) {\n        NotificationHandler.terminalLog(\n            'info',\n            `External application connected successfully`,\n            undefined,\n        );\n\n        await Promise.all([\n            this.requestSpecification(),\n            this.requestAppCapabilities(),\n        ]);\n\n        try {\n            await this.request('frontend_on_connect');\n        } catch (error) {\n            if (error.code !== JSONRPCErrorCode.MethodNotFound &&\n                error.code !== JSONRPCCustomErrorCode.EXTERNAL_APPLICATION_NOT_CONNECTED) {\n                NotificationHandler.terminalLog('error', error.message, error.data);\n            }\n        }\n\n        if (this.connectionHook !== null) this.connectionHook();\n    }\n\n    registerConnectionHook(connectionHook) {\n        this.connectionHook = connectionHook;\n    }\n\n    /**\n     * Registers external application and calls connection hook, if exists.\n     *\n     * @param {import('./externalApp/base.ts').ExternalApp} externalApp - External application.\n     */\n    registerApplication(externalApp) {\n        this.externalApp = externalApp;\n        this.connectionManager.add(externalApp);\n\n        if (this.connectionHook !== null) this.connectionHook();\n    }\n\n    /**\n     * Registers external backend application.\n     *\n     * @param {string} url - Backend URL.\n     */\n    registerBackendApplication(url) {\n        this.registerApplication(new ExternalBackendApp(url, jsonRPC));\n    }\n\n    /**\n     * Registers external frontend.\n     *\n     * @param {Window} sourceWindow - Wrapping window.\n     * @param {import('json-rpc-2.0').JSONRPCRequest} request - Wrapping window.\n     * @returns {import('json-rpc-2.0').JSONRPCResponse} Response with success or error message.\n     */\n    registerFrontendApplication(sourceWindow, request) {\n        const logAndRespond = (msgType, msg) => {\n            const [logType, response] = {\n                [PMMessageType.ERROR]: ['error', createJSONRPCErrorResponse(request.id, msgType, msg)],\n                [PMMessageType.WARNING]: ['warning', createJSONRPCSuccessResponse(request.id, msg)],\n                [PMMessageType.OK]: ['info', createJSONRPCSuccessResponse(request.id, msg)],\n            }[msgType];\n            NotificationHandler.terminalLog(logType, msg);\n            return response;\n        };\n\n        if (sourceWindow === window) return logAndRespond(PMMessageType.ERROR, 'External frontend cannot be a Pipeline Manager itself');\n        if (this.externalApp !== null) {\n            this.connectionManager.remove(this.externalApp);\n            logAndRespond(PMMessageType.WARNING, 'Replacing current external application.');\n        }\n\n        this.registerApplication(new ExternalFrontendApp(sourceWindow));\n        return logAndRespond(PMMessageType.OK, 'Registered external frontend successfully');\n    }\n}\n\nlet externalApplicationManager;\n\nexport default function getExternalApplicationManager() {\n    if (!externalApplicationManager) {\n        externalApplicationManager = new ExternalApplicationManager();\n        if (backendApiUrl) externalApplicationManager.registerBackendApplication(backendApiUrl);\n    }\n    return externalApplicationManager;\n}\n","/*\n * Copyright (c) 2022-2024 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n/* eslint-disable max-classes-per-file */\n/**\n * Class with information about ran procedure.\n */\nclass RunInfo {\n    /**\n     * @param procedureName Name of the procedure\n     */\n    constructor(procedureName) {\n        Object.defineProperty(this, \"procedureName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"hook\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: undefined\n        });\n        /** @private */\n        Object.defineProperty(this, \"pr_inProgress\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        this.procedureName = procedureName;\n    }\n    /**\n     * Finds progress bar affiliated with run.\n     * If cannot be found, throws Error.\n     */\n    get progressBar() {\n        const progressBar = document.querySelector(`#navbar-button-${this.procedureName} > .progress-bar`);\n        return progressBar;\n    }\n    /**\n     * Specifies if run is in progress.\n     */\n    get inProgress() {\n        return this.pr_inProgress;\n    }\n    set inProgress(value) {\n        const { progressBar } = this;\n        if (progressBar) {\n            if (!value)\n                progressBar.classList.remove('animate');\n            progressBar.style.width = '0%';\n        }\n        this.pr_inProgress = value;\n        if (this.hook !== undefined) {\n            this.hook();\n        }\n    }\n}\n/**\n * @template K key type\n * @template V value type\n * @extends {Map<K,V>}\n *\n * Map automatically creating values if key is not found.\n */\nclass DefaultMap extends Map {\n    constructor(defaultFactory) {\n        super();\n        Object.defineProperty(this, \"defaultFactory\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.defaultFactory = defaultFactory;\n    }\n    get(key) {\n        if (!super.has(key)) {\n            super.set(key, this.defaultFactory(key));\n        }\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return super.get(key);\n    }\n}\n/**\n * @extends {DefaultMap<string, RunInfo>}\n *\n * DefaultMap with custom hook run when RunInfo inProgress changes value.\n */\nclass RunInfoMap extends DefaultMap {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"hook\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: undefined\n        });\n    }\n    get(key) {\n        if (!super.has(key)) {\n            const newValue = this.defaultFactory(key);\n            newValue.hook = this.hook;\n            super.set(key, newValue);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return super.get(key);\n    }\n    setHook(hook) {\n        this.hook = hook;\n        // eslint-disable-next-line no-param-reassign\n        this.forEach((v) => { v.hook = hook; });\n    }\n}\nexport default new RunInfoMap((key) => new RunInfo(key));\n","/*\n * Copyright (c) 2022-2024 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/* eslint-disable import/prefer-default-export */\n\n// Mouse position\nlet y = 0;\nlet h = 0;\n\n// Height setting callback\nlet setTerminalHeight;\n\nconst mouseMoveHandler = (e) => {\n    const { clientY } = e;\n    const navBarHeight = 61;\n\n    // Calculate mouse move\n    const dy = y - clientY;\n\n    // Prevent terminal overflow under nav bar\n    if (clientY > navBarHeight) {\n        setTerminalHeight(h + dy);\n    }\n};\n\nconst mouseUpHandler = () => {\n    const terminalWrapper = document.querySelector('.terminal-wrapper');\n\n    document.removeEventListener('mousemove', mouseMoveHandler);\n    document.removeEventListener('mouseup', mouseUpHandler);\n    terminalWrapper.style['pointer-events'] = '';\n};\n\nexport const mouseDownHandler = (setHeight) => (e) => {\n    const terminalWrapper = document.querySelector('.terminal-wrapper');\n    setTerminalHeight = setHeight;\n\n    y = e.clientY;\n\n    // Calculate height of terminal panel\n    const styles = window.getComputedStyle(terminalWrapper);\n    h = parseInt(styles.height, 10);\n\n    document.addEventListener('mousemove', mouseMoveHandler);\n    document.addEventListener('mouseup', mouseUpHandler);\n    terminalWrapper.style['pointer-events'] = 'none';\n};\n","/*\n * Copyright (c) 2022-2024 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/* eslint-disable max-classes-per-file */\n\nimport { GraphTemplate, NodeInterface, Node } from '@baklavajs/core';\n\nimport { updateInterfacePosition } from '../custom/CustomNode.js';\nimport {\n    applySidePositions,\n    parseInterfaces,\n    validateInterfaceGroups,\n    generateProperties,\n    DYNAMIC_INTERFACE_SUFFIX,\n} from './interfaceParser.js';\n\nimport CheckboxInterface from '../interfaces/CheckboxInterface.js';\nimport HexInterface from '../interfaces/HexInterface.js';\nimport InputInterface from '../interfaces/InputInterface.js';\nimport IntegerInterface from '../interfaces/IntegerInterface.js';\nimport ListInterface from '../interfaces/ListInterface.js';\nimport NumberInterface from '../interfaces/NumberInterface.js';\nimport SelectInterface from '../interfaces/SelectInterface.js';\nimport SliderInterface from '../interfaces/SliderInterface.js';\nimport TextAreaInterface from '../interfaces/TextAreaInterface.js';\nimport TextInterface from '../interfaces/TextInterface.js';\nimport ButtonInterface from '../interfaces/ButtonInterface.js';\n\nimport { ir } from './interfaceRegistry.ts';\n\n/**\n * @param properties coming from the specification\n * @returns object that can be used to create properties or an array of errors\n * if any occurred.\n */\nexport function parseProperties(properties) {\n    const parsedProperties = {};\n    const usedNames = new Set();\n    const errors = [];\n\n    properties.forEach((prop) => {\n        if (prop.group !== undefined && Array.isArray(prop.group)) {\n            const parsedGroup = parseProperties(prop.group);\n            if (Array.isArray(parsedGroup) && parsedGroup.length) {\n                errors.push(...parsedGroup);\n            }\n\n            Object.entries(parsedGroup).forEach(([pgroupname]) => {\n                if (usedNames.has(pgroupname)) {\n                    const realname = pgroupname.slice(pgroupname.indexOf('_') + 1);\n                    errors.push(\n                        `Property named '${realname}' in a group property '${prop.name}' is a duplicate.`,\n                    );\n                }\n                usedNames.add(pgroupname);\n            });\n\n            prop.group = parsedGroup; // eslint-disable-line no-param-reassign\n        }\n\n        if (usedNames.has(`property_${prop.name}`)) {\n            errors.push(\n                `Property named '${prop.name}' is a duplicate.`,\n            );\n        }\n\n        parsedProperties[`property_${prop.name}`] = { ...prop };\n        usedNames.add(`property_${prop.name}`);\n    });\n\n    if (errors.length) {\n        return errors;\n    }\n\n    return parsedProperties;\n}\n\n/**\n * @param properties that are validated and parsed. The format\n * should be the same as the one returned by parseProperties.\n * @returns created properties\n */\nexport function createProperties(properties) {\n    const getIntf = (p, hidden = false) => {\n        const propName = p.name;\n        const propType = p.type;\n        let propDef = p.default;\n        let intf;\n\n        switch (propType) {\n            case 'constant':\n                intf = new TextInterface(propName, propDef);\n                break;\n            case 'text':\n                intf = new InputInterface(propName, propDef, p.readonly);\n                break;\n            case 'multiline':\n                intf = new TextAreaInterface(propName, propDef, p.readonly);\n                break;\n            case 'number':\n                intf = new NumberInterface(propName, propDef, p.min, p.max, p.readonly);\n                break;\n            case 'integer':\n                intf = new IntegerInterface(propName, propDef, p.min, p.max, p.readonly);\n                break;\n            case 'hex':\n                intf = new HexInterface(\n                    propName,\n                    propDef.toLowerCase(),\n                    p.min ? BigInt(p.min) : NaN,\n                    p.max ? BigInt(p.max) : NaN,\n                    p.readonly,\n                );\n                break;\n            case 'select': {\n                const it = p.values.map((element) => element.toString());\n                intf = new SelectInterface(propName, propDef, it, p.readonly);\n            } break;\n            case 'bool':\n                intf = new CheckboxInterface(propName, propDef, p.readonly);\n                break;\n            case 'slider':\n                if (propDef === undefined) {\n                    propDef = p.min;\n                }\n                intf = new SliderInterface(propName, propDef, p.min, p.max, p.step, p.readonly);\n                break;\n            case 'list':\n                if (propDef === null) {\n                    propDef = [];\n                }\n                intf = new ListInterface(propName, propDef, p.dtype, p.readonly);\n                break;\n            case 'button-url':\n                intf = new ButtonInterface(propName, () => window.open(intf.value, '_blank'), propDef);\n                break;\n            case 'button-api':\n                intf = new ButtonInterface(\n                    propName,\n                    () => intf.events.updated.emit(['button_click', { id: intf.id, value: intf.value }]),\n                    propDef);\n                break;\n            default:\n                /* eslint-disable no-console */\n                console.error(propType, ' input type is not recognized.');\n        }\n        if (intf !== undefined) {\n            intf.hidden = hidden;\n            intf.type = propType;\n\n            if (p.interfaceMaxConnectionsCount !== undefined) {\n                intf.interfaceMaxConnectionsCount = p.interfaceMaxConnectionsCount;\n            }\n\n            if (p.interfaceType !== undefined) {\n                intf.interfaceType = p.interfaceType;\n            }\n        }\n\n        return intf;\n    };\n\n    const tempProperties = {};\n\n    Object.entries(properties).forEach(([pname, p]) => {\n        if (p.group !== undefined) {\n            tempProperties[pname] = (() => {\n                const groupedProperty = getIntf(p);\n                groupedProperty.group = Object.keys(p.group);\n                return groupedProperty;\n            });\n            Object.entries(p.group).forEach(([pgroupname, pgroup]) => {\n                tempProperties[pgroupname] = () => getIntf(pgroup);\n            });\n        } else {\n            tempProperties[pname] = () => getIntf(p);\n        }\n    });\n    return tempProperties;\n}\n\n/**\n * Function performs sanity checking on parsed state before loading it\n * into the editor. It should throw explicit errors if any discrepancy is detected.\n *\n * @param parsedState that is passed to node to load\n * @param inputs inputs of the node\n * @param outputs outputs of the node\n * @returns list of errors.\n */\nfunction detectDiscrepancies(parsedState, inputs, outputs) {\n    let errors = [];\n\n    const checkType = (propType, value) => {\n        switch (propType) {\n            case 'constant':\n            case 'select':\n                return true;\n            case 'text':\n            case 'multiline':\n            case 'button-url':\n            case 'hex':\n                return typeof value === 'string';\n            case 'number':\n            case 'integer':\n            case 'slider':\n                return typeof value === 'number';\n            case 'bool':\n                return typeof value === 'boolean';\n            case 'list':\n                return Array.isArray(value);\n            case 'button-api':\n                return typeof value === 'object';\n            default:\n                return false;\n        }\n    };\n\n    // Checking for existence of interfaces defined\n    Object.keys({\n        ...parsedState.inputs,\n        ...parsedState.outputs,\n    }).forEach((ioName) => {\n        const name = ioName.slice(ioName.indexOf('_') + 1);\n        const direction = ioName.slice(0, ioName.indexOf('_'));\n        if (\n            !Object.prototype.hasOwnProperty.call(inputs, ioName) &&\n            !Object.prototype.hasOwnProperty.call(outputs, ioName)\n        ) {\n            if (direction === 'property') {\n                errors.push(`Property named '${name}' not found in specification!`);\n            } else if (!/\\[\\d+\\]$/.test(name)) {\n                errors.push(`Interface named '${name}' of direction '${direction}' not found in specification!`);\n            }\n        } else if (direction === 'property') {\n            // Verifying property type defined in the node and the value passed\n            const parsedValue = parsedState.inputs[ioName].value;\n            const propertyType = inputs[ioName].type;\n            if (!checkType(propertyType, parsedValue)) {\n                errors.push(`Property '${name}' type mismatch. ${propertyType} expected, ${typeof parsedValue} found.`);\n            } else if (propertyType === 'select') {\n                const { items } = inputs[ioName];\n                if (Array.isArray(items)) {\n                    if (!items.map(String).includes(String(parsedValue))) {\n                        errors.push(\n                            `Property '${name}' value mismatch. ${parsedValue} (type: ${typeof parsedValue}) not found in ${JSON.stringify(items)}`,\n                        );\n                    }\n                } else if (String(parsedValue) !== String(items)) {\n                    errors.push(\n                        `Property '${name}' value mismatch. Expected '${items}' (type: ${typeof items}), found '${parsedValue}' (type: ${typeof parsedValue}).`,\n                    );\n                }\n            } else if (propertyType === 'list') {\n                const { dtype } = inputs[ioName];\n\n                const mismatchedElements = parsedValue.filter((val) => {\n                    // Accept both 'integer' and 'number' for dtype 'integer'.\n                    if (dtype === 'integer') {\n                        return typeof val !== 'number' || !Number.isInteger(val);\n                    }\n                    return typeof val !== dtype;// eslint-disable-line valid-typeof\n                });\n                if (mismatchedElements.length > 0) {\n                    errors.push(\n                        `Property '${name}' value mismatch. ` +\n                        `Items: '${mismatchedElements.join(' ')}' are not of '${dtype}' dtype.` +\n                        `Items are of type: ${mismatchedElements.map((val) => typeof val).join(', ')}`,\n                    );\n                }\n            }\n        }\n    });\n\n    // Checking for existence of interface groups\n    Object.keys(parsedState.enabledInterfaceGroups).forEach((groupName) => {\n        if (\n            !Object.prototype.hasOwnProperty.call(inputs, groupName) &&\n            !Object.prototype.hasOwnProperty.call(outputs, groupName)\n        ) {\n            const direction = groupName.slice(0, groupName.indexOf('_'));\n            const name = groupName.slice(groupName.indexOf('_') + 1);\n\n            errors.push(`Interface group named '${name}' of direction '${direction}' not found in specification!`);\n        }\n    });\n\n    if (errors && errors.length) {\n        return errors;\n    }\n\n    errors = validateInterfaceGroups(\n        Object.keys(parsedState.enabledInterfaceGroups),\n        inputs,\n        outputs,\n    );\n\n    return errors;\n}\n\n/**\n * @param state state to be loaded. Should be a valid dataflow\n * @returns state that can be given to baklavajs, or an array of errors if any occurred\n */\nfunction parseNodeState(state) {\n    const newState = JSON.parse(JSON.stringify(state));\n\n    if (newState.interfaces !== undefined) {\n        const out = parseInterfaces(newState.interfaces, [], []);\n        if (Array.isArray(out) && out.length) {\n            return out;\n        }\n\n        const { inputs, outputs } = out;\n        newState.inputs = inputs;\n        newState.outputs = outputs;\n\n        delete newState.interfaces;\n    }\n\n    if (newState.properties !== undefined) {\n        const out = parseProperties(newState.properties);\n        if (Array.isArray(out) && out.length) {\n            return out;\n        }\n\n        newState.inputs = { ...newState.inputs, ...out };\n        delete newState.properties;\n    }\n\n    if (newState.enabledInterfaceGroups !== undefined) {\n        const interfaceGroups = {};\n        newState.enabledInterfaceGroups.forEach((intf) => {\n            interfaceGroups[`${intf.direction}_${intf.name}`] = { ...intf };\n        });\n        newState.enabledInterfaceGroups = interfaceGroups;\n    } else {\n        newState.enabledInterfaceGroups = {};\n    }\n\n    newState.title = newState.instanceName ?? '';\n    delete newState.instanceName;\n\n    newState.parsed = true;\n    return newState;\n}\n\nexport class CustomNode extends Node {\n    inputs = {};\n\n    outputs = {};\n\n    type = undefined;\n\n    constructor(\n        name,\n        layer,\n        inputs,\n        outputs,\n        twoColumn,\n        description = '',\n        nodeExtends = [],\n        nodeExtending = [],\n        nodeSiblings = [],\n        width = 300,\n        relatedGraphs = undefined,\n    ) {\n        super();\n\n        this.description = description;\n        this.extends = nodeExtends;\n        this.extending = nodeExtending;\n        this.siblings = nodeSiblings;\n        this.layer = layer;\n        this.title = name;\n        this.twoColumn = twoColumn;\n        this.type = name;\n        this.width = width;\n        this.relatedGraphs = relatedGraphs;\n\n        Object.keys(inputs).forEach((k) => {\n            const intf = inputs[k]();\n            this.addInput(k, intf);\n        });\n\n        Object.keys(outputs).forEach((k) => {\n            const intf = outputs[k]();\n            this.addOutput(k, intf);\n        });\n    }\n\n    /**\n     * Function for updating dynamic interfaces of the node based on the property passed.\n     *\n     * @param {*} prop property that is responsible for creating dynamic interfaces.\n     * It must have name and value properties.\n     */\n    updateDynamicInterfaces(prop) {\n        const interfaces = [];\n        const { value } = prop;\n\n        // Ensure prop.name is defined and is a string.\n        if (typeof prop.name !== 'string') {\n            throw new Error('Property \\'name\\' is undefined or not a string in updateDynamicInterfaces.');\n        }\n\n        // The interface metadata has to be obtained from the specification of the property\n        const propertyInput = this.inputs[`property_${prop.name}`];\n        const interfaceType = propertyInput?.interfaceType;\n        const interfaceMaxConnectionsCount = propertyInput?.interfaceMaxConnectionsCount;\n\n        // Direction is obtained from property name\n        const propName = prop.name.split(' ');\n        // Ensure propName has enough elements\n        if (propName.length < 2) {\n            throw new Error(\n                'Property name is too short to extract direction in updateDynamicInterfaces.' +\n                `Property name: ${prop.name}`,\n            );\n        }\n        const direction = propName[propName.length - 2];\n        // The DYNAMIC_INTERFACE_SUFFIX and direction are omitted\n        const interfaceName = prop.name\n            .slice(0, -1 * (DYNAMIC_INTERFACE_SUFFIX.length + 2 + direction.length));\n\n        const occupied = { left: [], right: [] };\n\n        const stateIOs = { ...this.inputs, ...this.outputs };\n\n        // Assigning sides and sides Positions to interfaces\n        Object.entries(stateIOs).forEach(([ioName, ioState]) => {\n            if (ioName.startsWith('property_')) return;\n            occupied[ioState.side].push(ioState.sidePosition);\n        });\n\n        for (let i = 0; i < value; i += 1) {\n            const ioName = `${interfaceName}[${i}]`;\n            const directionIoName = `${direction}_${ioName}`;\n\n            const intf = {\n                name: ioName,\n                direction,\n            };\n\n            const container = direction === 'output' ? this.outputs : this.inputs;\n\n            if (directionIoName in container) {\n                intf.externalName = container[directionIoName].externalName;\n                intf.side = container[directionIoName].side;\n                intf.sidePosition = container[directionIoName].sidePosition;\n            }\n\n            if (\n                !Object.prototype.hasOwnProperty.call(intf, 'sidePosition') &&\n                !Object.prototype.hasOwnProperty.call(intf, 'side')\n            ) {\n                const side = direction === 'output' ? 'right' : 'left';\n                let firstUnoccupied = occupied[side].sort((a, b) => a - b).findIndex(\n                    (sidePosition, index) => sidePosition !== index,\n                );\n\n                if (firstUnoccupied === -1) {\n                    if (occupied[side].length === 0) {\n                        firstUnoccupied = 0;\n                    } else {\n                        firstUnoccupied = Math.max(...occupied[side]) + 1;\n                    }\n                }\n\n                intf.sidePosition = firstUnoccupied;\n                intf.side = side;\n                intf.type = interfaceType;\n                intf.maxConnectionCount = interfaceMaxConnectionsCount;\n\n                occupied[intf.side].push(firstUnoccupied);\n            }\n\n            interfaces.push(intf);\n        }\n\n        // Remove extra interfaces if value of the property gets decreased.\n        const container = direction === 'output' ? this.outputs : this.inputs;\n        Object.keys(container).forEach((key) => {\n            if (!key.startsWith(`${direction}_${interfaceName}[`)) {\n                return;\n            }\n\n            const match = key.match(/\\[(\\d+)\\]$/);\n            if (!match) {\n                return;\n            }\n\n            const idx = parseInt(match[1], 10);\n            if (idx < value) {\n                return;\n            }\n\n            if (direction === 'output') {\n                this.removeOutput(key);\n            } else {\n                this.removeInput(key);\n            }\n        });\n\n        const out = parseInterfaces(interfaces, [], []);\n        if (Array.isArray(out) && out.length) {\n            throw new Error(`Internal error, node ${this.type} invalid. Reason: ${out.join(' ')}`);\n        }\n        const { inputs: newInputs, outputs: newOutputs } = out;\n\n        // Add new interfaces if they do not exist.\n        Object.entries(direction === 'output' ? newOutputs : newInputs).forEach(([key, intf]) => {\n            if ((key in container)) {\n                return;\n            }\n\n            const baklavaIntf = new NodeInterface(key);\n            Object.assign(baklavaIntf, intf);\n            if (direction === 'output') {\n                this.addOutput(key, baklavaIntf);\n            } else {\n                this.addInput(key, baklavaIntf);\n            }\n        });\n\n        // Finding a reactive reference of `this` and using it to bind\n        // the function to the node instance, so that the changes are\n        // reflected in the editor\n        const node = this.graph.nodes.find((n) => n.id === this.id);\n        const reactiveUpdate = this.updateInterfaces.bind(node);\n        reactiveUpdate(newInputs, newOutputs, false, [`${direction}_${interfaceName}`]);\n    }\n\n    toggleInterfaceGroup(intf, visible) {\n        // If the interface is visible and is being disabled\n\n        if (!intf.hidden && !visible) {\n            const connections = this.graphInstance.connections.filter(\n                (c) => c.from === intf || c.to === intf,\n            );\n            connections.forEach((c) => {\n                this.graphInstance.removeConnection(c);\n            });\n        }\n\n        // checking if there is an interface with the same side position\n        if (visible) {\n            updateInterfacePosition(this, intf, intf.side);\n        }\n        // It may also need a new sidePosition\n        intf.hidden = !visible; // eslint-disable-line no-param-reassign\n    }\n\n    save() {\n        const savedState = super.save();\n        const newProperties = [];\n        const newInterfaces = [];\n        const enabledInterfaceGroups = [];\n\n        Object.entries({ ...this.inputs, ...this.outputs }).forEach((io) => {\n            const [ioName, ioState] = io;\n\n            if (ioState.port) {\n                if (!ioState.hidden) {\n                    if (ioState.interfaces) {\n                        // Enabled interface groups\n                        enabledInterfaceGroups.push({\n                            name: ioName.slice(ioState.direction.length + 1),\n                            direction: ioState.direction,\n                        });\n                    }\n\n                    newInterfaces.push({\n                        name: ioName.slice(ioState.direction.length + 1),\n                        externalName: ioState.externalName,\n                        id: ioState.id,\n                        direction: ioState.direction,\n                        side: ioState.side,\n                        sidePosition: ioState.sidePosition,\n                    });\n                }\n            } else {\n                newProperties.push({\n                    name: ioName.slice('property'.length + 1),\n                    id: ioState.id,\n                    value: ioState.value === undefined ? null : ioState.value,\n                });\n            }\n        });\n\n        delete savedState.inputs;\n        delete savedState.outputs;\n        savedState.interfaces = newInterfaces;\n        savedState.properties = newProperties;\n        savedState.enabledInterfaceGroups = enabledInterfaceGroups;\n        savedState.relatedGraphs = this.relatedGraphs;\n\n        savedState.name = savedState.type;\n        delete savedState.type;\n\n        savedState.instanceName = savedState.title === '' ? undefined : savedState.title;\n        delete savedState.title;\n\n        return savedState;\n    }\n\n    /**\n     * Function used to update interfaces of a node when loading a dataflow\n     * in a development mode.\n     *\n     * @param {object} stateInputs newInputs of the node\n     * @param {object} stateOutputs newOutputs of the node\n     * @param {boolean} updateInterfaces determines what to do if an interface in either\n     * @param {string[]} include prefixes of names of interfaces that are to be removed. Other\n     * interfaces are left untouched. If set to undefined then all interfaces are updated.\n     * `stateInputs` or `stateOutputs` already exists in the node. If set to `true`, the\n     * interface will be updated with the new values, otherwise it will be left untouched.\n     */\n    updateInterfaces(stateInputs, stateOutputs, updateInterfaces = true, include = undefined) {\n        const errors = [];\n        // Updating interfaces of a graph node\n        Object.entries(this.inputs).forEach(([k, intf]) => {\n            // Process only interfaces, not properties\n            if (intf.direction === undefined) return;\n            if (\n                !Object.keys(stateInputs).includes(k) &&\n                (include === undefined || include.some((prefix) => k.startsWith(prefix)))\n            ) {\n                errors.push(\n                    `Interface '${intf.name}' of direction '${intf.direction}' ` +\n                    `removed as it was not found in the dataflow.`,\n                );\n\n                // The interface might have to be privatzed\n                this.graph.editor.privatizeInterface(this.graph.id, intf);\n\n                this.removeInput(k);\n            }\n        });\n        Object.entries(stateInputs).forEach(([idA, intfA]) => {\n            if (intfA.direction === undefined) return;\n            const foundIntf = Object.entries(this.inputs).find(\n                ([idB, intfB]) => idB === idA && intfB.direction === intfA.direction,\n            );\n            if (foundIntf === undefined) {\n                const baklavaIntf = new NodeInterface(idA);\n                errors.push(\n                    `Interface '${intfA.name}' of direction '${intfA.direction}' ` +\n                    `created as it was not found in the specification.`,\n                );\n                Object.assign(baklavaIntf, intfA);\n                this.addInterface(baklavaIntf.direction, idA, baklavaIntf);\n            } else if (updateInterfaces) {\n                Object.assign(foundIntf[1], intfA);\n            }\n        });\n\n        Object.entries(this.outputs).forEach(([k, intf]) => {\n            // Process only interfaces, not properties\n            if (intf.direction === undefined) return;\n            if (!Object.keys(stateOutputs).includes(k) &&\n                (include === undefined || include.some((prefix) => k.startsWith(prefix)))\n            ) {\n                errors.push(\n                    `Interface '${intf.name}' of direction '${intf.direction}' ` +\n                    `removed as it was not found in the dataflow.`,\n                );\n\n                // The interface might have to be privatzed\n                this.graph.editor.privatizeInterface(this.graph.id, intf);\n\n                this.removeOutput(k);\n            }\n        });\n        Object.entries(stateOutputs).forEach(([idA, intfA]) => {\n            const foundIntf = Object.entries(this.outputs).find(\n                ([idB, intfB]) => idB === idA && intfB.direction === intfA.direction,\n            );\n            if (foundIntf === undefined) {\n                const baklavaIntf = new NodeInterface(idA);\n                errors.push(\n                    `Interface '${intfA.name}' of direction '${intfA.direction}' ` +\n                    `created as it was not found in the specification.`,\n                );\n                Object.assign(baklavaIntf, intfA);\n                this.addInterface(baklavaIntf.direction, idA, baklavaIntf);\n            } else if (updateInterfaces) {\n                Object.assign(foundIntf[1], intfA);\n            }\n        });\n        return errors;\n    }\n\n    updateProperties(stateProperties) {\n        const errors = [];\n        // Updating properties of a graph node\n        Object.entries(this.inputs).forEach(([k, prop]) => {\n            // Process only properties, not interfaces\n            if (prop.direction !== undefined) return;\n            if (!Object.keys(stateProperties).includes(k)) {\n                errors.push(\n                    `Property '${prop.name}' ` +\n                    `removed as it was not found in the dataflow.`,\n                );\n                this.removeInput(k);\n            }\n        });\n        Object.entries(stateProperties).forEach(([idA, propA]) => {\n            if (propA.direction !== undefined) return;\n            const foundProp = Object.entries(this.inputs).find(\n                ([idB]) => idB === idA,\n            );\n            if (foundProp === undefined) {\n                const baklavaProp = new InputInterface(\n                    propA.name,\n                    propA.value,\n                );\n                errors.push(\n                    `Property '${propA.name}' ` +\n                    `created as it was not found in the specification.`,\n                );\n                Object.assign(baklavaProp, propA);\n                this.addInput(idA, baklavaProp);\n            }\n        });\n        return errors;\n    }\n\n    load(state) {\n        let parsedState;\n\n        // `parsed` determines whether the state was already parsed before loading\n        // This is caused by the fact that `load` can be used both to load a state\n        // from a dataflow and from an instance of a node\n        if (Object.prototype.hasOwnProperty.call(state, 'parsed') && state.parsed) {\n            parsedState = state;\n        } else {\n            parsedState = parseNodeState(state);\n\n            if (Array.isArray(parsedState) && parsedState.length) {\n                return parsedState.map((error) => `Node ${this.type} of id: ${this.id} invalid. ${error}`);\n            }\n        }\n\n        let isWebpack = true;\n        try {\n            isWebpack = window.isWebpack;\n        } catch {\n            isWebpack = false;\n        }\n\n        let errors = [];\n        if (!isWebpack && process.env.VUE_APP_GRAPH_DEVELOPMENT_MODE === 'true') {\n            errors = this.updateInterfaces(parsedState.inputs, parsedState.outputs);\n            errors = [...errors, ...this.updateProperties(parsedState.inputs)];\n            errors = errors.map((error) => `Node ${this.type} of id: ${this.id} invalid. ${error}`);\n        } else {\n            Object.entries(parsedState.inputs).forEach(([name, intf]) => {\n                if (!name.startsWith('property_')) return;\n\n                if (name.startsWith('property_') && name.endsWith(`${DYNAMIC_INTERFACE_SUFFIX}`)) {\n                    this.updateDynamicInterfaces(intf);\n                }\n            });\n\n            errors = detectDiscrepancies(parsedState, this.inputs, this.outputs);\n            if (Array.isArray(errors) && errors.length) {\n                return errors.map((error) => `Node ${this.type} of id: ${this.id} invalid. ${error}`);\n            }\n        }\n\n        super.load(parsedState);\n\n        // Disabling default interface groups if the node has its own state\n        if (Object.keys(parsedState.enabledInterfaceGroups).length) {\n            Object.entries({ ...this.inputs, ...this.outputs }).forEach(([, intf]) => {\n                // If this is an interfaces group\n                if (intf.interfaces !== undefined) {\n                    intf.hidden = true; // eslint-disable-line no-param-reassign\n                }\n            });\n        }\n\n        // Enabling interface groups\n        Object.entries(parsedState.enabledInterfaceGroups).forEach(\n            ([groupName, groupState]) => {\n                if (groupState.direction === 'input' || groupState.direction === 'inout') {\n                    this.inputs[groupName].hidden = false;\n                } else if (groupState.direction === 'output') {\n                    this.outputs[groupName].hidden = false;\n                }\n            },\n        );\n\n        const occupied = { left: [], right: [] };\n\n        const stateios = { ...parsedState.inputs, ...parsedState.outputs };\n\n        // Assigning sides and sides Positions to interfaces\n        Object.entries(stateios).forEach(([ioName, ioState]) => {\n            if (ioState.direction === 'input' || ioState.direction === 'inout') {\n                if (!(ioName in this.inputs)) {\n                    const baklavaIntf = new NodeInterface(ioName);\n                    Object.assign(baklavaIntf, ioState);\n                    this.addInput(ioName, baklavaIntf);\n                }\n                this.inputs[ioName].side = ioState.side;\n                this.inputs[ioName].sidePosition = ioState.sidePosition;\n                this.inputs[ioName].externalName = ioState.externalName;\n                this.inputs[ioName].direction = ioState.direction;\n                occupied[ioState.side].push(ioState.sidePosition);\n            } else if (ioState.direction === 'output') {\n                if (!(ioName in this.outputs)) {\n                    const baklavaIntf = new NodeInterface(ioName);\n                    Object.assign(baklavaIntf, ioState);\n                    this.addOutput(ioName, baklavaIntf);\n                }\n                this.outputs[ioName].side = ioState.side;\n                this.outputs[ioName].sidePosition = ioState.sidePosition;\n                this.outputs[ioName].externalName = ioState.externalName;\n                this.outputs[ioName].direction = ioState.direction;\n                occupied[ioState.side].push(ioState.sidePosition);\n            }\n        });\n\n        const refreshSidePositions = (entries) => {\n            // When state provided in the graph is incomplete, e.g. it misses\n            // an interface, we allow it.\n            // This, however, requires from us that we make sure that newly added\n            // interfaces (not present in parsedState) are not on conflicting positions\n            Object.entries(entries).forEach(([ioName, ioState]) => {\n                if (ioName.startsWith('property_')) return;\n                // if interface was explicitly defined in the graph file, skip it\n                if (ioName in stateios) return;\n                // otherwise, if the interface was implicitly created but it does not\n                // cover existing interface, skip it\n                if (!occupied[ioState.side].includes(ioState.sidePosition)) return;\n                // if the positions are clashing, pick first available max position on\n                // given side\n                const maxposition = Math.max(...occupied[ioState.side]);\n                ioState.sidePosition = maxposition + 1; // eslint-disable-line no-param-reassign\n                occupied[ioState.side].push(maxposition + 1);\n            });\n        };\n\n        refreshSidePositions(this.inputs);\n        refreshSidePositions(this.outputs);\n\n        // Default position should be undefined instead of (0, 0) so that it can be set\n        // by autolayout\n        if (state.position === undefined) {\n            this.position = undefined;\n        }\n\n        this.relatedGraphs = state.relatedGraphs;\n        return errors;\n    }\n\n    onPlaced() {\n        super.onPlaced();\n        const externalRequest = ([method, params]) => this.graphInstance\n            ?.editor\n            ?.editorManager\n            ?.externalApplicationManager\n            ?.request(method, params);\n        Object.entries(this.inputs)\n            .filter(([name, _]) => name.startsWith('property_'))\n            .filter(([_, intf]) => intf.componentName === 'ButtonInterface')\n            .forEach(([_, intf]) => intf.events.updated.subscribe(this, externalRequest));\n    }\n\n    onDestroy() {\n        [...Object.values(this.inputs), ...Object.values(this.outputs)].forEach((io) => {\n            Object.values(io.events).forEach((event) => {\n                // We need to unsubscribe from all events to avoid memory leaks\n                // On token mismatch, the event will not be unsubscribed\n                event.unsubscribe(this);\n                event.unsubscribe(io);\n            });\n        });\n    }\n}\n\n/**\n * @param parsedInterfaces that are validated and parsed. The format\n * should be the same as the one returned by parseInterfaces.\n * @returns created interfaces\n */\nexport const createBaklavaInterfaces = (parsedInterfaces) => {\n    function createBaklavaInterface(intf) {\n        return () => {\n            const baklavaIntf = new NodeInterface(intf.name);\n            Object.assign(baklavaIntf, intf);\n            return baklavaIntf;\n        };\n    }\n\n    // Creating interfaces for baklavajs\n    const inputs = Object.fromEntries(\n        Object.entries(parsedInterfaces.inputs).map(\n            ([n, intf]) => [n, createBaklavaInterface(intf)],\n        ),\n    );\n\n    const outputs = Object.fromEntries(\n        Object.entries(parsedInterfaces.outputs).map(\n            ([n, intf]) => [n, createBaklavaInterface(intf)],\n        ),\n    );\n\n    return [inputs, outputs];\n};\n\n/**\n * Class factory that creates a class for a custom Node that is described by the arguments.\n * It can be later registered so that the user can use it and save the editor.\n * `inputs`, `properties` and `outputs` formats are described in the documentation.\n *\n * @param {string} name Name of the block that is stored when saving\n * @param {string} layer Layer of the node\n * @param {*} interfaces List of interfaces in the block (input, output and inout)\n * @param {*} properties List of properties of the block\n * @param {*} interfaceGroups Object describing groups of interfaces\n * @param {*} defaultInterfaceGroups Object describing groups of interfaces that\n * are enabled by default\n * @param {boolean} twoColumn type of layout of the nodes\n * @returns Node based class is successful, otherwise an array of errors is returned.\n */\nexport function CustomNodeFactory(\n    name,\n    layer,\n    interfaces,\n    properties,\n    interfaceGroups,\n    defaultInterfaceGroups,\n    twoColumn,\n    description = '',\n    nodeExtends = [],\n    nodeExtending = [],\n    nodeSiblings = [],\n    width = 300,\n) {\n    const generatedProperties = generateProperties(interfaces);\n    if (!generatedProperties.success) {\n        return generatedProperties.value.map((error) => `Node ${name} invalid. ${error}`);\n    }\n\n    const parsedInterfaces = parseInterfaces(interfaces, interfaceGroups, defaultInterfaceGroups);\n    // If parsedInterfaces returns an array, it is an array of errors\n    if (Array.isArray(parsedInterfaces) && parsedInterfaces.length) {\n        return parsedInterfaces.map((error) => `Node ${name} invalid. ${error}`);\n    }\n    const [inputs, newOutputs] = createBaklavaInterfaces(parsedInterfaces);\n\n    const parsedProperties = parseProperties([...properties, ...generatedProperties.value]);\n    // If parsedProperties returns an array, it is an array of errors\n    if (Array.isArray(parsedProperties) && parsedProperties.length) {\n        return parsedProperties.map((error) => `Node ${name} invalid. ${error}`);\n    }\n    const createdProperties = createProperties(parsedProperties);\n\n    const newInputs = {\n        ...inputs,\n        ...createdProperties,\n    };\n\n    return class extends CustomNode {\n        constructor() {\n            super(\n                name,\n                layer,\n                newInputs,\n                newOutputs,\n                twoColumn,\n                description,\n                nodeExtends,\n                nodeExtending,\n                nodeSiblings,\n                width,\n            );\n        }\n    };\n}\n\n/**\n * Function looks for graph node interfaces based on the nodes inside of it.\n *\n * It finds all interfaces that have `externalName` property set and registers\n * them in the InterfaceRegistry, if they are not already registered, so that\n * they their state can be easily shared and synchronized.\n *\n * If there are any errors, they are returned as an array of strings.\n * If the operation was successful, the new inputs and outputs are returned.\n *\n * @param nodes Nodes of the subgraph\n * @param inputs List of inputs of the subgraph\n * @param outputs List of outputs of the subgraph\n *\n * @returns List of errors or new inputs and outputs\n */\nexport function updateSubgraphInterfaces(nodes, inputs = [], outputs = []) {\n    // Interfaces that are not connected to any other interface\n    const INTERFACE_PREFIXES = ['input_', 'inout_', 'output_'];\n\n    const exposedIntf = [\n        ...nodes.map((node) => Object.entries({ ...node.inputs, ...node.outputs })).flat(),\n    ].filter(([key]) => INTERFACE_PREFIXES.some((prefix) => key.startsWith(prefix)))\n        .filter(\n            ([, intf]) => intf.externalName,\n        );\n\n    // Filter out repeated external names\n    const countedIntfNames = Object.create(null);\n    const externalInterfaces = [];\n    exposedIntf.forEach(\n        ([, intf]) => {\n            countedIntfNames[intf.externalName] = (countedIntfNames[intf.externalName] ?? 0) + 1;\n            if (countedIntfNames[intf.externalName] === 1) {\n                externalInterfaces.push(intf);\n            } else {\n                externalInterfaces.push(`Interface '${intf.externalName}' is repeated ${countedIntfNames[intf.externalName]} times.`);\n            }\n        },\n    );\n    const errorMessages = externalInterfaces.filter((n) => typeof n === 'string');\n    if (errorMessages.length) {\n        return errorMessages;\n    }\n\n    // Create new inputs and outputs\n    const newInterfaces = [];\n    externalInterfaces.forEach((intf) => {\n        const graphId = nodes[0].graph.id;\n        // It may happen that the registered interface has the same id, but is a reference,\n        // for example when dealing with history or clipboard.\n        if (\n            ir.isRegistered(intf.id) &&\n            ir.getRegisteredInterface(intf.id).sharedInterface !== intf &&\n            ir.getRegisteredInterface(intf.id).sharedInterface.id === intf.id &&\n            ir.getRegisteredInterface(intf.id).sharedInterfaceGraphId === graphId\n        ) {\n            ir.deleteRegisteredInterface(intf.id);\n        }\n\n        if (!ir.isRegistered(intf.id)) {\n            ir.registerInterface(intf, graphId);\n        }\n\n        const container = intf.direction === 'output' ? outputs : inputs;\n        const idx = container.findIndex((x) => x.id === intf.id);\n        if (idx === -1) {\n            // Graph node interface should not inherit some properties that\n            // are node-specific, they will be accessed using InterfaceRegistry\n            newInterfaces.push({\n                name: intf.externalName,\n                id: intf.id,\n                externalName: undefined,\n                side: intf.side,\n                direction: intf.direction,\n                sidePosition: undefined,\n            });\n        } else {\n            container[idx].name = intf.externalName;\n            newInterfaces.push(container[idx]);\n        }\n    });\n\n    const newInterfacesPositionsOrErrors = applySidePositions(newInterfaces, {});\n    if (Array.isArray(newInterfacesPositionsOrErrors) && newInterfacesPositionsOrErrors.length) {\n        return newInterfacesPositionsOrErrors;\n    }\n\n    return {\n        inputs: Object.values(newInterfacesPositionsOrErrors.inputs),\n        outputs: Object.values(newInterfacesPositionsOrErrors.outputs),\n    };\n}\n\n/**\n * Function creating a graph template as defined in specification\n *\n * @param nodes Nodes of the subgraph\n * @param connections Connections inside the subgraph\n * @param name Default name that will be displayed in editor\n * @param editor PipelineManagerEditor instance\n * @returns Graph template that will be used to define the subgraph node\n */\nexport function GraphFactory(nodes, connections, name, editor) {\n    const parsedState = nodes.map((node) => parseNodeState(node));\n    const errorMessages = parsedState.filter((n) => typeof n === 'string');\n    if (errorMessages.length) {\n        return errorMessages;\n    }\n\n    const state = {\n        name,\n        nodes: parsedState,\n        connections,\n        inputs: [],\n        outputs: [],\n    };\n\n    return new GraphTemplate(state, editor);\n}\n","/*\n * Copyright (c) 2025 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { reactive } from 'vue';\n/**\n * Configuration state for the configuration menu.\n * This state is reactive and can be accessed and modified from any component.\n * It is used to control the visibility of the configuration menu and its options.\n */\nexport const menuState = reactive({\n    configurationMenu: {\n        visible: false,\n        addNode: false,\n        placeNode: false,\n    },\n    propertyMenu: false,\n    interfaceMenu: false,\n    propertyListMenu: false,\n    interfaceListMenu: false,\n    layerMenu: false,\n});\n/**\n * Configuration state for the node data.\n * It is used to store the node data that is being configured.\n */\nexport const configurationState = reactive({\n    nodeData: {\n        name: 'Custom Node',\n        category: 'Default category',\n        layer: '',\n        description: '',\n        color: '',\n    },\n    properties: [],\n    interfaces: [],\n    success: false,\n});\n","/*\n * Copyright (c) 2022-2023 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n *\n */\n\nimport cytoscape from 'cytoscape';\nimport cola from 'cytoscape-cola';\nimport dagre from 'cytoscape-dagre';\n\nimport BaseLayoutEngine from './baseEngine.js';\n\ncytoscape.use(dagre);\ncytoscape.use(cola);\n\nexport default class CytoscapeLayoutEngine extends BaseLayoutEngine {\n    // The only cytoscape algorithm not defined here are 'null' (every node to\n    // (0, 0)) and 'preset' (every node to user defined position)\n    availableAlgorithms = [\n        'cola',\n        'dagre-network-simplex',\n        'dagre-tight-tree',\n        'dagre-longest-path',\n        'random',\n        'grid',\n        'circle',\n        'concentric',\n        'breadthfirst',\n        'cose',\n    ];\n\n    async calculate(graph) {\n        const cytoscapeGraph = cytoscape({\n            elements: {\n                nodes: graph.nodes.map((node) => ({\n                    data: { id: node.id, width: node.width, height: node.height },\n                })),\n                edges: graph.connections.map((connection) => ({\n                    data: { id: connection.id, source: connection.from, target: connection.to },\n                })),\n            },\n            style: [\n                {\n                    selector: 'node',\n                    style: {\n                        shape: 'rectangle',\n                        width: 'data(width)',\n                        height: 'data(height)',\n                    },\n                },\n            ],\n            styleEnabled: true,\n        });\n\n        const options = { name: this.activeAlgorithm };\n        /* eslint-disable no-unused-vars */\n        switch (this.activeAlgorithm) {\n            case 'random':\n                options.boundingBox = {\n                    x1: 0,\n                    y1: 0,\n                    w: 2000,\n                    h: 2000,\n                };\n                break;\n            case 'grid':\n                options.avoidOverlapPadding = 150;\n                break;\n            case 'cose':\n                options.nodeOverlap = 1000;\n                options.idealEdgeLength = (edge) => 300;\n                break;\n            case 'cola':\n                options.nodeSpacing = (node) => 150;\n                break;\n            case 'dagre-network-simplex':\n            case 'dagre-tight-tree':\n            case 'dagre-longest-path': {\n                const [name, ...ranker] = this.activeAlgorithm.split('-');\n                options.nodeSep = 50;\n                options.rankSep = 100;\n                options.ranker = ranker.join('-');\n                options.name = name;\n                break;\n            }\n            default:\n                break;\n        }\n        /* eslint-enable no-unused-vars */\n\n        const layout = cytoscapeGraph.layout(options);\n        layout.run();\n        if (['cose', 'cola'].includes(this.activeAlgorithm)) {\n            // wait until asynchronous algorithm finish calculations\n            await layout.promiseOn('layoutstop');\n        }\n        return {\n            ...graph,\n            nodes: cytoscapeGraph.nodes().map((node) => ({\n                id: node.id(),\n                // node.position defines the center of node but graph representation\n                // required coordinates of top left corner\n                position: {\n                    x: node.position().x - node.width() / 2,\n                    y: node.position().y - node.height() / 2,\n                },\n            })),\n        };\n    }\n}\n","/*\n * Copyright (c) 2022-2024 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\nconst defaultDirection = 'inout';\n\n/**\n * Dynamic interfaces that are controlled with a dedicated property\n * are suffixed with `DYNAMIC_INTERFACE_SUFFIX`.\n*/\nexport const DYNAMIC_INTERFACE_SUFFIX = 'count';\n\n/**\n * Returns a prepared interface that is passed to baklava constructor\n *\n * @param io configuration of the interface\n * @param hidden whether th interface should be hidden. For example groups of interfaces\n * are hidden by default\n * @param {*} name custom name for the interface that should be used instead of the one coming\n * from `io`\n * @returns baklava interface constructor\n */\nfunction createInterface(io, hidden, name = undefined) {\n    const intf = {};\n    Object.assign(intf, io);\n\n    intf.name = name ?? io.name;\n    if (intf.type !== undefined) {\n        intf.type = typeof io.type === 'string' || io.type instanceof String ? [io.type] : io.type;\n    }\n    intf.componentName = 'NodeInterface';\n    intf.hidden = hidden;\n\n    // Readonly values used for detecting whether there were any changes to the interface\n    intf.originalSide = intf.side;\n    intf.originalSidePosition = intf.sidePosition;\n    return intf;\n}\n\n/**\n * Parses and validates interfaces passed in specification\n *\n * @param interfaces list of interfaces from specification that is going to be parsed\n * @param interfaceGroup determines whether `interfaces` are interface groups. If true the\n * additionally field `.interfaces` is parsed.\n * @returns parsed interfaces that can be passed to baklavajs if the interfaces were valid.\n * Otherwise an array of errors is returned.\n */\nfunction parseSingleInterfaces(interfaces, interfaceGroup = false) {\n    const errors = [];\n    const tempParsed = {\n        input: {},\n        inout: {},\n        output: {},\n    };\n\n    interfaces.forEach((io) => {\n        // Omitting interfaces that are marked as dynamic, as they are generated\n        // using 'updateDynamicInterfaces function\n        if (Object.prototype.hasOwnProperty.call(io, 'dynamic')) return;\n\n        // Copy the interface to avoid modifying the original object\n        const tempIO = JSON.parse(JSON.stringify(io));\n\n        const direction = io.direction ?? defaultDirection;\n        tempIO.direction = direction;\n\n        if (io.array !== undefined) {\n            const [left, right] = io.array;\n\n            for (let j = left; j < right; j += 1) {\n                const name = `${io.name}[${j}]`;\n\n                if (tempParsed[direction][name] !== undefined) {\n                    errors.push(\n                        `Interface named '${name}' of direction '${direction}' is a duplicate.`,\n                    );\n                }\n                tempIO.externalName = io.externalName ? `${io.externalName}[${j}]` : undefined;\n\n                // Copy the interface to avoid modifying the assigned object\n                tempParsed[direction][name] = JSON.parse(JSON.stringify(tempIO));\n            }\n        } else {\n            if (tempParsed[direction][io.name] !== undefined) {\n                errors.push(\n                    `Interface named '${io.name}' of direction '${direction}' is a duplicate.`,\n                );\n            }\n\n            tempParsed[direction][io.name] = tempIO;\n        }\n\n        if (interfaceGroup) {\n            const newInterfaces = [];\n\n            tempIO.interfaces.forEach((buildingIO) => {\n                const bdirection = buildingIO.direction ?? defaultDirection;\n                if (buildingIO.array !== undefined) {\n                    const [left, right] = buildingIO.array;\n\n                    for (let j = left; j < right; j += 1) {\n                        const name = `${bdirection}_${buildingIO.name}[${j}]`;\n                        newInterfaces.push(name);\n                    }\n                } else {\n                    const name = `${bdirection}_${buildingIO.name}`;\n                    newInterfaces.push(name);\n                }\n            });\n            tempIO.interfaces = newInterfaces; // eslint-disable-line no-param-reassign\n        }\n    });\n\n    // Removing inout with duplicate names\n    const filteredTempInouts = Object.fromEntries(\n        Object.entries(tempParsed.inout).filter(([name, state]) => {\n            const direction = state.direction ?? defaultDirection;\n            const duplicate =\n                Object.keys(tempParsed.output).includes(name) ||\n                Object.keys(tempParsed.input).includes(name);\n            if (duplicate) {\n                errors.push(\n                    `Interface named '${name}' of direction '${direction}' ` +\n                        `is a duplicate. There already exists an input or output of this name.`,\n                );\n            }\n            return !duplicate;\n        }),\n    );\n\n    tempParsed.inout = filteredTempInouts;\n    tempParsed.input = { ...tempParsed.input, ...tempParsed.inout };\n    delete tempParsed.inout;\n\n    tempParsed.input = Object.fromEntries(\n        Object.entries(tempParsed.input).map(([name, state]) => [\n            `${state.direction}_${name}`,\n            state,\n        ]),\n    );\n    tempParsed.output = Object.fromEntries(\n        Object.entries(tempParsed.output).map(([name, state]) => [\n            `${state.direction}_${name}`,\n            state,\n        ]),\n    );\n\n    if (errors.length) {\n        return errors;\n    }\n\n    return tempParsed;\n}\n\n/**\n * Checks whether interface groups that are in enabledInterfaceGroup\n * can be enabled at the same time\n * @param {array} enabledInterfaceGroups array of names of enabled interface groups\n * @param {*} inputs inputs of the node\n * @param {*} outputs outputs of the node\n * @returns list tuples that have information about conflicting interfaces.\n */\nexport function validateInterfaceGroupsNames(enabledInterfaceGroups, inputs, outputs) {\n    const errors = [];\n    // Checking for integrity of interface groups\n    const usedInterfaces = new Set();\n\n    enabledInterfaceGroups.forEach((name) => {\n        const interfaces = inputs[name]?.interfaces ?? outputs[name]?.interfaces;\n        const groupDirection = name.slice(0, name.indexOf('_'));\n        const groupName = name.slice(name.indexOf('_') + 1);\n\n        interfaces.forEach((intfName) => {\n            if (usedInterfaces.has(intfName)) {\n                const intfDirection = intfName.slice(0, intfName.indexOf('_'));\n                const parsedIntfName = intfName.slice(intfName.indexOf('_') + 1);\n\n                errors.push([parsedIntfName, intfDirection, groupName, groupDirection]);\n            } else {\n                usedInterfaces.add(intfName);\n            }\n        });\n    });\n    return errors;\n}\n\n/**\n * Checks whether interface groups that are in enabledInterfaceGroup\n * can be enabled at the same time\n * @param {array} enabledInterfaceGroups array of names of enabled interface groups\n * @param {*} inputs inputs of the node\n * @param {*} outputs outputs of the node\n * @returns list of explicit errors.\n */\nexport function validateInterfaceGroups(enabledInterfaceGroups, inputs, outputs) {\n    const errors = validateInterfaceGroupsNames(enabledInterfaceGroups, inputs, outputs);\n    const errorMessages = [];\n\n    errors.forEach(([parsedIntfName, intfDirection, groupName, groupDirection]) => {\n        errorMessages.push(\n            `Interface of name '${parsedIntfName}' and direction '${intfDirection}' has been reused ` +\n                `by interface group named '${groupName}' of direction '${groupDirection}'. ` +\n                `Make sure your interface groups are disjoint.`,\n        );\n    });\n\n    return errorMessages;\n}\n\n/**\n *\n * @param {*} inputs inputs of the node\n * @param {*} outputs outputs of the node\n * @returns inputs and outputs of the nodes with `sidePositions` assigned if\n * there were no errors found. Otherwise a list of errors is returned.\n */\nexport function applySidePositions(inputs, outputs) {\n    const tempParsedSides = {\n        left: {},\n        right: {},\n    };\n\n    const errors = [];\n\n    // Dividing interfaces into left and right sides\n    Object.entries({ ...inputs, ...outputs }).forEach(([name, intf]) => {\n        if (intf.side === 'right' || (intf.side === undefined && intf.direction === 'output')) {\n            tempParsedSides.right[name] = { ...intf };\n            tempParsedSides.right[name].side = 'right';\n        } else if (intf.side === 'left' || (intf.side === undefined && intf.direction !== 'output')) {\n            tempParsedSides.left[name] = { ...intf };\n            tempParsedSides.left[name].side = 'left';\n        }\n    });\n\n    const stripName = (name) => name.slice(name.indexOf('_') + 1);\n\n    // validating and setting sidePositions\n    const occupiedInputSidePositions = new Set();\n    const occupiedOutputSidePositions = new Set();\n\n    Object.entries(tempParsedSides.left).forEach(([name, intf]) => {\n        if (intf.sidePosition !== undefined) {\n            if (occupiedInputSidePositions.has(intf.sidePosition)) {\n                errors.push(\n                    `Interface named '${stripName(name)}' of direction '${intf.direction}' has ` +\n                        `invalid sidePosition value '${intf.sidePosition}'. ` +\n                        `There already exists an input or output with this sidePosition.`,\n                );\n            }\n            occupiedInputSidePositions.add(intf.sidePosition);\n        }\n    });\n\n    Object.entries(tempParsedSides.right).forEach(([name, intf]) => {\n        if (intf.sidePosition !== undefined) {\n            if (occupiedOutputSidePositions.has(intf.sidePosition)) {\n                errors.push(\n                    `Interface named '${stripName(name)}' of direction '${intf.direction}' has ` +\n                        `invalid sidePosition value '${intf.sidePosition}'. ` +\n                        `There already exists an input or output with this sidePosition.`,\n                );\n            }\n            occupiedOutputSidePositions.add(intf.sidePosition);\n        }\n    });\n\n    if (errors.length) {\n        return errors;\n    }\n\n    let leftSidePositionIndex = 0;\n    let rightSidePositionIndex = 0;\n\n    const getLeftSidePos = (intf) => {\n        if (intf.sidePosition === undefined) {\n            while (occupiedInputSidePositions.has(leftSidePositionIndex)) {\n                leftSidePositionIndex += 1;\n            }\n            occupiedInputSidePositions.add(leftSidePositionIndex);\n            return leftSidePositionIndex;\n        }\n        return intf.sidePosition;\n    };\n\n    const getRightSidePos = (intf) => {\n        if (intf.sidePosition === undefined) {\n            while (occupiedOutputSidePositions.has(rightSidePositionIndex)) {\n                rightSidePositionIndex += 1;\n            }\n            occupiedOutputSidePositions.add(rightSidePositionIndex);\n            return rightSidePositionIndex;\n        }\n        return intf.sidePosition;\n    };\n\n    Object.entries(tempParsedSides.left).forEach(([, intf]) => {\n        intf.sidePosition = getLeftSidePos(intf); // eslint-disable-line no-param-reassign,max-len\n    });\n\n    Object.entries(tempParsedSides.right).forEach(([, intf]) => {\n        intf.sidePosition = getRightSidePos(intf); // eslint-disable-line no-param-reassign,max-len\n    });\n\n    return {\n        inputs: Object.fromEntries(\n            Object.entries({ ...tempParsedSides.left, ...tempParsedSides.right })\n                .filter(([, intf]) => intf.direction !== 'output'),\n        ),\n        outputs: Object.fromEntries(\n            Object.entries({ ...tempParsedSides.left, ...tempParsedSides.right })\n                .filter(([, intf]) => intf.direction === 'output'),\n        ),\n    };\n}\n\n/**\n * The function reads provided `parsedInterfaces` and looks for interfaces with `dynamic` attribute.\n * For such interfaces, a dedicated property is created that controls the number interface\n * instances. The properties are returned and should be included in node creation.\n *\n * @param {Object} interfaces List of interfaces.\n * @return Object with two properties, success and value. If success is true, value contains\n * an array of properties that should be included in the node. Otherwise, value contains an array\n * of errors.\n */\nexport function generateProperties(interfaces) {\n    const errors = [];\n    const properties = [];\n    interfaces.forEach(\n        (intf) => {\n            if (Object.prototype.hasOwnProperty.call(intf, 'dynamic')) {\n                if (\n                    Array.isArray(intf.dynamic) &&\n                    intf.dynamic.length === 2 &&\n                    Number.isInteger(intf.dynamic[0]) &&\n                    Number.isInteger(intf.dynamic[1])\n                ) {\n                    // Property should have limits specified by 'intf.dynamic' value\n                    properties.push({\n                        name: `${intf.name} ${intf.direction} ${DYNAMIC_INTERFACE_SUFFIX}`,\n                        type: 'integer',\n                        min: intf.dynamic[0],\n                        max: intf.dynamic[1],\n                        default: intf.dynamic[0],\n                        // The type of dynamic interfaces is stored as `interfaceType`\n                        interfaceType: intf.type,\n                        interfaceMaxConnectionCount: intf.maxConnectionCount,\n                    });\n                } else if (intf.dynamic === true) {\n                    // Property should not have limits\n                    properties.push({\n                        name: `${intf.name} ${intf.direction} ${DYNAMIC_INTERFACE_SUFFIX}`,\n                        type: 'integer',\n                        min: 0,\n                        default: 0,\n                        // The type of dynamic interfaces is stored as `interfaceType`\n                        interfaceType: intf.type,\n                        interfaceMaxConnectionCount: intf.maxConnectionCount,\n                    });\n                } else {\n                    errors.push(\n                        `Interface '${intf.name}' has invalid 'dynamic' attribute. ` +\n                        'It should be either a boolean or an array with two integer elements.',\n                    );\n                }\n            }\n        },\n    );\n\n    if (errors.length) {\n        return { success: false, value: errors };\n    }\n    return { success: true, value: properties };\n}\n\n/**\n * @param {*} interfaces List of interfaces in the block (input, output and inout)\n * @param {*} interfaceGroups Object describing groups of interfaces'\n * @param {*} defaultInterfaceGroups Object describing groups of interfaces that are enabled\n * @returns object that has inputs and outputs key if parsing was successful,\n * a list of errors otherwise.\n */\nexport function parseInterfaces(\n    interfaces,\n    interfaceGroups,\n    defaultInterfaceGroups,\n) {\n    let errors = [];\n\n    // Parsing single interfaces first\n    const tempParsed = parseSingleInterfaces(interfaces);\n\n    // If parseSingleInterfaces returns an array, it is an array of errors\n    if (Array.isArray(tempParsed) && tempParsed.length) {\n        return tempParsed;\n    }\n\n    // Checking for integrity of interface groups\n    interfaceGroups.forEach((intfG) => {\n        const directionG = intfG.direction ?? defaultDirection;\n        intfG.interfaces.forEach((intf) => {\n            const direction = intf.direction ?? defaultDirection;\n            if (intf.array !== undefined) {\n                const [left, right] = intf.array;\n\n                for (let j = left; j < right; j += 1) {\n                    const name = `${direction}_${intf.name}[${j}]`;\n                    if (\n                        !Object.keys({ ...tempParsed.input, ...tempParsed.output }).includes(name)\n                    ) {\n                        errors.push(\n                            `Interface named '${intf.name}[${j}]' of direction '${direction}' ` +\n                                `used for interface group '${intfG.name}' of direction ` +\n                                `'${directionG}' does not exist.`,\n                        );\n                    }\n                }\n            } else {\n                const name = `${direction}_${intf.name}`;\n                if (!Object.keys({ ...tempParsed.input, ...tempParsed.output }).includes(name)) {\n                    errors.push(\n                        `Interface named '${intf.name}' of direction '${direction}' ` +\n                            `used for interface group '${intfG.name}' of direction ` +\n                            `'${directionG}' does not exist.`,\n                    );\n                }\n            }\n        });\n    });\n\n    if (errors.length) {\n        return errors;\n    }\n\n    const tempParsedGroups = parseSingleInterfaces(interfaceGroups, true);\n    // If parseSingleInterfaces returns an array, it is an array of errors\n    if (Array.isArray(tempParsedGroups) && tempParsedGroups.length) {\n        return tempParsedGroups;\n    }\n\n    // All interfaces that create some interfaces groups\n    const interfacesCreatingGroups = new Set();\n    Object.values({\n        ...tempParsedGroups.input,\n        ...tempParsedGroups.output,\n    }).forEach((state) => {\n        state.interfaces.forEach((intf) => interfacesCreatingGroups.add(intf));\n    });\n\n    // Detecting integrity of enabled interface groups\n    const enabledInterfaceGroupsNames = defaultInterfaceGroups.map(\n        (group) => `${group.direction ?? defaultDirection}_${group.name}`,\n    );\n\n    errors = validateInterfaceGroups(\n        enabledInterfaceGroupsNames,\n        { ...tempParsedGroups.input, ...tempParsed.input },\n        { ...tempParsedGroups.output, ...tempParsed.output },\n    );\n\n    if (errors.length) {\n        return errors;\n    }\n\n    // Interfaces that belong to groups are removed as they should not have side\n    // positions applied as they are never rendered\n    tempParsed.input = Object.fromEntries(Object.entries(tempParsed.input).filter(\n        ([name]) => !interfacesCreatingGroups.has(name),\n    ));\n\n    tempParsed.output = Object.fromEntries(Object.entries(tempParsed.output).filter(\n        ([name]) => !interfacesCreatingGroups.has(name),\n    ));\n\n    const parsedSides = applySidePositions(\n        { ...tempParsed.input, ...tempParsedGroups.input },\n        { ...tempParsed.output, ...tempParsedGroups.output },\n    );\n    if (Array.isArray(parsedSides) && parsedSides.length) {\n        return parsedSides;\n    }\n\n    const stripName = (name) => name.slice(name.indexOf('_') + 1);\n\n    const createdInterfaces = {\n        inputs: {},\n        outputs: {},\n    };\n\n    // Filtering single interfaces that are part of interface groups\n    // Those interfaces are removed as they are never rendered\n    // This is only used when parsing a specification format\n    Object.entries(parsedSides.inputs).forEach(([name, intf]) => {\n        // It is an interface group\n        if (intf.interfaces !== undefined) {\n            // Adding interfaces groups, hidden by default\n            createdInterfaces.inputs[name] = createInterface(\n                intf,\n                !enabledInterfaceGroupsNames.includes(name),\n                stripName(name),\n            );\n        } else {\n            createdInterfaces.inputs[name] = createInterface(\n                intf,\n                false,\n                stripName(name),\n            );\n        }\n    });\n\n    Object.entries(parsedSides.outputs).forEach(([name, intf]) => {\n        // It is an interface group\n        if (intf.interfaces !== undefined) {\n            // Adding interfaces groups, hidden by default\n            createdInterfaces.outputs[name] = createInterface(\n                intf,\n                !enabledInterfaceGroupsNames.includes(name),\n                stripName(name),\n            );\n        } else {\n            createdInterfaces.outputs[name] = createInterface(\n                intf,\n                false,\n                stripName(name),\n            );\n        }\n    });\n\n    return createdInterfaces;\n}\n","/*\n * Copyright (c) 2024 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Class used to store the current specification and unresolved specification\n * of the current session.\n *\n * This class should be used as a singleton and should be accessed using the\n * getInstance() function.\n */\nexport default class Specification {\n    static instance = undefined;\n\n    currentSpecification = undefined;\n\n    includedSpecification = undefined;\n\n    unresolvedSpecification = undefined;\n\n    constructor() {\n        if (Specification.instance !== undefined) {\n            throw new Error('Error - use Specification.getInstance()');\n        }\n    }\n\n    /**\n     * Static function used to get the instance of the Specification in a singleton manner.\n     * If there is no existing instance of the Specification then a new one is created.\n     *\n     * @returns Instance of Specification.\n     */\n    static getInstance() {\n        if (!Specification.instance) {\n            Specification.instance = new Specification();\n        }\n        return Specification.instance;\n    }\n\n    /**\n     * Searches the current specification for a node with the given name.\n     *\n     * @param nodeName name of the node that is to be found in the specification\n     * @returns the specification of the node if it exists, otherwise undefined\n     */\n    getNodeSpecification(nodeName) {\n        if (this.currentSpecification === undefined) return undefined;\n\n        return this.currentSpecification.nodes.find(\n            (n) => n.name === nodeName,\n        );\n    }\n}\n","/*\n * Copyright (c) 2022-2023 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { BaseLayoutAlgorithm } from './baseEngine.js';\n\n/**\n * Default layout algorithm that puts all nodes into (0, 0) position\n */\nexport default class NoLayoutAlgorithm extends BaseLayoutAlgorithm {\n    /* eslint-disable class-methods-use-this */\n    availableAlgorithms = [\n        'NoLayout',\n    ];\n\n    activeAlgorithm = 'NoLayout';\n\n    calculate(graph) {\n        const nodes = graph.nodes.map((node) => ({\n            ...node,\n            position: { x: 0, y: 0 },\n        }));\n        return { ...graph, nodes };\n    }\n}\n","/*\n * Copyright (c) 2022-2024 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n/* eslint-disable import/prefer-default-export */\nconst getBackendApiUrl = () => {\n    // Override backend URL if requested\n    const urlParams = new URLSearchParams(window.location.search);\n    const url = urlParams.get('backend');\n    if (url !== null)\n        return url;\n    if (window.location.protocol === 'file:' ||\n        (process.env.VUE_APP_STATIC !== undefined && process.env.VUE_APP_STATIC === 'true'))\n        return null;\n    if (process.env.VUE_APP_COMMUNICATION_SERVER_HOST !== undefined &&\n        process.env.VUE_APP_COMMUNICATION_SERVER_PORT !== undefined)\n        return `http://${process.env.VUE_APP_COMMUNICATION_SERVER_HOST}:${process.env.VUE_APP_COMMUNICATION_SERVER_PORT}`;\n    // npm run serve\n    if (process.env.NODE_ENV === 'development')\n        return null;\n    return `${window.location.protocol}//${window.location.host}`;\n};\nexport const backendApiUrl = getBackendApiUrl();\nexport const HTTPCodes = {\n    OK: 200,\n    BadRequest: 400,\n    ServiceUnavailable: 503,\n};\nexport const PMMessageType = {\n    OK: 0,\n    ERROR: 1,\n    PROGRESS: 2,\n    WARNING: 3,\n};\nexport const JSONRPCCustomErrorCode = {\n    EXCEPTION_RAISED: -1,\n    EXTERNAL_APPLICATION_NOT_CONNECTED: -2,\n    NEWER_SESSION_AVAILABLE: -3,\n};\n","/*\n * Copyright (c) 2022-2024 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { reactive } from 'vue';\n\nconst storageAvailable = (() => {\n    try {\n        const randomKey = Math.random().toString(36);\n        const randomValue = Math.random().toString(36);\n        localStorage.setItem(randomKey, randomValue);\n        localStorage.removeItem(randomKey);\n        return true;\n    } catch {\n        return false;\n    }\n})();\n\nconst pmStorage = new Map();\nconst get = (key) => {\n    if (storageAvailable) return localStorage.getItem(key);\n    return pmStorage.get(key) ?? null;\n};\n\nconst set = (key, value) => {\n    if (storageAvailable) localStorage.setItem(key, value);\n    else pmStorage.set(key, value);\n};\n\nconst remove = (key) => {\n    if (storageAvailable) localStorage.removeItem(key);\n    else pmStorage.delete(key);\n};\n\n/* eslint-disable import/prefer-default-export */\nexport const notificationStore = reactive({\n    notifications: JSON.parse(get('notifications')) || [],\n    add(notification) {\n        this.notifications.push(notification);\n\n        set('notifications', JSON.stringify(this.notifications));\n    },\n\n    remove() {\n        remove('notifications');\n        this.notifications = [];\n    },\n\n    removeOne(index) {\n        const newNotifications = this.notifications.filter((_, idx) => index !== idx);\n\n        set('notifications', JSON.stringify(newNotifications));\n        this.notifications = newNotifications;\n    },\n});\n\nexport const MAIN_TERMINAL = 'Terminal';\n\nexport const terminalStore = reactive({\n    // Object\n    logs: {\n        Terminal: JSON.parse(get(`logs`)) || [],\n    },\n    readOnly: {\n        Terminal: true,\n    },\n    add(log, instance = MAIN_TERMINAL) {\n        this.logs[instance].push(log);\n\n        // Update localStorage only for the main terminal\n        if (instance === MAIN_TERMINAL) {\n            set(`logs`, JSON.stringify(this.logs[instance]));\n        }\n    },\n    isReadOnly(instance = MAIN_TERMINAL) {\n        return this.readOnly[instance];\n    },\n\n    /**\n     * Adds a parsed notification. If there are messages, then it returns a following message:\n     *\n     * Title:\n     *     message_first_line\n     *     message_second_line\n     *     ...\n     *     message_last_line\n     *\n     * Otherwise, if messages are empty, then it returns a following message:\n     *\n     * Title.\n     *\n     * @param {string} title title of the message\n     * @param {Array[string] | string | undefined} messages messages of the message\n     */\n    addParsed(title, messages, instance = MAIN_TERMINAL) {\n        let parsedMessage = title;\n        if (messages) {\n            if (typeof messages === 'string' || messages instanceof String) {\n                messages = [messages]; // eslint-disable-line no-param-reassign\n            }\n            parsedMessage += ':';\n\n            messages.forEach((message) => {\n                parsedMessage += '\\n';\n                parsedMessage += '    ';\n                parsedMessage += message;\n            });\n        } else {\n            parsedMessage += '.';\n        }\n        this.add(parsedMessage, instance);\n    },\n\n    clear(instance = MAIN_TERMINAL) {\n        if (instance === MAIN_TERMINAL) {\n            remove(`logs`);\n        }\n        this.logs[instance] = [];\n    },\n\n    remove(instance = MAIN_TERMINAL) {\n        this.clear(instance);\n        delete this.logs[instance];\n        delete this.readOnly[instance];\n    },\n\n    exists(name = MAIN_TERMINAL) {\n        return name in this.logs;\n    },\n\n    getInstances() {\n        return Object.keys(this.logs);\n    },\n\n    /**\n     * Creates a new terminal instance.\n     * If such terminal already exisists, then false is returned.\n     *\n     * @param {string} Unique name of the terminal instance to be created.\n     * @param {boolean} If true, then the terminal instance will be only for read.\n     * @returns returns true if terminal was created, false otherwise.\n     */\n    createTerminalInstance(name, readOnly = true) {\n        if (Object.keys(this.logs).includes(name)) return false;\n\n        this.logs[name] = [];\n        this.readOnly[name] = readOnly;\n        return true;\n    },\n\n    show: false,\n\n    /**\n    * @type {import('./communication/utils').TerminalManager|null}\n    */\n    manager: null,\n});\n","/*\n * Copyright (c) 2025 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n *\n * Methods responsible for handling the configuration of custom nodes.\n * It allows to create, modify and to add properties and interfaces to the custom node.\n *\n * The current metadata of the custom node can be accessed in ConfigurationState.ts\n * and the current configuration can be accessed in the configurationState reactive object.\n*/\nimport { useViewModel } from '@baklavajs/renderer-vue';\nimport EditorManager, { NEW_NODE_STYLE, EDITED_NODE_STYLE } from '../EditorManager.js';\nimport { parseInterfaces } from '../interfaceParser.js';\nimport { configurationState, } from './ConfigurationState.ts';\nimport { createProperties, parseProperties, createBaklavaInterfaces } from '../NodeFactory.js';\nimport NotificationHandler from '../notifications.js';\nimport { suppressHistoryLogging } from '../History.ts';\n/**\n  * Updates editor specification for the edited node type.\n*/\nfunction commitTypeToSpecification() {\n    suppressHistoryLogging(true);\n    const editorManager = EditorManager.getEditorManagerInstance();\n    const newNodeData = configurationState.nodeData;\n    const currentType = configurationState.editedType;\n    let style = NEW_NODE_STYLE;\n    if (currentType !== undefined) {\n        // eslint-disable-next-line no-underscore-dangle\n        const errors = editorManager._unregisterNodeType(currentType);\n        if (errors.length) {\n            NotificationHandler.terminalLog('error', 'Error when registering the node', errors);\n            return;\n        }\n        style = EDITED_NODE_STYLE;\n    }\n    const ret = editorManager.addNodeToEditorSpecification({\n        name: newNodeData.name,\n        layer: newNodeData.layer,\n        category: newNodeData.category,\n        color: newNodeData.color,\n        description: newNodeData.description,\n        interfaces: configurationState.interfaces,\n        properties: configurationState.properties,\n        style,\n    }, currentType, false);\n    if (ret.errors !== undefined && ret.errors.length) {\n        NotificationHandler.terminalLog('error', 'Error when registering the node', ret.errors);\n        return;\n    }\n    suppressHistoryLogging(false);\n}\n/**\n  * Finds all nodes of a given type in all editor graphs.\n  * @param nodeType - type of the node to find\n  * @param extending - find extending nodes\n  * @returns any[] - an array of nodes\n*/\nexport function findNodes(nodeType, extending = false) {\n    const { viewModel } = useViewModel();\n    const { editor } = viewModel.value;\n    const allNodes = Array.from(editor.graphs).map((graph) => graph.nodes).flat();\n    if (extending)\n        return allNodes.filter((n) => { var _a; return (_a = n.extends) === null || _a === void 0 ? void 0 : _a.includes(nodeType); });\n    return allNodes.filter((n) => n.type === nodeType);\n}\n/**\n  * Creates a new node based on the current configuration.\n  * It first validates the configuration and if it is correct, it adjusts the existing nodes\n  * to the new configuration and creates a new node if `configurationMenu.addNode`\n  * is set to true. If the configuration is incorrect, it logs an error.\n  * @returns string[] - an array of errors that occurred during node creation\n*/\nexport function createNode() {\n    const editorManager = EditorManager.getEditorManagerInstance();\n    const newNodeData = configurationState.nodeData;\n    const currentType = configurationState.editedType;\n    // Checking if there is there already exists newNodeData.name type and is different\n    // than the current node that is being created\n    if (editorManager.baklavaView.editor.nodeTypes.has(newNodeData.name) && (currentType === undefined ||\n        currentType !== newNodeData.name)) {\n        const errors = [`Node of type ${newNodeData.name} already exists. Please pick another type`];\n        NotificationHandler.terminalLog('error', 'Error when creating a node', errors);\n        return errors;\n    }\n    commitTypeToSpecification();\n    return [];\n}\n/**\n  * Modifies the configuration of the custom node.\n  * It first validates the configuration and if it is correct, it adjusts the existing nodes\n  * to the new configuration. If the configuration is incorrect, it logs an error.\n  * @returns string[] - an array of errors that occurred during the modification\n*/\nexport function modifyConfiguration() {\n    suppressHistoryLogging(true);\n    const newNodeData = configurationState.nodeData;\n    const currentType = configurationState.editedType;\n    const nodes = findNodes(currentType);\n    /* eslint-disable no-param-reassign */\n    nodes.forEach((node) => {\n        if (node.type === node.title) {\n            node.title = newNodeData.name;\n        }\n        else {\n            node.highlightedType = newNodeData.name;\n        }\n        node.type = newNodeData.name;\n        node.layer = newNodeData.layer;\n        node.category = newNodeData.category;\n        node.color = newNodeData.color;\n        node.description = newNodeData.description;\n    });\n    /* eslint-enable no-param-reassign */\n    commitTypeToSpecification();\n    suppressHistoryLogging(false);\n    return [];\n}\n/**\n  * Adds or removes node properties.\n  * @param nodes - list of nodes\n  * @param properties - list of properties\n  * @param remove - whether properties should be removed\n  * @returns void\n*/\nexport function alterProperties(nodes, properties, remove = false) {\n    if (properties === undefined)\n        return [];\n    const parsedProperties = parseProperties(properties);\n    // If parsedProperties returns an array, it is an array of errors\n    if (Array.isArray(parsedProperties) && parsedProperties.length) {\n        return parsedProperties;\n    }\n    const createdProperties = createProperties(parsedProperties);\n    nodes.forEach((node) => {\n        const state = node.save();\n        Object.keys(createdProperties).forEach((k) => {\n            const input = createdProperties[k]();\n            if (remove) {\n                node.removeInput(k, input);\n            }\n            else {\n                node.addInput(k, input);\n            }\n            // Because `this` is not reactive in node functions, we need\n            // to notice the reactive `node` reference inputs were updated\n            node.inputs = node.inputs; // eslint-disable-line no-self-assign, no-param-reassign\n        });\n        node.load(state);\n    });\n    return [];\n}\n/**\n  * Adds or removes node interfaces.\n  * @param nodes - list of nodes\n  * @param interfaces - list of interfaces\n  * @param remove - whether interfaces should be removed\n  * @returns void\n*/\nexport function alterInterfaces(nodes, interfaces, remove = false) {\n    if (interfaces === undefined)\n        return [];\n    const parsedInterfaces = parseInterfaces(interfaces, [], []);\n    // If parsedInterfaces returns an array, it is an array of errors\n    if (Array.isArray(parsedInterfaces) && parsedInterfaces.length) {\n        return parsedInterfaces;\n    }\n    const [inputs, outputs] = createBaklavaInterfaces(parsedInterfaces);\n    nodes.forEach((node) => {\n        const state = node.save();\n        Object.keys(inputs).forEach((k) => {\n            const input = inputs[k]();\n            if (remove) {\n                node.removeInput(k, input);\n            }\n            else {\n                node.addInput(k, input);\n            }\n            node.inputs = node.inputs; // eslint-disable-line no-self-assign, no-param-reassign\n        });\n        Object.keys(outputs).forEach((k) => {\n            const output = outputs[k]();\n            if (remove) {\n                node.removeOutput(k, output);\n            }\n            else {\n                node.addOutput(k, output);\n            }\n            node.outputs = node.outputs; // eslint-disable-line no-self-assign, no-param-reassign, max-len\n        });\n        node.load(state);\n    });\n    return [];\n}\n/**\n  * Adds property to the custom node. If the property is invalid, it logs an error.\n  * @param property - the property to be added\n  * @returns void\n*/\nexport function addProperty(property) {\n    var _a;\n    const currentType = configurationState.editedType;\n    const editorManager = EditorManager.getEditorManagerInstance();\n    let error = editorManager.validateNodeProperty(property);\n    if (error.length) {\n        NotificationHandler.terminalLog('error', 'Invalid property', error);\n        return;\n    }\n    const nodes = findNodes(currentType);\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    if (nodes === undefined) {\n        NotificationHandler.terminalLog('error', 'Node not found', `Node of type ${currentType} not found`);\n        return;\n    }\n    configurationState.properties.push(property);\n    error = alterProperties(nodes, configurationState.properties);\n    if (error.length) {\n        NotificationHandler.terminalLog('error', 'Invalid property', error);\n        return;\n    }\n    const resolvedChildNodes = (_a = editorManager.specification.currentSpecification.nodes\n        .filter((n) => { var _a; return (_a = n.extends) === null || _a === void 0 ? void 0 : _a.includes(currentType); })) !== null && _a !== void 0 ? _a : [];\n    resolvedChildNodes.forEach((n) => {\n        var _a;\n        // eslint-disable-next-line no-param-reassign\n        n.properties = [...((_a = n.properties) !== null && _a !== void 0 ? _a : []), ...[property]];\n        const childNodes = findNodes(n.name);\n        alterProperties(childNodes, [property]);\n    });\n    commitTypeToSpecification();\n}\n/**\n  * Removes properties from the custom node.\n  * @param properties - the properties to be removed\n  * @returns void\n*/\nexport function removeProperties(properties) {\n    var _a;\n    const currentType = configurationState.editedType;\n    const editorManager = EditorManager.getEditorManagerInstance();\n    const nodes = findNodes(currentType);\n    if (nodes === undefined) {\n        NotificationHandler.terminalLog('error', 'Node not found', `Node of type ${currentType} not found`);\n        return;\n    }\n    configurationState.properties = configurationState.properties.filter((item) => !properties.includes(item));\n    alterProperties(nodes, properties, true);\n    const resolvedChildNodes = (_a = editorManager.specification.currentSpecification.nodes\n        .filter((n) => { var _a; return (_a = n.extends) === null || _a === void 0 ? void 0 : _a.includes(currentType); })) !== null && _a !== void 0 ? _a : [];\n    resolvedChildNodes.forEach((n) => {\n        var _a, _b;\n        // eslint-disable-next-line no-param-reassign\n        n.properties = (_b = (_a = n.properties) === null || _a === void 0 ? void 0 : _a.filter((prop) => !properties.some((p) => p.name === prop.name))) !== null && _b !== void 0 ? _b : [];\n        const childNodes = findNodes(n.name);\n        alterProperties(childNodes, properties, true);\n    });\n    commitTypeToSpecification();\n}\n/**\n  * Adds interface to the custom node. If the interface is invalid, it logs an error.\n  * @param intf - the interface to be added\n  * @returns void\n*/\nexport function addInterface(intf) {\n    var _a;\n    const currentType = configurationState.editedType;\n    const editorManager = EditorManager.getEditorManagerInstance();\n    let error = editorManager.validateNodeInterface(intf);\n    if (error.length) {\n        NotificationHandler.terminalLog('error', 'Invalid interface', error);\n        return;\n    }\n    const nodes = findNodes(currentType);\n    if (nodes === undefined) {\n        NotificationHandler.terminalLog('error', 'Node not found', `Node of type ${currentType} not found`);\n        return;\n    }\n    configurationState.interfaces.push(intf);\n    error = alterInterfaces(nodes, configurationState.interfaces);\n    if (error.length) {\n        NotificationHandler.terminalLog('error', 'Invalid interface', error);\n        return;\n    }\n    const resolvedChildNodes = (_a = editorManager.specification.currentSpecification.nodes\n        .filter((n) => { var _a; return (_a = n.extends) === null || _a === void 0 ? void 0 : _a.includes(currentType); })) !== null && _a !== void 0 ? _a : [];\n    resolvedChildNodes.forEach((n) => {\n        var _a;\n        // eslint-disable-next-line no-param-reassign\n        n.interfaces = [...((_a = n.interfaces) !== null && _a !== void 0 ? _a : []), ...[intf]];\n        const childNodes = findNodes(n.name);\n        alterInterfaces(childNodes, [intf]);\n    });\n    commitTypeToSpecification();\n}\n/**\n  * Removes interfaces from the custom node.\n  * @param interfaces - the interfaces to be removed\n  * @returns void\n*/\nexport function removeInterfaces(interfaces) {\n    var _a;\n    const currentType = configurationState.editedType;\n    const editorManager = EditorManager.getEditorManagerInstance();\n    const nodes = findNodes(currentType);\n    if (nodes === undefined) {\n        NotificationHandler.terminalLog('error', 'Node not found', `Node of type ${currentType} not found`);\n        return;\n    }\n    configurationState.interfaces = configurationState.interfaces.filter((item) => !interfaces.includes(item));\n    alterInterfaces(nodes, interfaces, true);\n    const resolvedChildNodes = (_a = editorManager.specification.currentSpecification.nodes\n        .filter((n) => { var _a; return (_a = n.extends) === null || _a === void 0 ? void 0 : _a.includes(currentType); })) !== null && _a !== void 0 ? _a : [];\n    resolvedChildNodes.forEach((n) => {\n        var _a, _b;\n        // eslint-disable-next-line no-param-reassign\n        n.interfaces = (_b = (_a = n.interfaces) === null || _a === void 0 ? void 0 : _a.filter((intf) => !interfaces.some((i) => i.name === intf.name))) !== null && _b !== void 0 ? _b : [];\n        const childNodes = findNodes(n.name);\n        alterInterfaces(childNodes, interfaces, true);\n    });\n    commitTypeToSpecification();\n}\n","/*\n * Copyright (c) 2022-2023 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/* eslint-disable max-classes-per-file */\n/**\n * Base class allowing to define autolayout algorithms. Each engine\n * can specify multiple algorithms, names in `availableAlgorithms` array.\n * Currently chosen algorithm is named in `activeAlgorithm`\n */\nexport default class BaseLayoutEngine {\n    availableAlgorithms = [];\n\n    // Base layout is an abstract class\n    constructor() {\n        if (this.constructor === BaseLayoutEngine) {\n            throw new Error(\"Can't initialize base class instance\"); // eslint-disable-line quotes\n        }\n    }\n\n    chooseAlgorithm(algorithm) {\n        if (!this.availableAlgorithms.includes(algorithm)) {\n            throw new Error(\n                `Could not find ${algorithm} in ${this.constructor.name} engine.\n                Available algorithms: ${this.availableAlgorithms}`,\n            );\n        }\n        this.activeAlgorithm = algorithm;\n    }\n\n    /* eslint-disable class-methods-use-this */\n    /* eslint-disable no-unused-vars */\n    async calculate(graph) {\n        throw new Error('Method calculate() must be implemented by layout engine');\n    }\n}\n\n/**\n * Instance of engine with only single algorithm\n */\nexport class BaseLayoutAlgorithm extends BaseLayoutEngine {\n    constructor() {\n        super();\n        this.availableAlgorithms = [this.constructor.name];\n        this.activeAlgorithm = this.constructor.name;\n        this.chooseAlgorithm = undefined; // turn of choosing algorithm\n        if (this.constructor === BaseLayoutAlgorithm) {\n            throw new Error(\"Can't initialize base class instance\"); // eslint-disable-line quotes\n        }\n    }\n}\n","/*\n * Copyright (c) 2022-2024 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Helper function that can be used to handle double clicks.\n *\n * @param {number} timer time window in which a callback can be fired\n * @param {function} callback event fired on double click\n * @returns event that should be applied to @pointerdown\n */\nexport default function doubleClick(timer, callback) {\n    const doubleClickTimer = timer;\n    let lastClickTime = -doubleClickTimer;\n\n    /* eslint-disable vue/no-mutating-props,no-param-reassign */\n    const onMouseDown = (ev) => {\n        if (Date.now() - lastClickTime < doubleClickTimer) {\n            callback(ev);\n        }\n        lastClickTime = Date.now();\n    };\n\n    return onMouseDown;\n}\n","/*\n * Copyright (c) 2022-2023 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { useGraph } from '@baklavajs/renderer-vue';\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Function for calculating node position based on given movementStep.\n *\n * @param movementStep Vue's reference to value containing snap offset\n */\nexport function gridSnapper(movementStep) {\n    const calculateSnappedPosition = (coord) => Math.round(coord / movementStep.value) * movementStep.value;\n    return calculateSnappedPosition;\n}\n/**\n * Creates function that aligns the value of node position along specified axis if it is close\n * enough to other node position\n *\n * @param kind Either 'x' or 'y', defines along which axis the coordinate is aligned\n */\nexport function nodeSnapper(kind) {\n    const { graph } = useGraph();\n    const snapDistance = 100;\n    const calculateSnappedPosition = (coord, nodeId, selectedNodesIds) => {\n        const nearestCoords = graph.value.nodes\n            // any definition is an ad-hoc solution as we don't have our node definition\n            .filter((node) => node.id !== nodeId && !selectedNodesIds.includes(node.id))\n            .map((node) => node.position[kind])\n            .filter((otherCoords) => Math.abs(coord - otherCoords) < snapDistance);\n        return nearestCoords.length !== 0 ? Math.min(...nearestCoords) : undefined;\n    };\n    return calculateSnappedPosition;\n}\n","import { terminalStore } from '../stores';\nexport function checkTerminalExistence(name, exists = true) {\n    if (terminalStore.exists(name) !== exists) {\n        const message = `Terminal instance of name '${name} ${exists ? 'does not exist' : 'already exists'}`;\n        throw new Error(message);\n    }\n}\n","/*\n * Copyright (c) 2022-2024 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __awaiter } from \"tslib\";\n/*\n * This module contains all possible JSON-RPC requests that frontend can\n * receive and process.\n *\n * Each exported function is automatically registered as JSON-RPC method\n * when JSON-RPC server is created in fetchRequest.\n * Function name have to match with specification (resources/api_specification).\n */\nimport { useViewModel } from '@baklavajs/renderer-vue';\nimport runInfo from './runInformation';\nimport EditorManager from '../EditorManager';\nimport NotificationHandler from '../notifications';\nimport { MAIN_TERMINAL, terminalStore } from '../stores';\n// eslint-disable-next-line import/no-cycle\nimport getExternalApplicationManager from './ExternalApplicationManager';\nimport { checkTerminalExistence } from './utils';\n/* eslint-disable import/prefer-default-export */\n/* eslint-disable camelcase */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst editorManager = EditorManager.getEditorManagerInstance();\n/**\n * Finds graph of id `graph_id`.\n * An error with appropriate message is thrown if any error occurs.\n *\n * @param graph_id Id of a graph to find\n * @returns found graph\n */\nfunction getGraph(graph_id) {\n    const { viewModel } = useViewModel();\n    const graph = [...viewModel.value.editor.graphs].find((g) => g.id === graph_id);\n    if (graph === undefined) {\n        throw new Error(`Graph with id '${graph_id}' does not exist.`);\n    }\n    return graph;\n}\n/**\n * Finds node of id `node_id` in graph of id `graph_id`.\n * An error with appropriate message is thrown if any error occurs.\n *\n * @param graph_id Id of a graph to find\n * @param node_id Id of a node to find\n * @returns found node\n */\nfunction getNode(graph_id, node_id) {\n    const graph = getGraph(graph_id);\n    const node = graph.nodes.find((n) => n.id === node_id);\n    if (node === undefined) {\n        throw new Error(`Node with id '${node_id}' does not exist.`);\n    }\n    return node;\n}\n/**\n * Finds property of id `id` or name `name` in node.\n * One of those values has to be defined.\n * An error with appropriate message is thrown if any error occurs.\n *\n * @param node Node instance that is searched\n * @param id id of the property\n * @param name name of the property\n * @returns found property\n */\nfunction getProperty(node, id, name) {\n    let prop;\n    if (id !== undefined) {\n        prop = Object.values(node.inputs).find((p) => p.id === id);\n        // If not property found or it is not a property, but an interface\n        if (prop === undefined || prop.side !== undefined) {\n            throw new Error(`Property with id '${id}' does not exist.`);\n        }\n    }\n    else {\n        prop = Object.values(node.inputs).find((p) => p.name === name);\n        // If not property found or it is not a property, but an interface\n        if (prop === undefined || prop.side !== undefined) {\n            throw new Error(`Property with name '${name}' does not exist.`);\n        }\n    }\n    return prop;\n}\n/**\n * Finds connection between interfaces with id `from` and `to` in graph of id `graph_id`.\n * An error with appropriate message is thrown if any error occurs.\n *\n * @param graph_id Id of a graph to find\n * @param from Id of a first interface\n * @param to Id of a second interface\n * @returns found node\n */\nfunction getConnection(graph_id, from, to) {\n    const graph = getGraph(graph_id);\n    const connection = graph.connections.find((c) => c.from.id === from && c.to.id === to);\n    if (connection === undefined) {\n        throw new Error(`Connection from ${from} to ${to} does not exist.`);\n    }\n    return connection;\n}\n/**\n * @returns currently used specification\n */\nexport function frontend_specification_get() {\n    return { specification: editorManager.saveSpecification() };\n}\n/**\n * @returns currently used dataflow\n */\nexport function graph_get() {\n    return {\n        dataflow: editorManager.saveDataflow(),\n    };\n}\n/**\n * Updates values of properties specified in `params`.\n * An error with appropriate message is thrown if any error occurs.\n */\nexport function properties_change(params) {\n    const node = getNode(params.graph_id, params.node_id);\n    // First iteration to validate that every property exists\n    // eslint-disable-next-line no-restricted-syntax\n    for (const property of params.properties) {\n        getProperty(node, property.id, property.name);\n    }\n    // Second iteration to actually alter the values\n    // eslint-disable-next-line no-restricted-syntax\n    for (const property of params.properties) {\n        const prop = getProperty(node, property.id, property.name);\n        prop.value = property.new_value;\n    }\n}\n/**\n * Updates values of properties specified in `params`.\n * An error with appropriate message is thrown if any error occurs.\n */\nexport function position_change(params) {\n    const node = getNode(params.graph_id, params.node_id);\n    node.position.x = params.position.x;\n    node.position.y = params.position.y;\n}\n/**\n * Creates and deletes nodes based on received `params`.\n */\nexport function nodes_change(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const { viewModel } = useViewModel();\n        const graph = getGraph(params.graph_id);\n        params.nodes.added.forEach((n) => {\n            const info = viewModel.value.editor.nodeTypes.get(n.name);\n            if (!info) {\n                throw new Error(`Node type not found for name ${n.name}`);\n            }\n            else {\n                const node = new info.type(); // eslint-disable-line new-cap\n                node.id = n.id;\n                if (n.color) {\n                    const editor = viewModel.value.editor;\n                    editor.setNodeColor(n.id, n.color);\n                }\n                graph.addNode(node);\n                const errors = node.load(n);\n                if (Array.isArray(errors) && errors.length)\n                    throw new Error(errors.join('\\n'));\n            }\n        });\n        params.nodes.deleted.forEach((n) => {\n            var _a;\n            const node = getNode(params.graph_id, n);\n            if ((_a = params.remove_with_connections) !== null && _a !== void 0 ? _a : true) {\n                graph.removeNode(node);\n            }\n            else {\n                graph.removeNodeOnly(node);\n            }\n        });\n    });\n}\n/**\n * Creates and deletes connections based on received `params`.\n */\nexport function connections_change(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const graph = getGraph(params.graph_id);\n        params.connections.added.forEach((c) => {\n            const fromIntf = graph.findNodeInterface(c.from);\n            if (!fromIntf)\n                throw new Error(`Interface with id ${c.from} does not exist`);\n            const toIntf = graph.findNodeInterface(c.to);\n            if (!toIntf)\n                throw new Error(`Interface with id ${c.to} does not exist`);\n            const connection = graph.addConnection(fromIntf, toIntf);\n            if (!connection)\n                throw new Error(`Connection from ${c.from} to ${c.to} cannot be created`);\n        });\n        params.connections.deleted.forEach((c) => {\n            graph.removeConnection(getConnection(params.graph_id, c.from, c.to));\n        });\n    });\n}\n/**\n * Loads received dataflow.\n */\nexport function graph_change(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const externalApplicationManager = getExternalApplicationManager();\n        yield externalApplicationManager.conditionalLoadingScreen(params.loadingScreen, () => __awaiter(this, void 0, void 0, function* () { return externalApplicationManager.updateDataflow(params.dataflow); }));\n    });\n}\n/**\n * Returns an array of properties specified in `params`.\n * An error with appropriate message is thrown if any error occurs.\n */\nexport function properties_get(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const node = getNode(params.graph_id, params.node_id);\n        const properties = [];\n        if (params.properties === undefined) {\n            // eslint-disable-next-line no-restricted-syntax\n            for (const property of Object.values(node.inputs)) {\n                if (property.side === undefined) {\n                    properties.push({\n                        id: property.id,\n                        name: property.name,\n                        value: property.value,\n                    });\n                }\n            }\n            return properties;\n        }\n        // eslint-disable-next-line no-restricted-syntax\n        for (const property of params.properties) {\n            const prop = getProperty(node, property.id, property.name);\n            properties.push({\n                id: prop.id,\n                name: prop.name,\n                value: prop.value,\n            });\n        }\n        return properties;\n    });\n}\n/**\n * Returns a serialized node state specified in `params`.\n * An error with appropriate message is thrown if any error occurs.\n */\nexport function node_get(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const node = getNode(params.graph_id, params.node_id);\n        return {\n            node: node.save(),\n        };\n    });\n}\n/**\n * Sets width of progress bar.\n * If there is not run in progress, throws error.\n */\nexport function progress_change(params) {\n    const procedureInfo = runInfo.get(params.method);\n    if (!procedureInfo.inProgress) {\n        throw new Error('No run in progress');\n    }\n    if (!procedureInfo.progressBar)\n        throw new Error(`Progress bar does not exist for method: ${params.method}`);\n    if (params.progress === -1) {\n        procedureInfo.progressBar.classList.add('animate');\n        return;\n    }\n    if (params.progress > 100 || params.progress < 0)\n        throw new Error(`Progress has to be in [0, 100] or -1. Received: ${params.progress}`);\n    procedureInfo.progressBar.style.width = `${params.progress}%`;\n    procedureInfo.progressBar.classList.remove('animate');\n}\n/**\n * Updates the editor's metadata.\n */\nexport function metadata_change(params) {\n    editorManager.updateMetadata(params.metadata, true);\n}\n/**\n * Triggers action centering the editor.\n */\nexport function viewport_center() {\n    editorManager.baklavaView.editor.centerZoom();\n}\n/**\n * Creates new terminal instance\n */\nexport function terminal_add(params) {\n    const status = terminalStore.createTerminalInstance(params.name, params.readonly);\n    if (status === false) {\n        throw new Error(`Terminal instance of name '${params.name}' already exists`);\n    }\n}\nexport function terminal_remove(params) {\n    checkTerminalExistence(params.name, true);\n    terminalStore.remove(params.name);\n}\n/**\n * Writes a single message to a chosen terminal\n */\nexport function terminal_write(params) {\n    if (!(params.name in terminalStore.logs)) {\n        terminalStore.createTerminalInstance(params.name);\n    }\n    terminalStore.add(params.message, params.name);\n}\nexport function terminal_clear(params) {\n    var _a;\n    const name = (_a = params === null || params === void 0 ? void 0 : params.name) !== null && _a !== void 0 ? _a : MAIN_TERMINAL;\n    checkTerminalExistence(name, true);\n    terminalStore.clear(name);\n}\nexport function terminal_hide() {\n    var _a;\n    (_a = terminalStore.manager) === null || _a === void 0 ? void 0 : _a.hide();\n}\nexport function terminal_show(params) {\n    var _a, _b;\n    const name = (_a = params === null || params === void 0 ? void 0 : params.name) !== null && _a !== void 0 ? _a : MAIN_TERMINAL;\n    if (name !== undefined)\n        checkTerminalExistence(name, true);\n    (_b = terminalStore.manager) === null || _b === void 0 ? void 0 : _b.show(name);\n}\nexport function terminal_view(params) {\n    var _a, _b;\n    (_a = params.names) === null || _a === void 0 ? void 0 : _a.forEach(((name) => checkTerminalExistence(name, true)));\n    (_b = terminalStore.manager) === null || _b === void 0 ? void 0 : _b.view(params);\n}\nexport function terminal_get_instances() {\n    return terminalStore.getInstances();\n}\nexport function notification_send(params) {\n    NotificationHandler.terminalLog(params.type, params.title, params.details);\n}\nexport function specification_change(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const externalApplicationManager = getExternalApplicationManager();\n        yield externalApplicationManager.conditionalLoadingScreen(params.loadingScreen, () => __awaiter(this, void 0, void 0, function* () {\n            return externalApplicationManager.updateSpecification(params.specification, params.urloverrides);\n        }));\n    });\n}\nexport function specification_graph_change(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const externalApplicationManager = getExternalApplicationManager();\n        yield externalApplicationManager.conditionalLoadingScreen(params.loadingScreen, () => __awaiter(this, void 0, void 0, function* () {\n            const error = yield externalApplicationManager.updateSpecification(params.specification, params.urloverrides);\n            if (!error) {\n                yield externalApplicationManager.updateDataflow(params.dataflow);\n            }\n        }));\n    });\n}\n/**\n * Highlights nodes provided in params\n */\nexport function nodes_highlight(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const graph = getGraph(params.graph_id);\n        graph.selectedNodes = graph.selectedNodes.filter((node) => !params.nodes.unselected.includes(node.id));\n        params.nodes.selected.forEach((node_id) => {\n            const node = getNode(params.graph_id, node_id);\n            if (!graph.selectedNodes.includes(node)) {\n                graph.selectedNodes.push(node);\n            }\n        });\n    });\n}\nexport function register_external_frontend() {\n    throw new Error('Frontend registering available only through \"postMessage\" interface.');\n}\n","/*\n * Copyright (c) 2022-2024 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { __awaiter } from \"tslib\";\n// eslint-disable-next-line max-classes-per-file\nimport { JSONRPCServerAndClient, JSONRPCServer, JSONRPCClient, createJSONRPCErrorResponse, } from 'json-rpc-2.0';\nimport Ajv2019 from 'ajv/dist/2019.js';\nimport NotificationHandler from '../notifications';\nimport { PMMessageType } from '../utils';\nimport commonTypesSchema from '../../../../resources/api_specification/common_types.json' with { type: 'json' };\nimport specificationSchema from '../../../../resources/api_specification/specification.json' with { type: 'json' };\n// eslint-disable-next-line import/no-cycle\nimport * as remoteProcedures from './remoteProcedures';\nclass CustomJSONRPCServerAndClient extends JSONRPCServerAndClient {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"customMethodRegex\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: null\n        });\n        Object.defineProperty(this, \"customMethodReplace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: null\n        });\n    }\n}\nconst customMethodRegex = /^custom_.*$/;\nconst customMethodReplace = 'dataflow_run';\nconst ajv = new Ajv2019({\n    schemas: [commonTypesSchema],\n    allowUnionTypes: true,\n    strict: true,\n});\nexport const frontendEndpoints = specificationSchema.frontend_endpoints;\nexport const backendEndpoints = specificationSchema.backend_endpoints;\nexport const externalEndpoints = specificationSchema.external_endpoints;\n// This should become part of the testing suite at some point\nlet invalidDefinition;\ntry {\n    [frontendEndpoints, backendEndpoints, externalEndpoints].forEach((endpoints) => {\n        Object.entries(endpoints).forEach(([definitionName, definition]) => {\n            var _a;\n            invalidDefinition = definitionName;\n            ajv.compile(definition.params);\n            ajv.compile((_a = definition.returns) !== null && _a !== void 0 ? _a : {});\n        });\n    });\n}\ncatch (exception) {\n    throw new Error(`Procedures specification schema '${invalidDefinition}' is incorrect: ${exception}`);\n}\n/**\n * Middleware that validates received requests.\n */\nconst validateServerRequestResponse = (next, request, serverParams) => __awaiter(void 0, void 0, void 0, function* () {\n    var _a;\n    // request validation\n    if (!(request.method in frontendEndpoints)) {\n        if (request.id !== undefined)\n            return createJSONRPCErrorResponse(request.id, 1, 'Requested method does not exist');\n        throw new Error('Requested method does not exist');\n    }\n    const schema = frontendEndpoints[request.method];\n    const valid = ajv.validate(schema.params, (_a = request.params) !== null && _a !== void 0 ? _a : {});\n    if (!valid) {\n        if (request.id !== undefined)\n            return createJSONRPCErrorResponse(request.id, 1, 'Request does not match specification');\n        throw new Error('Request does not match specification');\n    }\n    const response = yield next(request, serverParams);\n    if (request.id === undefined)\n        return null;\n    // response validation\n    if ((response === null || response === void 0 ? void 0 : response.result) !== undefined && schema.returns !== null) {\n        const validResponse = ajv.validate(schema.returns, response.result);\n        if (!validResponse) {\n            if (request.id !== undefined) {\n                return createJSONRPCErrorResponse(request.id, 1, 'Response does not match specification');\n            }\n            throw new Error('Response does not match specification');\n        }\n    }\n    return response;\n});\nlet jsonRPCID = 1;\n// eslint-disable-next-line no-plusplus\nconst createID = () => jsonRPCID++;\nconst requestSchema = new Map();\nlet jsonRPCServer;\nconst validateClientResponse = (response) => {\n    var _a;\n    if (response.result && response.id && ((_a = requestSchema.get(response.id)) === null || _a === void 0 ? void 0 : _a.returns)) {\n        const validResponse = ajv.validate(\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        requestSchema.get(response.id).returns, response.result);\n        if (!validResponse) {\n            return createJSONRPCErrorResponse(response.id, PMMessageType.ERROR, 'Response does not match specification');\n        }\n    }\n    return response;\n};\nclass CustomJSONRPCClient extends JSONRPCClient {\n    receive(responses) {\n        // eslint-disable-next-line no-param-reassign\n        responses = Array.isArray(responses) ? responses : [responses];\n        super.receive(responses.map(validateClientResponse));\n    }\n}\n/**\n * Function that creates JSON-RPC client-server and defines how messages are send and received.\n */\nfunction createServer() {\n    // Create JSON-RPC server\n    jsonRPCServer = new CustomJSONRPCServerAndClient(new JSONRPCServer(), new CustomJSONRPCClient((request_1, _a) => __awaiter(this, [request_1, _a], void 0, function* (request, { externalApp }) {\n        var _b;\n        if (!externalApp) {\n            throw new Error('Missing backend.');\n        }\n        const method = (customMethodRegex.test(request.method)) ?\n            customMethodReplace : request.method;\n        // request validation\n        if (!(method in externalEndpoints) && !(method in backendEndpoints)) {\n            throw new Error('Requested method not known');\n        }\n        const endpoints = (method in externalEndpoints) ?\n            externalEndpoints : backendEndpoints;\n        const schema = endpoints[method];\n        const valid = ajv.validate(schema.params, (_b = request.params) !== null && _b !== void 0 ? _b : {});\n        if (!valid)\n            return Promise.reject(new Error('Request does not match specification'));\n        if (request.id) {\n            requestSchema.set(request.id, schema);\n        }\n        // sending request\n        const endpoint = (endpoints === backendEndpoints) ? 'backend-api' : 'external-api';\n        try {\n            externalApp.request(JSON.parse(JSON.stringify(request)), endpoint);\n        }\n        catch (exception) {\n            return Promise.reject(exception);\n        }\n        return Promise.resolve();\n    }), createID));\n    // Add middlewares\n    jsonRPCServer.server.applyMiddleware(validateServerRequestResponse);\n    // Register JSON-RPC methods\n    Object.entries(remoteProcedures).forEach(([name, func]) => {\n        if (typeof (func) === 'function' && name in frontendEndpoints)\n            jsonRPCServer.addMethod(name, func);\n        else if (typeof (func) === 'function') {\n            NotificationHandler.showToast('warning', `Function ${name} was not registered as RPC method`);\n        }\n    });\n    jsonRPCServer.customMethodRegex = customMethodRegex;\n    jsonRPCServer.customMethodReplace = customMethodReplace;\n}\nconst obj = {\n    get jsonRPC() {\n        if (!jsonRPCServer)\n            createServer();\n        return jsonRPCServer;\n    },\n};\nexport default obj.jsonRPC;\n","/*\n * Copyright (c) 2024 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\nexport class InterfaceRegistry {\n    constructor() {\n        Object.defineProperty(this, \"exposedInterfaces\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n    }\n    /**\n     * Clears the registry.\n     */\n    clearRegistry() {\n        this.exposedInterfaces.clear();\n    }\n    /**\n     * Stores graph id of a shared interface in the registry, so that when\n     * privatizing an interface we can remove it from all the graphs that use it.\n     * If the interface is not registered, an error is thrown.\n     *\n     * @param {string} intfId Id of the interface.\n     * @param {string} graphId Id of a graph that has the registered interface\n     */\n    pushGraphIdToRegistry(intfId, graphId) {\n        const sharedInterface = this.exposedInterfaces.get(intfId);\n        if (!sharedInterface) {\n            throw new Error(`Interface with id ${intfId} not found in the register.`);\n        }\n        sharedInterface.graphIds.push(graphId);\n    }\n    /**\n     * Seamlessly wraps passed `intf`, so that the properties `maxConnectionsCount`,\n     * `connectionCount` and `type` are shared between those two interfaces.\n     *\n     * @param {NodeInterface} intf Interface for which the wrapper is created.\n     */\n    createSharedInterface(intf) {\n        const sharedInterface = this.exposedInterfaces.get(intf.id);\n        if (!sharedInterface) {\n            throw new Error(`'Interface with id ${intf.id} not found in the register.`);\n        }\n        Object.defineProperty(intf, 'maxConnectionsCount', {\n            get() {\n                return sharedInterface.sharedInterface.maxConnectionsCount;\n            },\n            set(value) {\n                sharedInterface.sharedInterface.maxConnectionsCount = value;\n            },\n        });\n        Object.defineProperty(intf, 'connectionCount', {\n            get() {\n                return sharedInterface.sharedInterface.connectionCount;\n            },\n            set(value) {\n                sharedInterface.sharedInterface.connectionCount = value;\n            },\n        });\n        Object.defineProperty(intf, 'type', {\n            get() {\n                return sharedInterface.sharedInterface.type;\n            },\n        });\n    }\n    /**\n     * Checks if the interface of given id is registered.\n     *\n     * @param {string} intfId Id of the interface to check.\n     * @returns {boolean} True if the interface is registered, false otherwise.\n     */\n    isRegistered(intfId) {\n        return this.exposedInterfaces.has(intfId);\n    }\n    /**\n     * Returns the registered interface of given id. If the interface is not registered,\n     * an error is thrown.\n     *\n     * @param {string} intfId Id of the interface to get.\n     */\n    getRegisteredInterface(intfId) {\n        if (!this.exposedInterfaces.has(intfId)) {\n            throw new Error(`Interface of id ${intfId} is not registered.`);\n        }\n        return this.exposedInterfaces.get(intfId);\n    }\n    /**\n     * Deletes the registered interface of given id. If the interface is not registered,\n     * an error is thrown.\n     *\n     * @param {string} intfId Id of the interface to delete\n     */\n    deleteRegisteredInterface(intfId) {\n        if (!this.exposedInterfaces.has(intfId)) {\n            throw new Error(`Interface of id ${intfId} is not registered.`);\n        }\n        return this.exposedInterfaces.delete(intfId);\n    }\n    /**\n     * Registers an interface in the registry, so that it can be shared between\n     * multiple graph nodes. If the interface is already registered, an error is thrown.\n     *\n     * @param {NodeInterface} intf Interface to register.\n     */\n    registerInterface(intf, graphId) {\n        if (this.exposedInterfaces.has(intf.id)) {\n            throw new Error(`Trying to register an interface of id ${intf.id}, but it is already registered.`);\n        }\n        this.exposedInterfaces.set(intf.id, {\n            sharedInterface: intf,\n            sharedInterfaceGraphId: graphId,\n            graphIds: [],\n        });\n    }\n}\nexport const ir = new InterfaceRegistry();\n","/*\n * Copyright (c) 2022-2023 Antmicro <www.antmicro.com>\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Handles incoming notifications from Pipeline Manager: creates toast\n * notifications (popup), adds them to store for notifications panel,\n * logs appropriate notification to terminal window\n */\n\nimport { createToastInterface, POSITION } from 'vue-toastification';\nimport { notificationStore, terminalStore } from './stores.js';\nimport Notification from '../components/Notification.vue';\nimport EditorManager from './EditorManager';\n\nconst toast = createToastInterface({\n    timeout: 5000,\n    position: POSITION.BOTTOM_RIGHT,\n    icon: false,\n    closeButton: false,\n});\n\nexport const LOG_LEVEL = {\n    info: 0,\n    warning: 1,\n    error: 2,\n};\n\nexport default class NotificationHandler {\n    static NotificationHandler = true;\n\n    static defaultShowOption = true;\n\n    /**\n     * Sets the showNotification flag. If set to false, no popup\n     * notifications are shown\n     *\n     * @param show new value for showNotification\n     */\n    static setShowNotification(show) {\n        NotificationHandler.showNotifications = show;\n    }\n\n    /**\n     * Sets the default showNotification flag value.\n     * Does not change whether the notifications are actually set or not,\n     * this should be done in `setShowNotification` or `restoreShowNotification`\n     * methods\n     *\n     * @param showOption default value for showNotification flag\n     */\n    static setShowOption(showOption) {\n        NotificationHandler.defaultShowOption = showOption;\n    }\n\n    /**\n     * Restores show notification flag to it's default value\n     */\n    static restoreShowNotification() {\n        NotificationHandler.showNotifications = NotificationHandler.defaultShowOption;\n    }\n\n    static showToast(type, message) {\n        const content = {\n            component: Notification,\n            props: {\n                type,\n                message,\n            },\n        };\n\n        if (\n            LOG_LEVEL[type] >= LOG_LEVEL[\n                EditorManager.getEditorManagerInstance().baklavaView.logLevel?.toLowerCase()\n            ] && NotificationHandler.showNotifications\n        ) {\n            toast(content);\n        } else {\n            const bell = document.querySelector('#navbar-bell>.indicator');\n            if (bell) {\n                bell.classList.remove('animate');\n                setTimeout(() => bell.classList.add('animate'), 300);\n            }\n        }\n        notificationStore.add({ type, message });\n    }\n\n    /**\n     * Helper function that displays the title of the message as a toast notification and\n     * a full message in terminal with a proper title.\n     *\n     * @param {string} type Type of the toast notification\n     * @param {string} title Title of the message used both for toast and terminal notification.\n     * Preferably without any punctuation marks at the end\n     * @param {Array[string] | string | undefined} messages messages that are displayed in\n     * the terminal\n     */\n    static terminalLog(type, title, messages) {\n        NotificationHandler.showToast(type, title);\n        terminalStore.addParsed(title, messages);\n    }\n}\n"],"names":["ExternalBackendApp","constructor","url","jsonRPC","maxMessageLength","Object","defineProperty","this","enumerable","configurable","writable","value","socket","io","extraHeaders","commonHeaders","on","terminalLog","rejectAllPendingRequests","data","response","server","receive","ack","emitWithAck","undefined","error","method","client","isConnected","status","connected","request","externalApp","_a","onConnect","unknownError","messageType","code","EXCEPTION_RAISED","NEWER_SESSION_AVAILABLE","message","endpoint","disconnected","Error","stringify","JSON","length","messageID","id","crypto","randomUUID","i","emit","chunk","substring","Math","min","end","ConnectionManager","connectionHook","disconnectionHook","Map","add","set","remove","delete","poll","arguments","interval","isRunning","updating","Set","keys","filter","has","forEach","updateConnection","then","Promise","resolve","setTimeout","wasConnected","get","pollStop","ExternalFrontendApp","source","postMessage","defaultAppCapabilities","handleExternalAppResponse","type","OK","content","ERROR","WARNING","handleSpecificationResult","errors","warnings","info","errorTitle","warningTitle","infTitle","Array","isArray","showVersionError","currentVersion","usedVersion","ExternalApplicationManager","editorManager","EditorManager","getEditorManagerInstance","appCapabilities","externalApplicationManager","connectionManager","initializeConnection","itemInfo","inProgress","isExternalAppAvailable","from","values","some","Boolean","params","requestSpecification","specification","updateSpecification","conditionalLoadingScreen","load","callback","setLoad","baklavaView","editor","events","result","urloverrides","String","success","specificationOrError","validateSpecification","specificationVersion","parse","version","updateEditorSpecification","updateDataflow","dataflow","dataflowOrError","loadDataflow","requestAppCapabilities","requestDataflowExport","saveDataflow","requestDataflowAction","procedureName","requireResponse","runProcedureInfo","validatedProcedureName","customMethodRegex","test","customMethodReplace","showToast","startsWith","requestDataflowStop","importDataflow","file","document","getElementById","files","reader","FileReader","encoding","charset","readerPromise","onloadend","replace","readAsText","readAsDataURL","external_application_dataflow","mime","base64","notifyAboutChange","changedProperties","notifyWhenChanged","requestTerminalRead","terminalName","name","_externalApp","all","JSONRPCErrorCode","MethodNotFound","EXTERNAL_APPLICATION_NOT_CONNECTED","registerConnectionHook","registerApplication","registerBackendApplication","registerFrontendApplication","sourceWindow","logAndRespond","msgType","msg","logType","createJSONRPCErrorResponse","createJSONRPCSuccessResponse","window","getExternalApplicationManager","RunInfo","progressBar","querySelector","pr_inProgress","classList","style","width","hook","DefaultMap","defaultFactory","super","key","newValue","setHook","v","setTerminalHeight","y","h","mouseMoveHandler","e","clientY","mouseUpHandler","terminalWrapper","removeEventListener","mouseDownHandler","setHeight","styles","getComputedStyle","parseInt","height","addEventListener","parseProperties","properties","parsedProperties","usedNames","prop","group","parsedGroup","push","entries","pgroupname","realname","slice","indexOf","createProperties","getIntf","p","hidden","propName","propType","intf","propDef","default","readonly","max","toLowerCase","BigInt","NaN","it","map","element","toString","step","dtype","open","updated","console","interfaceMaxConnectionsCount","interfaceType","tempProperties","pname","groupedProperty","pgroup","parseNodeState","state","newState","interfaces","out","inputs","outputs","enabledInterfaceGroups","interfaceGroups","direction","title","instanceName","parsed","CustomNode","layer","twoColumn","description","nodeExtends","nodeExtending","nodeSiblings","relatedGraphs","extends","extending","siblings","k","addInput","addOutput","updateDynamicInterfaces","propertyInput","split","interfaceName","occupied","left","right","stateIOs","ioName","ioState","side","sidePosition","directionIoName","container","externalName","prototype","hasOwnProperty","call","firstUnoccupied","sort","a","b","findIndex","index","maxConnectionCount","match","removeOutput","removeInput","join","newInputs","newOutputs","baklavaIntf","assign","node","graph","nodes","find","n","updateInterfaces","bind","reactiveUpdate","toggleInterfaceGroup","visible","graphInstance","connections","c","to","removeConnection","save","savedState","newProperties","newInterfaces","port","stateInputs","stateOutputs","include","includes","prefix","privatizeInterface","idA","intfA","foundIntf","idB","intfB","addInterface","updateProperties","stateProperties","propA","baklavaProp","parsedState","isWebpack","endsWith","parsedValue","propertyType","checkType","items","mismatchedElements","val","Number","isInteger","groupName","detectDiscrepancies","groupState","stateios","refreshSidePositions","maxposition","position","onPlaced","externalRequest","_","componentName","subscribe","onDestroy","event","unsubscribe","createBaklavaInterfaces","parsedInterfaces","createBaklavaInterface","fromEntries","CustomNodeFactory","defaultInterfaceGroups","generatedProperties","updateSubgraphInterfaces","INTERFACE_PREFIXES","exposedIntf","flat","countedIntfNames","create","externalInterfaces","errorMessages","graphId","ir","isRegistered","getRegisteredInterface","sharedInterface","sharedInterfaceGraphId","deleteRegisteredInterface","registerInterface","idx","x","newInterfacesPositionsOrErrors","GraphFactory","menuState","configurationMenu","addNode","placeNode","propertyMenu","interfaceMenu","propertyListMenu","interfaceListMenu","layerMenu","configurationState","nodeData","category","color","CytoscapeLayoutEngine","availableAlgorithms","calculate","cytoscapeGraph","elements","edges","connection","target","selector","shape","styleEnabled","options","activeAlgorithm","boundingBox","x1","y1","w","avoidOverlapPadding","nodeOverlap","idealEdgeLength","edge","nodeSpacing","ranker","nodeSep","rankSep","layout","run","promiseOn","defaultDirection","DYNAMIC_INTERFACE_SUFFIX","createInterface","originalSide","originalSidePosition","parseSingleInterfaces","interfaceGroup","tempParsed","input","inout","output","tempIO","array","j","buildingIO","bdirection","filteredTempInouts","duplicate","validateInterfaceGroupsNames","usedInterfaces","groupDirection","intfName","intfDirection","parsedIntfName","validateInterfaceGroups","applySidePositions","tempParsedSides","stripName","occupiedInputSidePositions","occupiedOutputSidePositions","leftSidePositionIndex","rightSidePositionIndex","getLeftSidePos","getRightSidePos","generateProperties","dynamic","interfaceMaxConnectionCount","parseInterfaces","intfG","directionG","tempParsedGroups","interfacesCreatingGroups","enabledInterfaceGroupsNames","parsedSides","createdInterfaces","Specification","static","currentSpecification","includedSpecification","unresolvedSpecification","instance","getInstance","getNodeSpecification","nodeName","NoLayoutAlgorithm","backendApiUrl","URLSearchParams","location","search","protocol","getBackendApiUrl","PMMessageType","PROGRESS","JSONRPCCustomErrorCode","storageAvailable","randomKey","random","randomValue","localStorage","setItem","removeItem","pmStorage","getItem","notificationStore","notifications","notification","removeOne","newNotifications","MAIN_TERMINAL","terminalStore","logs","Terminal","readOnly","log","isReadOnly","addParsed","messages","parsedMessage","clear","exists","getInstances","createTerminalInstance","show","manager","commitTypeToSpecification","newNodeData","currentType","editedType","_unregisterNodeType","ret","addNodeToEditorSpecification","findNodes","nodeType","viewModel","allNodes","graphs","createNode","nodeTypes","modifyConfiguration","highlightedType","alterProperties","createdProperties","alterInterfaces","addProperty","property","validateNodeProperty","removeProperties","item","_b","validateNodeInterface","removeInterfaces","BaseLayoutEngine","chooseAlgorithm","algorithm","BaseLayoutAlgorithm","doubleClick","timer","doubleClickTimer","lastClickTime","ev","Date","now","gridSnapper","movementStep","coord","round","nodeSnapper","kind","nodeId","selectedNodesIds","nearestCoords","otherCoords","abs","checkTerminalExistence","getGraph","graph_id","g","getNode","node_id","getProperty","frontend_specification_get","saveSpecification","graph_get","properties_change","new_value","position_change","nodes_change","added","setNodeColor","deleted","remove_with_connections","removeNode","removeNodeOnly","connections_change","fromIntf","findNodeInterface","toIntf","addConnection","getConnection","graph_change","loadingScreen","properties_get","node_get","progress_change","procedureInfo","progress","metadata_change","updateMetadata","metadata","viewport_center","centerZoom","terminal_add","terminal_remove","terminal_write","terminal_clear","terminal_hide","hide","terminal_show","terminal_view","names","view","terminal_get_instances","notification_send","details","specification_change","specification_graph_change","nodes_highlight","selectedNodes","unselected","selected","register_external_frontend","CustomJSONRPCServerAndClient","JSONRPCServerAndClient","ajv","schemas","allowUnionTypes","strict","frontendEndpoints","backendEndpoints","s","externalEndpoints","invalidDefinition","endpoints","definitionName","definition","compile","returns","exception","validateServerRequestResponse","next","serverParams","schema","validate","jsonRPCID","createID","requestSchema","jsonRPCServer","validateClientResponse","CustomJSONRPCClient","JSONRPCClient","responses","JSONRPCServer","request_1","reject","applyMiddleware","func","addMethod","createServer","clearRegistry","exposedInterfaces","pushGraphIdToRegistry","intfId","graphIds","createSharedInterface","maxConnectionsCount","connectionCount","toast","timeout","BOTTOM_RIGHT","icon","closeButton","LOG_LEVEL","warning","NotificationHandler","setShowNotification","showNotifications","setShowOption","showOption","defaultShowOption","restoreShowNotification","component","props","logLevel","bell"],"sourceRoot":""}