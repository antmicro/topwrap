# Generator

{class}`~topwrap.backend.generator.Generator` is used for generating {class}`~topwrap.model.design.ModuleInstance` and HDL code.
There can be a {class}`~topwrap.backend.generator.Generator` for each {class}`~topwrap.model.interconnect.Interconnect` and for each {class}`~topwrap.backend.backend.Backend`.

Each Generator needs to implement the {meth}`~topwrap.backend.generator.Generator.generate()` method that will generate interconnect code specific for used backend.
```python
generate(self, interconnect: _IT, module_instance: ModuleInstance) -> _T:
  pass
```
`_IT` is bound to `Interconnect` and is set by interconnect-specific implementation (e.g. `WishboneRRSystemVerilogGenerator`). \
`_T` isn't bound and is set by backend-specific implementation (e.g. `SystemVerilogGenerator`).

:::{note}
Backend-specific generators inheritance from Generator (e.g. {class}`~topwrap.backend.sv.generators.SystemVerilogGenerator`). \
Interconnect-specific generators inheritance from backend-specific (e.g. {class}`~topwrap.backend.sv.generators.WishboneRRSystemVerilogGenerator`).
:::

Generated HDL code need to follow naming convention, for ports it is set by {meth}`~topwrap.backend.generator.Generator.get_name()`, and for {class}`~topwrap.model.design.Module` by default it is `interconnect_{interconnect.name}`.
{meth}`~topwrap.backend.generator.Generator.add_module_instance_to_design()` is used to create ModuleInstance and add it to {class}`~topwrap.model.design.Design`, it can be overridden when generated HDL code needs it.

:::{important}
`clk` and `rst` ports are always generated by default, if `generate()` method don't create these ports it is needed to override `add_module_instance_to_design()` to change that behavior.
:::

Backend-specific implementation can introduce new methods that the interconnect-specific class can implement or use.
Each backends need to have its own lookup list that contains `Interconnect` and is mapped to `Generator`


## How to implement a Generator
Based on example of `WishboneRRSystemVerilogGenerator`, a new SystemVerilog-based generator can be implemented as follows.
Create subclass of `SystemVerilogGenerator` and implement `generate()`.
It needs to return generated System Verilog code, the code needs to have same ports as generated `ModuleInstance`.
To make name generation less prone to errors use `get_name()` in implementation of `generate()` or override `get_name()` with your naming convention.

## Lookup maps
`SystemVerilogBackend` uses {const}`~topwrap.backend.sv.generators.verilog_generators_map` as lookup map.

## API Reference
```{eval-rst}
.. autoclass:: topwrap.backend.generator.Generator
   :members:
   :private-members:
```

```{eval-rst}
.. autoclass:: topwrap.backend.sv.generators.SystemVerilogGenerator
   :members:
   :private-members:
```

```{eval-rst}
.. autoclass:: topwrap.backend.sv.generators.WishboneRRSystemVerilogGenerator
   :members:
   :private-members:
```

```{eval-rst}
.. autodata:: topwrap.backend.sv.generators.verilog_generators_map
   :no-value:
```
